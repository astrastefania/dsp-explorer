webpackJsonp([0],{

/***/ 291:
/* no static exports found */
/* all exports used */
/*!**************************************!*\
  !*** ./dashboard/static/js/index.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _angular = __webpack_require__(/*! angular */ 50);\n\nvar angular = _interopRequireWildcard(_angular);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n__webpack_require__(/*! ../../../~/ngmap */ 621);\n\n// Import this app style\n__webpack_require__(/*! ../style/index.scss */ 623);\n// Require static angular componenets\nvar baseImports = __webpack_require__(/*! ../../../static/js/index */ 94);\n// Angular form imports\nbaseImports.angularForm();\n\n// Stuff\n__webpack_require__(/*! ng-infinite-scroll */ 620);\n__webpack_require__(/*! ../../../~/vsGoogleAutocomplete/dist/vs-google-autocomplete */ 627);\n\n// Init Angular APP\nvar app = angular.module('dashboard', ['ui.bootstrap', 'toastr', 'ui.select', 'ngSanitize', 'ngAnimate', 'mgcrea.ngStrap', 'infinite-scroll', 'vsGoogleAutocomplete', 'ngMap']).config(['$interpolateProvider', function ($interpolateProvider) {\n    $interpolateProvider.startSymbol('{$');\n    $interpolateProvider.endSymbol('$}');\n}]).config(['$qProvider', function ($qProvider) {\n    $qProvider.errorOnUnhandledRejections(false);\n}]);\n\n// Require base angular componenets\nbaseImports.angularBase(app).directives(app).dataVizDirectives(app);\n\napp.controller('landingController', __webpack_require__(/*! ./controllers/landing.controller */ 306).default);\napp.controller('dashboardController', __webpack_require__(/*! ./controllers/dashboard.controller */ 305).default);\napp.controller('onboardingController', __webpack_require__(/*! ./controllers/onboarding.controller */ 307).default);\napp.controller('themesController', __webpack_require__(/*! ./controllers/themes.controller */ 309).default);\napp.controller('searchController', __webpack_require__(/*! ./controllers/searchmembers.controller */ 308).default);\napp.directive('userStories', __webpack_require__(/*! ./directives/UserStories.directive */ 310).default);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2Rhc2hib2FyZC9zdGF0aWMvanMvaW5kZXguanM/ODgyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhbmd1bGFyIGZyb20gJ2FuZ3VsYXInO1xucmVxdWlyZSgnLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25nbWFwJylcblxuLy8gSW1wb3J0IHRoaXMgYXBwIHN0eWxlXG5yZXF1aXJlKFwiLi4vc3R5bGUvaW5kZXguc2Nzc1wiKVxuLy8gUmVxdWlyZSBzdGF0aWMgYW5ndWxhciBjb21wb25lbmV0c1xubGV0IGJhc2VJbXBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL3N0YXRpYy9qcy9pbmRleFwiKVxuLy8gQW5ndWxhciBmb3JtIGltcG9ydHNcbmJhc2VJbXBvcnRzLmFuZ3VsYXJGb3JtKClcblxuLy8gU3R1ZmZcbnJlcXVpcmUoJ25nLWluZmluaXRlLXNjcm9sbCcpXG5yZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3ZzR29vZ2xlQXV0b2NvbXBsZXRlL2Rpc3QvdnMtZ29vZ2xlLWF1dG9jb21wbGV0ZVwiKTtcblxuLy8gSW5pdCBBbmd1bGFyIEFQUFxudmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdkYXNoYm9hcmQnLCBbXG4gICAgJ3VpLmJvb3RzdHJhcCcsICd0b2FzdHInLCAndWkuc2VsZWN0JywnbmdTYW5pdGl6ZScsICduZ0FuaW1hdGUnLCdtZ2NyZWEubmdTdHJhcCcsICdpbmZpbml0ZS1zY3JvbGwnLCAndnNHb29nbGVBdXRvY29tcGxldGUnLCAnbmdNYXAnXG5dKVxuICAgIC5jb25maWcoWyckaW50ZXJwb2xhdGVQcm92aWRlcicsIGZ1bmN0aW9uKCRpbnRlcnBvbGF0ZVByb3ZpZGVyKSB7XG4gICAgICAgICAgICAkaW50ZXJwb2xhdGVQcm92aWRlci5zdGFydFN5bWJvbCgneyQnKTtcbiAgICAgICAgICAgICRpbnRlcnBvbGF0ZVByb3ZpZGVyLmVuZFN5bWJvbCgnJH0nKTtcbiAgICB9XSlcbiAgICAuY29uZmlnKFsnJHFQcm92aWRlcicsIGZ1bmN0aW9uICgkcVByb3ZpZGVyKSB7JHFQcm92aWRlci5lcnJvck9uVW5oYW5kbGVkUmVqZWN0aW9ucyhmYWxzZSk7fV0pO1xuXG4vLyBSZXF1aXJlIGJhc2UgYW5ndWxhciBjb21wb25lbmV0c1xuYmFzZUltcG9ydHMuYW5ndWxhckJhc2UoYXBwKVxuICAgIC5kaXJlY3RpdmVzKGFwcClcbiAgICAuZGF0YVZpekRpcmVjdGl2ZXMoYXBwKVxuXG5cbmFwcC5jb250cm9sbGVyKCdsYW5kaW5nQ29udHJvbGxlcicsIHJlcXVpcmUoJy4vY29udHJvbGxlcnMvbGFuZGluZy5jb250cm9sbGVyJykuZGVmYXVsdCApXG5hcHAuY29udHJvbGxlcignZGFzaGJvYXJkQ29udHJvbGxlcicsIHJlcXVpcmUoJy4vY29udHJvbGxlcnMvZGFzaGJvYXJkLmNvbnRyb2xsZXInKS5kZWZhdWx0IClcbmFwcC5jb250cm9sbGVyKCdvbmJvYXJkaW5nQ29udHJvbGxlcicsIHJlcXVpcmUoJy4vY29udHJvbGxlcnMvb25ib2FyZGluZy5jb250cm9sbGVyJykuZGVmYXVsdCApXG5hcHAuY29udHJvbGxlcigndGhlbWVzQ29udHJvbGxlcicsIHJlcXVpcmUoJy4vY29udHJvbGxlcnMvdGhlbWVzLmNvbnRyb2xsZXInKS5kZWZhdWx0IClcbmFwcC5jb250cm9sbGVyKCdzZWFyY2hDb250cm9sbGVyJywgcmVxdWlyZSgnLi9jb250cm9sbGVycy9zZWFyY2htZW1iZXJzLmNvbnRyb2xsZXInKS5kZWZhdWx0IClcbmFwcC5kaXJlY3RpdmUoJ3VzZXJTdG9yaWVzJywgcmVxdWlyZSgnLi9kaXJlY3RpdmVzL1VzZXJTdG9yaWVzLmRpcmVjdGl2ZScpLmRlZmF1bHQgKVxuXG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBkYXNoYm9hcmQvc3RhdGljL2pzL2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFEQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 305:
/* no static exports found */
/* all exports used */
/*!*****************************************************************!*\
  !*** ./dashboard/static/js/controllers/dashboard.controller.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n/**\n * Created by andreafspeziale on 06/07/17.\n */\n\nexports.default = ['$scope', '$http', function ($scope, $http) {\n\n    $scope.get_om_events = function () {\n        $http({\n            'method': 'GET',\n            'url': '/api/v1.1/get_om_events'\n        });\n    };\n\n    $scope.get_om_events();\n}];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2Rhc2hib2FyZC9zdGF0aWMvanMvY29udHJvbGxlcnMvZGFzaGJvYXJkLmNvbnRyb2xsZXIuanM/M2U3YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZWQgYnkgYW5kcmVhZnNwZXppYWxlIG9uIDA2LzA3LzE3LlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IFsgJyRzY29wZScsICckaHR0cCcsIGZ1bmN0aW9uICgkc2NvcGUsICRodHRwKSB7XG4gICAgXG4gICAgJHNjb3BlLmdldF9vbV9ldmVudHMgPSBmdW5jdGlvbigpe1xuICAgICAgICAkaHR0cCh7XG4gICAgICAgICAgICAnbWV0aG9kJzogJ0dFVCcsXG4gICAgICAgICAgICAndXJsJzogJy9hcGkvdjEuMS9nZXRfb21fZXZlbnRzJ1xuICAgICAgICB9KVxuICAgIH07XG5cbiAgICAkc2NvcGUuZ2V0X29tX2V2ZW50cygpXG5cbn1dXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGRhc2hib2FyZC9zdGF0aWMvanMvY29udHJvbGxlcnMvZGFzaGJvYXJkLmNvbnRyb2xsZXIuanMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 306:
/* no static exports found */
/* all exports used */
/*!***************************************************************!*\
  !*** ./dashboard/static/js/controllers/landing.controller.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _d = __webpack_require__(/*! d3 */ 35);\n\nvar d3 = _interopRequireWildcard(_d);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nexports.default = ['$scope', '$uibModal', '$http', function ($scope, $uibModal, $http) {\n\n    var root_node_size = 30;\n    var child_node_size = 20;\n    var data_nodes = [{ id: 0, amount: root_node_size, name: \"ARDUINO\" }, { id: 1, amount: root_node_size, name: \"3D PRINTER\" }, { id: 2, amount: root_node_size, name: \"RASPBERRY Pi\" }, { id: 3, amount: child_node_size, name: \"Raspberry_Pi\" }, { id: 4, amount: child_node_size, name: \"arduino\" }, { id: 5, amount: child_node_size, name: \"make\" }, { id: 6, amount: child_node_size, name: \"3dprintindustry\" }, { id: 7, amount: child_node_size, name: \"3DPrintGirl\" }, { id: 8, amount: child_node_size, name: \"3dersorg\" }, { id: 9, amount: child_node_size, name: \"htpc_guides\" }, { id: 10, amount: child_node_size, name: \"hackaday\" }];\n    var data_links = [{ 'source': 0, 'target': 1 }, { 'source': 0, 'target': 2 }, { 'source': 1, 'target': 2 }, { 'source': 0, 'target': 3 }, { 'source': 0, 'target': 4 }, { 'source': 0, 'target': 5 }, { 'source': 1, 'target': 6 }, { 'source': 1, 'target': 7 }, { 'source': 1, 'target': 8 }, { 'source': 2, 'target': 3 }, { 'source': 2, 'target': 9 }, { 'source': 2, 'target': 10 }];\n    createNetwork(data_links, '#theme_graph', '#DB4348', data_nodes);\n}]; /**\n     * Created by andreafspeziale on 03/05/17.\n     */\n\nfunction createNetwork(data_links, svg_id, c, data_nodes) {\n    var svg = d3.select(svg_id);\n\n    var simulation = d3.forceSimulation(data_nodes).force('link', d3.forceLink(data_links).distance(50).strength(0.01)).force('charge', d3.forceManyBody()).force('center', d3.forceCenter(300, 300)).on('tick', tick);\n\n    var links = svg.append(\"g\").attr(\"class\", \"links\").selectAll(\"line\").data(data_links).enter().append('line').style('stroke', '#7A7378');\n\n    var nodes = svg.selectAll(\".node\").data(data_nodes).enter().append(\"g\").attr(\"class\", \"node\").call(d3.drag().on(\"start\", dragstarted).on(\"drag\", dragged).on(\"end\", dragended)).on('mouseover', function (d) {\n        d3.select(this).select('text').transition().duration(200).attr('opacity', 1);\n    }).on(\"mouseout\", function (d) {\n        d3.select(this).select('text').transition().duration(200).attr('opacity', function (d) {\n            return get_opacity_for_node(d);\n        });\n    });\n\n    var node = nodes.append('circle').style('fill', function (d) {\n        if (is_source_node(d)) {\n            return c;\n        } else {\n            return '#1CA4A4';\n        }\n    }).attr('r', function (d) {\n        return d.amount;\n    });\n\n    var nodeText = nodes.append(\"text\").attr('opacity', function (d) {\n        return get_opacity_for_node(d);\n    }).text(function (d) {\n        return d.name;\n    });\n\n    function is_source_node(d) {\n        return d.id == 0 || d.id == 1 || d.id == 2;\n    }\n\n    function get_opacity_for_node(d) {\n        if (is_source_node(d)) {\n            return 1;\n        }\n        return 0;\n    }\n\n    function tick() {\n        node.attr('cx', function (d) {\n            return d.x;\n        }).attr('cy', function (d) {\n            return d.y;\n        });\n        links.attr('x1', function (d) {\n            return d.source.x;\n        }).attr('y1', function (d) {\n            return d.source.y;\n        }).attr('x2', function (d) {\n            return d.target.x;\n        }).attr('y2', function (d) {\n            return d.target.y;\n        });\n        nodeText.attr('x', function (d) {\n            return d.x;\n        }).attr('y', function (d) {\n            return d.y;\n        });\n    }\n\n    function dragstarted(d) {\n        if (!d3.event.active) simulation.alphaTarget(0.3).restart();\n        d.fx = d.x;\n        d.fy = d.y;\n    }\n\n    function dragged(d) {\n        d.fx = d3.event.x;\n        d.fy = d3.event.y;\n    }\n\n    function dragended(d) {\n        if (!d3.event.active) simulation.alphaTarget(0);\n        d.fx = null;\n        d.fy = null;\n    }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2Rhc2hib2FyZC9zdGF0aWMvanMvY29udHJvbGxlcnMvbGFuZGluZy5jb250cm9sbGVyLmpzPzdlZDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcmVhdGVkIGJ5IGFuZHJlYWZzcGV6aWFsZSBvbiAwMy8wNS8xNy5cbiAqL1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuZXhwb3J0IGRlZmF1bHQgWyAnJHNjb3BlJywnJHVpYk1vZGFsJywnJGh0dHAnLCBmdW5jdGlvbiAoJHNjb3BlLCR1aWJNb2RhbCwkaHR0cCkge1xuXG4gICAgbGV0IHJvb3Rfbm9kZV9zaXplID0gMzA7XG4gICAgbGV0IGNoaWxkX25vZGVfc2l6ZSA9IDIwO1xuICAgIGxldCBkYXRhX25vZGVzID0gW3tpZDogMCwgYW1vdW50OnJvb3Rfbm9kZV9zaXplLCBuYW1lOlwiQVJEVUlOT1wifSxcbiAgICAgICAge2lkOiAxLCBhbW91bnQ6IHJvb3Rfbm9kZV9zaXplLCBuYW1lOlwiM0QgUFJJTlRFUlwifSxcbiAgICAgICAge2lkOiAyLCBhbW91bnQ6IHJvb3Rfbm9kZV9zaXplLCBuYW1lOlwiUkFTUEJFUlJZIFBpXCJ9LFxuICAgICAgICB7aWQ6IDMsIGFtb3VudDogY2hpbGRfbm9kZV9zaXplLCBuYW1lOlwiUmFzcGJlcnJ5X1BpXCJ9LFxuICAgICAgICB7aWQ6IDQsIGFtb3VudDogY2hpbGRfbm9kZV9zaXplLCBuYW1lOlwiYXJkdWlub1wifSxcbiAgICAgICAge2lkOiA1LCBhbW91bnQ6IGNoaWxkX25vZGVfc2l6ZSwgbmFtZTpcIm1ha2VcIn0sXG4gICAgICAgIHtpZDogNiwgYW1vdW50OiBjaGlsZF9ub2RlX3NpemUsIG5hbWU6XCIzZHByaW50aW5kdXN0cnlcIn0sXG4gICAgICAgIHtpZDogNywgYW1vdW50OiBjaGlsZF9ub2RlX3NpemUsIG5hbWU6XCIzRFByaW50R2lybFwifSxcbiAgICAgICAge2lkOiA4LCBhbW91bnQ6IGNoaWxkX25vZGVfc2l6ZSwgbmFtZTpcIjNkZXJzb3JnXCJ9LFxuICAgICAgICB7aWQ6IDksIGFtb3VudDogY2hpbGRfbm9kZV9zaXplLCBuYW1lOlwiaHRwY19ndWlkZXNcIn0sXG4gICAgICAgIHtpZDogMTAsIGFtb3VudDogY2hpbGRfbm9kZV9zaXplLCBuYW1lOlwiaGFja2FkYXlcIn0sXG4gICAgXTtcbiAgICBsZXQgZGF0YV9saW5rcyA9IFt7J3NvdXJjZSc6IDAsICd0YXJnZXQnOiAxfSxcbiAgICAgICAgeydzb3VyY2UnOiAwLCAndGFyZ2V0JzogMn0sXG4gICAgICAgIHsnc291cmNlJzogMSwgJ3RhcmdldCc6IDJ9LFxuICAgICAgICB7J3NvdXJjZSc6IDAsICd0YXJnZXQnOiAzfSxcbiAgICAgICAgeydzb3VyY2UnOiAwLCAndGFyZ2V0JzogNH0sXG4gICAgICAgIHsnc291cmNlJzogMCwgJ3RhcmdldCc6IDV9LFxuICAgICAgICB7J3NvdXJjZSc6IDEsICd0YXJnZXQnOiA2fSxcbiAgICAgICAgeydzb3VyY2UnOiAxLCAndGFyZ2V0JzogN30sXG4gICAgICAgIHsnc291cmNlJzogMSwgJ3RhcmdldCc6IDh9LFxuICAgICAgICB7J3NvdXJjZSc6IDIsICd0YXJnZXQnOiAzfSxcbiAgICAgICAgeydzb3VyY2UnOiAyLCAndGFyZ2V0JzogOX0sXG4gICAgICAgIHsnc291cmNlJzogMiwgJ3RhcmdldCc6IDEwfV07XG4gICAgY3JlYXRlTmV0d29yayhkYXRhX2xpbmtzLCAnI3RoZW1lX2dyYXBoJywgJyNEQjQzNDgnLCBkYXRhX25vZGVzKVxuXG59XVxuXG5mdW5jdGlvbiBjcmVhdGVOZXR3b3JrKGRhdGFfbGlua3MsIHN2Z19pZCwgYywgZGF0YV9ub2Rlcyl7XG4gICAgbGV0IHN2ZyA9IGQzLnNlbGVjdChzdmdfaWQpO1xuXG4gICAgbGV0IHNpbXVsYXRpb24gPSBkMy5mb3JjZVNpbXVsYXRpb24oZGF0YV9ub2RlcylcbiAgICAgICAgLmZvcmNlKCdsaW5rJywgZDMuZm9yY2VMaW5rKGRhdGFfbGlua3MpLmRpc3RhbmNlKDUwKS5zdHJlbmd0aCgwLjAxKSlcbiAgICAgICAgLmZvcmNlKCdjaGFyZ2UnLCBkMy5mb3JjZU1hbnlCb2R5KCkpXG4gICAgICAgIC5mb3JjZSgnY2VudGVyJywgZDMuZm9yY2VDZW50ZXIoMzAwLCAzMDApKVxuICAgICAgICAub24oJ3RpY2snLCB0aWNrKTtcblxuICAgIGxldCBsaW5rcyA9IHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsaW5rc1wiKVxuICAgICAgICAuc2VsZWN0QWxsKFwibGluZVwiKVxuICAgICAgICAuZGF0YShkYXRhX2xpbmtzKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCdsaW5lJylcbiAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAnIzdBNzM3OCcpO1xuXG4gICAgbGV0IG5vZGVzID0gc3ZnLnNlbGVjdEFsbChcIi5ub2RlXCIpXG4gICAgICAgIC5kYXRhKGRhdGFfbm9kZXMpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGVcIilcbiAgICAgICAgLmNhbGwoZDMuZHJhZygpXG4gICAgICAgICAgICAub24oXCJzdGFydFwiLCBkcmFnc3RhcnRlZClcbiAgICAgICAgICAgIC5vbihcImRyYWdcIiwgZHJhZ2dlZClcbiAgICAgICAgICAgIC5vbihcImVuZFwiLCBkcmFnZW5kZWQpKVxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbigyMDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAxKVxuICAgICAgICB9KVxuICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc2VsZWN0KCd0ZXh0JylcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgLmR1cmF0aW9uKDIwMClcbiAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0X29wYWNpdHlfZm9yX25vZGUoZCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICBsZXQgbm9kZSA9IG5vZGVzLmFwcGVuZCgnY2lyY2xlJylcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGlmKGlzX3NvdXJjZV9ub2RlKGQpKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHJldHVybiAnIzFDQTRBNCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdyJywgKGQpID0+IGQuYW1vdW50KTtcblxuICAgIGxldCBub2RlVGV4dCA9IG5vZGVzLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoJ29wYWNpdHknLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgIHJldHVybiBnZXRfb3BhY2l0eV9mb3Jfbm9kZShkKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRleHQoKGQpID0+IGQubmFtZSk7XG5cbiAgICBmdW5jdGlvbiBpc19zb3VyY2Vfbm9kZShkKXtcbiAgICAgICAgcmV0dXJuIGQuaWQgPT0gMCB8fCBkLmlkID09IDEgfHwgZC5pZCA9PSAyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0X29wYWNpdHlfZm9yX25vZGUoZCl7XG4gICAgICAgIGlmKGlzX3NvdXJjZV9ub2RlKGQpKXtcbiAgICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aWNrICgpIHtcbiAgICAgICAgbm9kZS5hdHRyKCdjeCcsIChkKSA9PiBkLngpXG4gICAgICAgICAgICAuYXR0cignY3knLCAoZCkgPT4gZC55KTtcbiAgICAgICAgbGlua3MuYXR0cigneDEnLCAoZCkgPT4gZC5zb3VyY2UueClcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIChkKSA9PiBkLnNvdXJjZS55KVxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgKGQpID0+IGQudGFyZ2V0LngpXG4gICAgICAgICAgICAuYXR0cigneTInLCAoZCkgPT4gZC50YXJnZXQueSk7XG4gICAgICAgIG5vZGVUZXh0LmF0dHIoJ3gnLCAoZCkgPT4gZC54KVxuICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCkgPT4gZC55KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYWdzdGFydGVkKGQpIHtcbiAgICAgICAgaWYgKCFkMy5ldmVudC5hY3RpdmUpIHNpbXVsYXRpb24uYWxwaGFUYXJnZXQoMC4zKS5yZXN0YXJ0KCk7XG4gICAgICAgIGQuZnggPSBkLng7XG4gICAgICAgIGQuZnkgPSBkLnk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhZ2dlZChkKSB7XG4gICAgICAgIGQuZnggPSBkMy5ldmVudC54O1xuICAgICAgICBkLmZ5ID0gZDMuZXZlbnQueTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmFnZW5kZWQoZCkge1xuICAgICAgICBpZiAoIWQzLmV2ZW50LmFjdGl2ZSkgc2ltdWxhdGlvbi5hbHBoYVRhcmdldCgwKTtcbiAgICAgICAgZC5meCA9IG51bGw7XG4gICAgICAgIGQuZnkgPSBudWxsO1xuICAgIH1cblxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBkYXNoYm9hcmQvc3RhdGljL2pzL2NvbnRyb2xsZXJzL2xhbmRpbmcuY29udHJvbGxlci5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBR0E7QUFDQTtBQURBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFZQTtBQVlBO0FBRUE7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQU9BO0FBU0E7QUFJQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 307:
/* no static exports found */
/* all exports used */
/*!******************************************************************!*\
  !*** ./dashboard/static/js/controllers/onboarding.controller.js ***!
  \******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _lodash = __webpack_require__(/*! lodash */ 9);\n\nvar _ = _interopRequireWildcard(_lodash);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nexports.default = ['$scope', function ($scope) {\n\n    $scope._ = _;\n\n    $scope.$watch('birthdate', function (a, b) {\n        return a === b && ($scope.birthdate = new Date(a));\n    });\n\n    $scope.altInputFormats = ['M!/d!/yyyy'];\n    $scope.dateOptions = {\n        formatYear: 'yy',\n        maxDate: new m().subtract(13, 'years'),\n        initDate: new Date(new m().subtract(13, 'years')),\n        startingDay: 1\n    };\n    $scope.datePopup = { opened: false };\n\n    $scope.openDatePopUp = function () {\n        return $scope.datePopup.opened = true;\n    };\n    $scope.profileImageUpload = function (n) {\n        return $('#profile-image-input').trigger('click');\n    };\n\n    $scope.checkSocialUrl = function (url) {\n        return url.match(/http:\\/\\//) || url.match(/https:\\/\\//) || url.match(/www\\./) || url.match(/\\.com/) || url.match(/\\.it/) || url.match(/\\.org/) || url.match(/\\.net/);\n    };\n\n    $scope.addHttpToSocialUrl = function (url) {\n        if (!url.match(/http:\\/\\//) && !url.match(/https:\\/\\//)) url = 'https://' + url;\n        return url;\n    };\n\n    $scope.extractUserFromSocialUrl = function (url) {\n\n        if (url.match(/http:\\/\\//) || url.match(/https:\\/\\//)) url = url.replace('https://', '') && url.replace('http://', '');\n        if (url.match(/www\\./)) url = url.replace('www.', '');\n        if (url.match(/www\\./)) url = url.replace('www.', '');\n        if (url.match(/\\.com/)) url = url.replace('.com', '');\n        if (url.match(/\\.it/)) url = url.replace('.it', '');\n        if (url.match(/\\.org/)) url = url.replace('.org', '');\n        if (url.match(/\\.net/)) url = url.replace('.net', '');\n\n        var user = url.replace(/\\/$/, '').split('/').pop().trim();\n        return user !== '' ? user : url;\n    };\n}]; /**\n     * Created by andreafspeziale on 06/07/17.\n     *///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2Rhc2hib2FyZC9zdGF0aWMvanMvY29udHJvbGxlcnMvb25ib2FyZGluZy5jb250cm9sbGVyLmpzPzhjZGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcmVhdGVkIGJ5IGFuZHJlYWZzcGV6aWFsZSBvbiAwNi8wNy8xNy5cbiAqL1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnXG5cbmV4cG9ydCBkZWZhdWx0IFsgJyRzY29wZScsIGZ1bmN0aW9uICgkc2NvcGUpIHtcbiAgICBcbiAgICAkc2NvcGUuXyA9IF9cbiAgICBcbiAgICAkc2NvcGUuJHdhdGNoKCdiaXJ0aGRhdGUnLCAoYSxiKSA9PiBhPT09YiAmJiAoICRzY29wZS5iaXJ0aGRhdGUgPSBuZXcgRGF0ZShhKSApIClcbiAgICBcbiAgICAkc2NvcGUuYWx0SW5wdXRGb3JtYXRzID0gWydNIS9kIS95eXl5J107XG4gICAgJHNjb3BlLmRhdGVPcHRpb25zID0ge1xuICAgICAgICBmb3JtYXRZZWFyOiAneXknLFxuICAgICAgICBtYXhEYXRlOiBuZXcgbSgpLnN1YnRyYWN0KDEzLCAneWVhcnMnKSxcbiAgICAgICAgaW5pdERhdGU6IG5ldyBEYXRlKG5ldyBtKCkuc3VidHJhY3QoMTMsICd5ZWFycycpKSxcbiAgICAgICAgc3RhcnRpbmdEYXk6IDEsXG4gICAgfTtcbiAgICAkc2NvcGUuZGF0ZVBvcHVwID0ge29wZW5lZDogZmFsc2V9O1xuXG4gICAgJHNjb3BlLm9wZW5EYXRlUG9wVXAgPSAoKSA9PiAkc2NvcGUuZGF0ZVBvcHVwLm9wZW5lZCA9IHRydWVcbiAgICAkc2NvcGUucHJvZmlsZUltYWdlVXBsb2FkID0gbj0+JCgnI3Byb2ZpbGUtaW1hZ2UtaW5wdXQnKS50cmlnZ2VyKCdjbGljaycpXG4gICAgXG4gICAgJHNjb3BlLmNoZWNrU29jaWFsVXJsPSh1cmwpPT57XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB1cmwubWF0Y2goL2h0dHA6XFwvXFwvLykgfHwgdXJsLm1hdGNoKC9odHRwczpcXC9cXC8vKSB8fFxuICAgICAgICAgICAgdXJsLm1hdGNoKC93d3dcXC4vKSB8fFxuICAgICAgICAgICAgdXJsLm1hdGNoKC9cXC5jb20vKSB8fFxuICAgICAgICAgICAgdXJsLm1hdGNoKC9cXC5pdC8pIHx8XG4gICAgICAgICAgICB1cmwubWF0Y2goL1xcLm9yZy8pIHx8XG4gICAgICAgICAgICB1cmwubWF0Y2goL1xcLm5ldC8pXG4gICAgICAgIClcbiAgICB9XG4gICAgXG4gICAgJHNjb3BlLmFkZEh0dHBUb1NvY2lhbFVybCA9KHVybCk9PntcbiAgICAgICAgaWYoICF1cmwubWF0Y2goL2h0dHA6XFwvXFwvLykgJiYgIXVybC5tYXRjaCgvaHR0cHM6XFwvXFwvLykgKSB1cmwgPSAnaHR0cHM6Ly8nK3VybDtcbiAgICAgICAgcmV0dXJuIHVybFxuICAgIH1cbiAgICBcbiAgICAkc2NvcGUuZXh0cmFjdFVzZXJGcm9tU29jaWFsVXJsID0odXJsKT0+e1xuICAgICAgICBcbiAgICAgICAgaWYoIHVybC5tYXRjaCgvaHR0cDpcXC9cXC8vKSB8fCB1cmwubWF0Y2goL2h0dHBzOlxcL1xcLy8pICkgdXJsID0gdXJsLnJlcGxhY2UoJ2h0dHBzOi8vJywgJycpICYmIHVybC5yZXBsYWNlKCdodHRwOi8vJywgJycpXG4gICAgICAgIGlmKCB1cmwubWF0Y2goL3d3d1xcLi8pKSB1cmwgPSB1cmwucmVwbGFjZSgnd3d3LicsICcnKVxuICAgICAgICBpZiggdXJsLm1hdGNoKC93d3dcXC4vKSkgdXJsID0gdXJsLnJlcGxhY2UoJ3d3dy4nLCAnJylcbiAgICAgICAgaWYoIHVybC5tYXRjaCgvXFwuY29tLykpIHVybCA9IHVybC5yZXBsYWNlKCcuY29tJywgJycpXG4gICAgICAgIGlmKCB1cmwubWF0Y2goL1xcLml0LykpIHVybCA9IHVybC5yZXBsYWNlKCcuaXQnLCAnJylcbiAgICAgICAgaWYoIHVybC5tYXRjaCgvXFwub3JnLykpIHVybCA9IHVybC5yZXBsYWNlKCcub3JnJywgJycpXG4gICAgICAgIGlmKCB1cmwubWF0Y2goL1xcLm5ldC8pKSB1cmwgPSB1cmwucmVwbGFjZSgnLm5ldCcsICcnKVxuICAgIFxuICAgICAgICBsZXQgdXNlciA9IHVybC5yZXBsYWNlKC9cXC8kLywgJycpLnNwbGl0KCcvJykucG9wKCkudHJpbSgpXG4gICAgICAgIHJldHVybiB1c2VyICE9PSAnJyA/IHVzZXIgOiB1cmwgO1xuICAgIH1cblxufV1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZGFzaGJvYXJkL3N0YXRpYy9qcy9jb250cm9sbGVycy9vbmJvYXJkaW5nLmNvbnRyb2xsZXIuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUdBO0FBQ0E7QUFEQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 308:
/* no static exports found */
/* all exports used */
/*!*********************************************************************!*\
  !*** ./dashboard/static/js/controllers/searchmembers.controller.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _lodash = __webpack_require__(/*! lodash */ 9);\n\nexports.default = ['$scope', '$http', '$sce', function ($scope, $http, $sce) {\n    $scope.search_filter = '';\n    $scope.results = [];\n    $scope.last_members = [];\n\n    $scope.get_last_members = function (search_string) {\n        if (search_string != 0) {\n            $scope.preset_search = true;\n            $scope.search_filter = search_string;\n            $scope.search();\n        }\n        $http({\n            'method': 'GET',\n            'url': '/api/v1.1/search/last_members/'\n        }).then($scope.handleSearchLastMembersResponse, $scope.handleSearchError);\n    };\n\n    $scope.search = function (searchString) {\n\n        $scope.search_filter = searchString || $scope.search_filter;\n\n        if ($scope.search_filter.length < 3) {\n            $scope.results = $scope.last_members;\n            $scope.is_last_members_label = true;\n            return;\n        }\n        $http({\n            'method': 'GET',\n            'url': '/api/v1.1/search/members/' + $scope.search_filter + '/'\n        }).then($scope.handleSearchResponse, $scope.handleSearchError);\n    };\n\n    $scope.searchDebounced = (0, _lodash.debounce)($scope.search, 500);\n\n    $scope.highlight = function (text, search) {\n        if (!search) {\n            return $sce.trustAsHtml(text);\n        }\n        return $sce.trustAsHtml(text.replace(new RegExp(search, 'gi'), '<span class=\"text-red bold\">$&</span>'));\n    };\n\n    $scope.handleSearchLastMembersResponse = function (result) {\n        $scope.last_members = result['data']['result'];\n        $scope.is_last_members_label = !$scope.preset_search;\n        if (!$scope.preset_search) $scope.results = $scope.last_members;\n        $scope.resizeCircleImages();\n    };\n\n    $scope.handleSearchResponse = function (result) {\n        $scope.is_last_members_label = false;\n        $scope.results = result['data']['result'];\n        $scope.resizeCircleImages();\n    };\n\n    $scope.handleSearchError = function () {\n        $scope.is_last_members_label = false;\n        $scope.results = [];\n    };\n}]; /**\n     * Created by alexcomu on 04/05/17.\n     *///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2Rhc2hib2FyZC9zdGF0aWMvanMvY29udHJvbGxlcnMvc2VhcmNobWVtYmVycy5jb250cm9sbGVyLmpzPzNhOTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcmVhdGVkIGJ5IGFsZXhjb211IG9uIDA0LzA1LzE3LlxuICovXG5cbmltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSAnbG9kYXNoJ1xuXG5leHBvcnQgZGVmYXVsdCBbJyRzY29wZScsJyRodHRwJywnJHNjZScsIGZ1bmN0aW9uICgkc2NvcGUsICRodHRwLCAkc2NlKSB7XG4gICAgJHNjb3BlLnNlYXJjaF9maWx0ZXIgPSAnJztcbiAgICAkc2NvcGUucmVzdWx0cyA9IFtdO1xuICAgICRzY29wZS5sYXN0X21lbWJlcnMgPSBbXTtcblxuICAgICRzY29wZS5nZXRfbGFzdF9tZW1iZXJzID0gZnVuY3Rpb24oc2VhcmNoX3N0cmluZyl7XG4gICAgICAgIGlmKHNlYXJjaF9zdHJpbmchPTApe1xuICAgICAgICAgICAgJHNjb3BlLnByZXNldF9zZWFyY2ggPSB0cnVlO1xuICAgICAgICAgICAgJHNjb3BlLnNlYXJjaF9maWx0ZXIgPSBzZWFyY2hfc3RyaW5nO1xuICAgICAgICAgICAgJHNjb3BlLnNlYXJjaCgpO1xuICAgICAgICB9XG4gICAgICAgICRodHRwKHtcbiAgICAgICAgICAgICdtZXRob2QnOiAnR0VUJyxcbiAgICAgICAgICAgICd1cmwnOiAnL2FwaS92MS4xL3NlYXJjaC9sYXN0X21lbWJlcnMvJ1xuICAgICAgICB9KS50aGVuKCRzY29wZS5oYW5kbGVTZWFyY2hMYXN0TWVtYmVyc1Jlc3BvbnNlLCAkc2NvcGUuaGFuZGxlU2VhcmNoRXJyb3IpO1xuICAgIH07XG4gICAgXG4gICAgJHNjb3BlLnNlYXJjaCA9IChzZWFyY2hTdHJpbmcpID0+IHtcbiAgICAgICAgXG4gICAgICAgICRzY29wZS5zZWFyY2hfZmlsdGVyID0gc2VhcmNoU3RyaW5nIHx8ICRzY29wZS5zZWFyY2hfZmlsdGVyO1xuICAgICAgICBcbiAgICAgICAgaWYoJHNjb3BlLnNlYXJjaF9maWx0ZXIubGVuZ3RoIDwgMyl7XG4gICAgICAgICAgICAkc2NvcGUucmVzdWx0cyA9ICRzY29wZS5sYXN0X21lbWJlcnM7XG4gICAgICAgICAgICAkc2NvcGUuaXNfbGFzdF9tZW1iZXJzX2xhYmVsID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAkaHR0cCh7XG4gICAgICAgICAgICAnbWV0aG9kJzogJ0dFVCcsXG4gICAgICAgICAgICAndXJsJzogJy9hcGkvdjEuMS9zZWFyY2gvbWVtYmVycy8nKyRzY29wZS5zZWFyY2hfZmlsdGVyKycvJ1xuICAgICAgICB9KS50aGVuKCRzY29wZS5oYW5kbGVTZWFyY2hSZXNwb25zZSwgJHNjb3BlLmhhbmRsZVNlYXJjaEVycm9yKVxuICAgIH07XG4gICAgXG4gICAgJHNjb3BlLnNlYXJjaERlYm91bmNlZCA9IGRlYm91bmNlKCRzY29wZS5zZWFyY2ggLCA1MDApXG5cbiAgICAkc2NvcGUuaGlnaGxpZ2h0ID0gZnVuY3Rpb24odGV4dCwgc2VhcmNoKSB7XG4gICAgICAgIGlmICghc2VhcmNoKSB7cmV0dXJuICRzY2UudHJ1c3RBc0h0bWwodGV4dCk7fVxuICAgICAgICByZXR1cm4gJHNjZS50cnVzdEFzSHRtbCh0ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cChzZWFyY2gsICdnaScpLCAnPHNwYW4gY2xhc3M9XCJ0ZXh0LXJlZCBib2xkXCI+JCY8L3NwYW4+JykpO1xuICAgIH07XG5cbiAgICAkc2NvcGUuaGFuZGxlU2VhcmNoTGFzdE1lbWJlcnNSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgJHNjb3BlLmxhc3RfbWVtYmVycyA9IHJlc3VsdFsnZGF0YSddWydyZXN1bHQnXTtcbiAgICAgICAgJHNjb3BlLmlzX2xhc3RfbWVtYmVyc19sYWJlbCA9ICEkc2NvcGUucHJlc2V0X3NlYXJjaDtcbiAgICAgICAgaWYoISRzY29wZS5wcmVzZXRfc2VhcmNoKSAgJHNjb3BlLnJlc3VsdHMgPSAkc2NvcGUubGFzdF9tZW1iZXJzO1xuICAgICAgICAkc2NvcGUucmVzaXplQ2lyY2xlSW1hZ2VzKClcblxuICAgIH07XG5cbiAgICAkc2NvcGUuaGFuZGxlU2VhcmNoUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICRzY29wZS5pc19sYXN0X21lbWJlcnNfbGFiZWwgPSBmYWxzZTtcbiAgICAgICAgJHNjb3BlLnJlc3VsdHMgPSByZXN1bHRbJ2RhdGEnXVsncmVzdWx0J11cbiAgICAgICAgJHNjb3BlLnJlc2l6ZUNpcmNsZUltYWdlcygpXG4gICAgfTtcblxuICAgICRzY29wZS5oYW5kbGVTZWFyY2hFcnJvciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICRzY29wZS5pc19sYXN0X21lbWJlcnNfbGFiZWwgPSBmYWxzZTtcbiAgICAgICAgJHNjb3BlLnJlc3VsdHMgPSBbXVxuICAgIH07XG4gICAgXG4gICAgXG4gICAgXG59XVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBkYXNoYm9hcmQvc3RhdGljL2pzL2NvbnRyb2xsZXJzL3NlYXJjaG1lbWJlcnMuY29udHJvbGxlci5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7O0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 309:
/* no static exports found */
/* all exports used */
/*!**************************************************************!*\
  !*** ./dashboard/static/js/controllers/themes.controller.js ***!
  \**************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n/**\n * Created by andreafspeziale on 24/05/17.\n */\nexports.default = ['$scope', '$uibModal', '$http', '$aside', function ($scope, $uibModal, $http, $aside) {\n\n    $scope.FeedModel = {\n        theme: null,\n        filter: 'yesterday',\n        current_cursor: null,\n        next_cursor: -1,\n        progress: false,\n        top: $(window).scrollTop(),\n        data: [],\n\n        next: function next() {\n            var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.theme;\n            var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.filter;\n            var cursor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.next_cursor;\n\n            if (this.progress === true || this.next_cursor == 0 || this.current_cursor == this.next_cursor) return;\n\n            this.progress = true;\n            this.current_cursor = this.next_cursor;\n            this.get_news(theme, filter, cursor);\n            return this;\n        },\n\n        reset: function reset() {\n            var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.theme;\n            var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.filter;\n            var cursor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n            this.data = [];\n            this.current_cursor = null;\n            this.next_cursor = -1;\n            this.next(theme, filter, cursor);\n            return this;\n        },\n\n        get_news: function get_news() {\n            var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.theme;\n\n            var _this = this;\n\n            var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.filter;\n            var cursor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.next_cursor;\n\n            console.log('get news');\n            this.progress = true;\n            $http.get('/api/v1.2/news/' + theme + '/' + filter + '/' + cursor + '/').then(function (response) {\n                console.log('get news response');\n                _this.data = _this.data.concat(response.data.result.news);\n                _this.next_cursor = parseInt(response.data.result.next_cursor);\n                _this.progress = false;\n            }, function (err) {\n                console.log('ERROR:', err);_this.progress = false;\n            });\n            return this;\n        },\n        get_audiences: function get_audiences(theme) {\n            $http.get('/api/v1.2/audiences/' + theme).then(function (response) {\n                $scope.influencers = response.data.result.audiences;\n            }, function (err) {\n                // ToDo show API errors with a common error message using toastr?\n            });\n        }\n    };\n\n    var unbind_topic_id = $scope.$watch('topic_id', function (newValue, oldValue) {\n        console.log('default topic');\n        // if(newValue === oldValue) return\n        $scope.FeedModel.theme = newValue;\n        $scope.FeedModel.get_news(newValue, $scope.filter, $scope.cursor).get_audiences(newValue);\n        unbind_topic_id();\n    });\n\n    // Set filter for time\n    $scope.setFilter = function (filter) {\n        console.log('Set filter');\n        if ($scope.FeedModel.progress == false) {\n            console.log('SET filter inside');\n            $scope.FeedModel.filter = filter;\n            $scope.FeedModel.reset($scope.theme);\n        }\n    };\n\n    // open aside with influencers\n    $scope.openAside = function () {\n        $scope.aside = $aside({\n            scope: $scope,\n            title: \"Title\",\n            templateUrl: false,\n            backdrop: 'static',\n            template: __webpack_require__(/*! ../../../templates/aside/influencers.html */ 615),\n            show: false\n        });\n        $scope.aside.$promise.then(function () {\n            $scope.aside.show();\n            $('body').addClass('no-scroll');\n        });\n    };\n    $scope.closeAside = function () {\n        $scope.aside.hide();\n        $('body').removeClass('no-scroll');\n    };\n}];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2Rhc2hib2FyZC9zdGF0aWMvanMvY29udHJvbGxlcnMvdGhlbWVzLmNvbnRyb2xsZXIuanM/MGE3MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZWQgYnkgYW5kcmVhZnNwZXppYWxlIG9uIDI0LzA1LzE3LlxuICovXG5leHBvcnQgZGVmYXVsdCBbICckc2NvcGUnLCckdWliTW9kYWwnLCckaHR0cCcsJyRhc2lkZScsIGZ1bmN0aW9uICgkc2NvcGUsJHVpYk1vZGFsLCRodHRwLCRhc2lkZSkge1xuICAgIFxuICAgICRzY29wZS5GZWVkTW9kZWwgPSB7XG4gICAgICAgIHRoZW1lIDogbnVsbCxcbiAgICAgICAgZmlsdGVyIDogJ3llc3RlcmRheScgLFxuICAgICAgICBjdXJyZW50X2N1cnNvciA6IG51bGwsXG4gICAgICAgIG5leHRfY3Vyc29yIDogLTEsXG4gICAgICAgIHByb2dyZXNzIDogZmFsc2UsXG4gICAgICAgIHRvcDogICQod2luZG93KS5zY3JvbGxUb3AoKSxcbiAgICAgICAgZGF0YSA6IFtdLFxuICAgICAgICBcbiAgICAgICAgbmV4dCA6IGZ1bmN0aW9uKCB0aGVtZSA9IHRoaXMudGhlbWUgLCBmaWx0ZXIgPSB0aGlzLmZpbHRlciAsIGN1cnNvciA9IHRoaXMubmV4dF9jdXJzb3Ipe1xuICAgICAgICAgICAgaWYoXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9PT0gdHJ1ZVxuICAgICAgICAgICAgICAgIHx8IHRoaXMubmV4dF9jdXJzb3IgPT0gMFxuICAgICAgICAgICAgICAgIHx8IHRoaXMuY3VycmVudF9jdXJzb3IgPT0gdGhpcy5uZXh0X2N1cnNvclxuICAgICAgICAgICAgKSByZXR1cm5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfY3Vyc29yID0gdGhpcy5uZXh0X2N1cnNvclxuICAgICAgICAgICAgdGhpcy5nZXRfbmV3cyggdGhlbWUsIGZpbHRlciwgY3Vyc29yIClcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgcmVzZXQgOiBmdW5jdGlvbih0aGVtZT10aGlzLnRoZW1lLCBmaWx0ZXI9dGhpcy5maWx0ZXIsIGN1cnNvcj0tMSl7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBbXVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50X2N1cnNvciA9IG51bGxcbiAgICAgICAgICAgIHRoaXMubmV4dF9jdXJzb3IgPSAtMVxuICAgICAgICAgICAgdGhpcy5uZXh0KHRoZW1lLCBmaWx0ZXIsIGN1cnNvcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBnZXRfbmV3cyA6IGZ1bmN0aW9uKHRoZW1lPXRoaXMudGhlbWUgLCBmaWx0ZXI9dGhpcy5maWx0ZXIgLCBjdXJzb3IgPSB0aGlzLm5leHRfY3Vyc29yKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnZXQgbmV3cycpO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAkaHR0cC5nZXQoJy9hcGkvdjEuMi9uZXdzLycgKyB0aGVtZSArICcvJyArIGZpbHRlciArICcvJyArIGN1cnNvciArICcvJylcbiAgICAgICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZ2V0IG5ld3MgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5jb25jYXQocmVzcG9uc2UuZGF0YS5yZXN1bHQubmV3cylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dF9jdXJzb3IgPSBwYXJzZUludChyZXNwb25zZS5kYXRhLnJlc3VsdC5uZXh0X2N1cnNvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgKGVycik9PnsgY29uc29sZS5sb2coJ0VSUk9SOicsIGVycik7IHRoaXMucHJvZ3Jlc3MgPSBmYWxzZTsgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0sXG4gICAgICAgIGdldF9hdWRpZW5jZXMgOiBmdW5jdGlvbiAodGhlbWUpIHtcbiAgICAgICAgICAgICRodHRwLmdldCgnL2FwaS92MS4yL2F1ZGllbmNlcy8nICsgdGhlbWUpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5pbmZsdWVuY2VycyA9IHJlc3BvbnNlLmRhdGEucmVzdWx0LmF1ZGllbmNlcztcbiAgICAgICAgICAgICAgICB9LGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVG9EbyBzaG93IEFQSSBlcnJvcnMgd2l0aCBhIGNvbW1vbiBlcnJvciBtZXNzYWdlIHVzaW5nIHRvYXN0cj9cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGxldCB1bmJpbmRfdG9waWNfaWQgPSAkc2NvcGUuJHdhdGNoKCd0b3BpY19pZCcsIGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2RlZmF1bHQgdG9waWMnKTtcbiAgICAgICAgLy8gaWYobmV3VmFsdWUgPT09IG9sZFZhbHVlKSByZXR1cm5cbiAgICAgICAgJHNjb3BlLkZlZWRNb2RlbC50aGVtZSA9IG5ld1ZhbHVlXG4gICAgICAgICRzY29wZS5GZWVkTW9kZWxcbiAgICAgICAgICAgIC5nZXRfbmV3cyhuZXdWYWx1ZSwgJHNjb3BlLmZpbHRlciwgJHNjb3BlLmN1cnNvcilcbiAgICAgICAgICAgIC5nZXRfYXVkaWVuY2VzKG5ld1ZhbHVlKVxuICAgICAgICB1bmJpbmRfdG9waWNfaWQoKVxuICAgIH0pXG4gICAgXG4gICAgLy8gU2V0IGZpbHRlciBmb3IgdGltZVxuICAgICRzY29wZS5zZXRGaWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTZXQgZmlsdGVyJyk7XG4gICAgICAgIGlmKCRzY29wZS5GZWVkTW9kZWwucHJvZ3Jlc3M9PWZhbHNlKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTRVQgZmlsdGVyIGluc2lkZScpO1xuICAgICAgICAgICAgJHNjb3BlLkZlZWRNb2RlbC5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgICAgICAkc2NvcGUuRmVlZE1vZGVsLnJlc2V0KCRzY29wZS50aGVtZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG9wZW4gYXNpZGUgd2l0aCBpbmZsdWVuY2Vyc1xuICAgICRzY29wZS5vcGVuQXNpZGUgPSAoKSA9PiB7XG4gICAgICAgICRzY29wZS5hc2lkZSA9ICRhc2lkZSh7XG4gICAgICAgICAgICBzY29wZTokc2NvcGUsXG4gICAgICAgICAgICB0aXRsZTogXCJUaXRsZVwiLFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IGZhbHNlLFxuICAgICAgICAgICAgYmFja2Ryb3A6ICdzdGF0aWMnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoXCIuLi8uLi8uLi90ZW1wbGF0ZXMvYXNpZGUvaW5mbHVlbmNlcnMuaHRtbFwiKSxcbiAgICAgICAgICAgIHNob3c6ZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgICRzY29wZS5hc2lkZS4kcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLmFzaWRlLnNob3coKTtcbiAgICAgICAgICAgICQoJ2JvZHknKS5hZGRDbGFzcygnbm8tc2Nyb2xsJyk7XG4gICAgICAgIH0pXG4gICAgfVxuICAgICRzY29wZS5jbG9zZUFzaWRlID0gKCkgPT57XG4gICAgICAgICRzY29wZS5hc2lkZS5oaWRlKClcbiAgICAgICAgJCgnYm9keScpLnJlbW92ZUNsYXNzKCduby1zY3JvbGwnKTtcbiAgICAgICAgXG4gICAgfVxuICAgIFxufV1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZGFzaGJvYXJkL3N0YXRpYy9qcy9jb250cm9sbGVycy90aGVtZXMuY29udHJvbGxlci5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckRBO0FBQ0E7QUF1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 310:
/* no static exports found */
/* all exports used */
/*!*****************************************************************!*\
  !*** ./dashboard/static/js/directives/UserStories.directive.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _lodash = __webpack_require__(/*! lodash */ 9);\n\nvar _ = _interopRequireWildcard(_lodash);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar template = '\\n    <div class=\"row\">\\n        <div class=\"col-md-12\">\\n            <h2><strong class=\"text-red\">Stories</strong> <small>from <a href=\"http://openmaker.eu/\" target=\"_blank\">openmaker.eu</a></small></h2>\\n        </div>\\n        \\n        <div class=\"col-md-3\" ng-repeat=\"story in stories | limitTo:3\">\\n            <div class=\"card margin-bottom-20\" ng-if=\"story\">\\n                <a href=\"{$ story.link $}\" target=\"_blank\">\\n                    <div class=\"card-image\" style=\"border-bottom:solid 1px rgba(160, 160, 160, 0.2);\">\\n                        <img ng-if=\"story.image\" style=\"min-width:100%;\" ng-src=\"{$ story.image $}\" class=\"img-responsive\" alt=\"Story image\">\\n                    </div>\\n                    <div class=\"card-content text-center\">\\n                        <!--<h5>{{ feed.title|truncatechars:40 }}</h5>-->\\n                        <h5 ng-bind-html=\"story.title.rendered\" ></h5>\\n                    </div>\\n                    <div class=\"card-action\">\\n                        <p ng-bind-html=\"story.excerpt.rendered\"></p>\\n                    </div>\\n                </a>\\n            </div>\\n        </div>\\n        <div class=\"col-xs-12 col-sm-6 col-md-4 col-lg-3\">\\n                            <a href=\"http://openmaker.eu/\" target=\"_blank\">\\n                                <div class=\"card margin-bottom-20\" style=\"min-height: 326px;\">\\n                                    <h3 class=\"text-red\" style=\"position: absolute;\\n                                top: 50%;\\n                                left: 50%;\\n                                margin-right: -50%;\\n                                transform: translate(-50%, -50%)\">Discover <small class=\"text-black\">more</small><br><i class=\"fa fa-hand-o-right\" aria-hidden=\"true\"></i></h3>\\n                                </div>\\n                            </a>\\n                        </div>\\n    </div>\\n';\n\nexports.default = [function () {\n\n    return {\n        template: template,\n        scope: [],\n        controller: ['$scope', '$http', function ($scope, $http) {\n\n            $scope.stories = [];\n\n            var openmaker_country = ['it', 'es', 'sk', 'uk', 'eu'];\n            var openmaker_suffix = 'openmaker.eu';\n            var api_suffix = 'wp-json/wp/v2';\n\n            var url = 'http://' + openmaker_suffix + '/' + api_suffix + '/posts?_embed=true';\n            $http.get(url).then(function (res) {\n                $scope.stories = res.data.slice(0, 4).map(function (story) {\n                    console.log('image', story);\n                    story.image = _.get(story, \"['_embedded']['wp:featuredmedia'][0].source_url\") || '/static/images/openmaker-logo.svg';\n                    return story;\n                });\n            }, function (err) {\n                return console.log('Error : ', err);\n            });\n\n            // _.each(openmaker_country, country =>{\n            //     let url = `http://${country}.${openmaker_suffix}/${api_suffix}/posts?_embed=true`\n            //     $http.get(url).then(\n            //         res => {\n            //             res.data[0].image =\n            //                 _.get(res, \"data[0]['_embedded']['wp:featuredmedia'][0].source_url\") ||\n            //                 '/static/images/openmaker-logo.svg'\n            //             $scope.stories.push(res.data[0])\n            //         }\n            //         ,\n            //         err => console.log('Error : ', err)\n            //     )\n            // })\n        }]\n    };\n}];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2Rhc2hib2FyZC9zdGF0aWMvanMvZGlyZWN0aXZlcy9Vc2VyU3Rvcmllcy5kaXJlY3RpdmUuanM/MjJlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCdcblxubGV0IHRlbXBsYXRlID0gYFxuICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC0xMlwiPlxuICAgICAgICAgICAgPGgyPjxzdHJvbmcgY2xhc3M9XCJ0ZXh0LXJlZFwiPlN0b3JpZXM8L3N0cm9uZz4gPHNtYWxsPmZyb20gPGEgaHJlZj1cImh0dHA6Ly9vcGVubWFrZXIuZXUvXCIgdGFyZ2V0PVwiX2JsYW5rXCI+b3Blbm1ha2VyLmV1PC9hPjwvc21hbGw+PC9oMj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTNcIiBuZy1yZXBlYXQ9XCJzdG9yeSBpbiBzdG9yaWVzIHwgbGltaXRUbzozXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZCBtYXJnaW4tYm90dG9tLTIwXCIgbmctaWY9XCJzdG9yeVwiPlxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJ7JCBzdG9yeS5saW5rICR9XCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWltYWdlXCIgc3R5bGU9XCJib3JkZXItYm90dG9tOnNvbGlkIDFweCByZ2JhKDE2MCwgMTYwLCAxNjAsIDAuMik7XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aW1nIG5nLWlmPVwic3RvcnkuaW1hZ2VcIiBzdHlsZT1cIm1pbi13aWR0aDoxMDAlO1wiIG5nLXNyYz1cInskIHN0b3J5LmltYWdlICR9XCIgY2xhc3M9XCJpbWctcmVzcG9uc2l2ZVwiIGFsdD1cIlN0b3J5IGltYWdlXCI+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1jb250ZW50IHRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8IS0tPGg1Pnt7IGZlZWQudGl0bGV8dHJ1bmNhdGVjaGFyczo0MCB9fTwvaDU+LS0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aDUgbmctYmluZC1odG1sPVwic3RvcnkudGl0bGUucmVuZGVyZWRcIiA+PC9oNT5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWFjdGlvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHAgbmctYmluZC1odG1sPVwic3RvcnkuZXhjZXJwdC5yZW5kZXJlZFwiPjwvcD5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXhzLTEyIGNvbC1zbS02IGNvbC1tZC00IGNvbC1sZy0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cImh0dHA6Ly9vcGVubWFrZXIuZXUvXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkIG1hcmdpbi1ib3R0b20tMjBcIiBzdHlsZT1cIm1pbi1oZWlnaHQ6IDMyNnB4O1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGgzIGNsYXNzPVwidGV4dC1yZWRcIiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiA1MCU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDUwJTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiAtNTAlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKVwiPkRpc2NvdmVyIDxzbWFsbCBjbGFzcz1cInRleHQtYmxhY2tcIj5tb3JlPC9zbWFsbD48YnI+PGkgY2xhc3M9XCJmYSBmYS1oYW5kLW8tcmlnaHRcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+PC9oMz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5gXG5cbmV4cG9ydCBkZWZhdWx0IFtmdW5jdGlvbigpe1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIHRlbXBsYXRlOnRlbXBsYXRlLFxuICAgICAgICBzY29wZTogW10sXG4gICAgICAgIGNvbnRyb2xsZXIgOiBbJyRzY29wZScsJyRodHRwJywgZnVuY3Rpb24oJHNjb3BlLCAkaHR0cCl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICRzY29wZS5zdG9yaWVzID0gW11cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IG9wZW5tYWtlcl9jb3VudHJ5ID0gWydpdCcsICdlcycsICdzaycsICd1aycsICdldSddXG4gICAgICAgICAgICBsZXQgb3Blbm1ha2VyX3N1ZmZpeCA9ICdvcGVubWFrZXIuZXUnXG4gICAgICAgICAgICBsZXQgYXBpX3N1ZmZpeCA9ICd3cC1qc29uL3dwL3YyJ1xuICAgIFxuICAgICAgICAgICAgbGV0IHVybCA9IGBodHRwOi8vJHtvcGVubWFrZXJfc3VmZml4fS8ke2FwaV9zdWZmaXh9L3Bvc3RzP19lbWJlZD10cnVlYFxuICAgICAgICAgICAgJGh0dHAuZ2V0KHVybCkudGhlbihcbiAgICAgICAgICAgICAgICByZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc3RvcmllcyA9IHJlcy5kYXRhLnNsaWNlKDAsNCkubWFwKHN0b3J5PT57XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnaW1hZ2UnLCBzdG9yeSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3J5LmltYWdlID0gXy5nZXQoc3RvcnksIFwiWydfZW1iZWRkZWQnXVsnd3A6ZmVhdHVyZWRtZWRpYSddWzBdLnNvdXJjZV91cmxcIikgfHwgJy9zdGF0aWMvaW1hZ2VzL29wZW5tYWtlci1sb2dvLnN2ZydcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yeVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgICAgZXJyID0+IGNvbnNvbGUubG9nKCdFcnJvciA6ICcsIGVycilcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gXy5lYWNoKG9wZW5tYWtlcl9jb3VudHJ5LCBjb3VudHJ5ID0+e1xuICAgICAgICAgICAgLy8gICAgIGxldCB1cmwgPSBgaHR0cDovLyR7Y291bnRyeX0uJHtvcGVubWFrZXJfc3VmZml4fS8ke2FwaV9zdWZmaXh9L3Bvc3RzP19lbWJlZD10cnVlYFxuICAgICAgICAgICAgLy8gICAgICRodHRwLmdldCh1cmwpLnRoZW4oXG4gICAgICAgICAgICAvLyAgICAgICAgIHJlcyA9PiB7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICByZXMuZGF0YVswXS5pbWFnZSA9XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgXy5nZXQocmVzLCBcImRhdGFbMF1bJ19lbWJlZGRlZCddWyd3cDpmZWF0dXJlZG1lZGlhJ11bMF0uc291cmNlX3VybFwiKSB8fFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICcvc3RhdGljL2ltYWdlcy9vcGVubWFrZXItbG9nby5zdmcnXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAkc2NvcGUuc3Rvcmllcy5wdXNoKHJlcy5kYXRhWzBdKVxuICAgICAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgICAgICAvLyAgICAgICAgICxcbiAgICAgICAgICAgIC8vICAgICAgICAgZXJyID0+IGNvbnNvbGUubG9nKCdFcnJvciA6ICcsIGVycilcbiAgICAgICAgICAgIC8vICAgICApXG4gICAgICAgICAgICAvLyB9KVxuICAgICAgICAgICAgXG4gICAgICAgIH1dXG4gICAgfVxuICBcbn1dXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZGFzaGJvYXJkL3N0YXRpYy9qcy9kaXJlY3RpdmVzL1VzZXJTdG9yaWVzLmRpcmVjdGl2ZS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQURBO0FBQ0E7OztBQUNBO0FBQ0E7QUFtQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQXRDQTtBQXlDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 324:
/* no static exports found */
/* all exports used */
/*!****************************************************************************************!*\
  !*** ./~/css-loader!./~/sass-loader/lib/loader.js!./dashboard/static/style/index.scss ***!
  \****************************************************************************************/
/***/ (function(module, exports) {

eval("throw new Error(\"Module build failed: Error: Missing binding /Users/massimo/IdeaProjects/dsp/node_modules/node-sass/vendor/darwin-x64-57/binding.node\\nNode Sass could not find a binding for your current environment: OS X 64-bit with Node.js 8.x\\n\\nFound bindings for the following environments:\\n  - OS X 64-bit with Node.js 7.x\\n\\nThis usually happens because your environment has changed since running `npm install`.\\nRun `npm rebuild node-sass --force` to build the binding for your current environment.\\n    at module.exports (/Users/massimo/IdeaProjects/dsp/node_modules/node-sass/lib/binding.js:15:13)\\n    at Object.<anonymous> (/Users/massimo/IdeaProjects/dsp/node_modules/node-sass/lib/index.js:14:35)\\n    at Module._compile (module.js:624:30)\\n    at Object.Module._extensions..js (module.js:635:10)\\n    at Module.load (module.js:545:32)\\n    at tryModuleLoad (module.js:508:12)\\n    at Function.Module._load (module.js:500:3)\\n    at Module.require (module.js:568:17)\\n    at require (internal/module.js:11:18)\\n    at Object.<anonymous> (/Users/massimo/IdeaProjects/dsp/node_modules/sass-loader/lib/loader.js:3:14)\\n    at Module._compile (module.js:624:30)\\n    at Object.Module._extensions..js (module.js:635:10)\\n    at Module.load (module.js:545:32)\\n    at tryModuleLoad (module.js:508:12)\\n    at Function.Module._load (module.js:500:3)\\n    at Module.require (module.js:568:17)\\n    at require (internal/module.js:11:18)\\n    at loadLoader (/Users/massimo/IdeaProjects/dsp/node_modules/loader-runner/lib/loadLoader.js:13:17)\\n    at iteratePitchingLoaders (/Users/massimo/IdeaProjects/dsp/node_modules/loader-runner/lib/LoaderRunner.js:169:2)\\n    at iteratePitchingLoaders (/Users/massimo/IdeaProjects/dsp/node_modules/loader-runner/lib/LoaderRunner.js:165:10)\\n    at /Users/massimo/IdeaProjects/dsp/node_modules/loader-runner/lib/LoaderRunner.js:173:18\\n    at loadLoader (/Users/massimo/IdeaProjects/dsp/node_modules/loader-runner/lib/loadLoader.js:36:3)\\n    at iteratePitchingLoaders (/Users/massimo/IdeaProjects/dsp/node_modules/loader-runner/lib/LoaderRunner.js:169:2)\\n    at runLoaders (/Users/massimo/IdeaProjects/dsp/node_modules/loader-runner/lib/LoaderRunner.js:362:2)\\n    at NormalModule.doBuild (/Users/massimo/IdeaProjects/dsp/node_modules/webpack/lib/NormalModule.js:179:3)\\n    at NormalModule.build (/Users/massimo/IdeaProjects/dsp/node_modules/webpack/lib/NormalModule.js:268:15)\\n    at Compilation.buildModule (/Users/massimo/IdeaProjects/dsp/node_modules/webpack/lib/Compilation.js:146:10)\\n    at factoryCallback (/Users/massimo/IdeaProjects/dsp/node_modules/webpack/lib/Compilation.js:329:11)\\n    at factory (/Users/massimo/IdeaProjects/dsp/node_modules/webpack/lib/NormalModuleFactory.js:253:5)\\n    at applyPluginsAsyncWaterfall (/Users/massimo/IdeaProjects/dsp/node_modules/webpack/lib/NormalModuleFactory.js:99:14)\");//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzI0LmpzIiwic291cmNlcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 615:
/* no static exports found */
/* all exports used */
/*!****************************************************!*\
  !*** ./dashboard/templates/aside/influencers.html ***!
  \****************************************************/
/***/ (function(module, exports) {

eval("module.exports = \"<div id=\\\"influencers_aside\\\"\\n     style=\\\"position: absolute\\\"\\n     class=\\\"aside left col-lg-2 col-md-4 col-sm-6 col-xs-12 padding-0\\\"\\n     tabindex=\\\"1\\\" role=\\\"dialog\\\"\\n>\\n    <div class=\\\"aside-dialog\\\">\\n        <div class=\\\"aside-content\\\" >\\n\\n            <div class=\\\"aside-header bg-red\\\">\\n                <h3><span>Influencers</span>\\n                    <span class=\\\"glyphicon glyphicon-remove pull-right\\\" style=\\\"color:#fff; cursor:pointer; font-size: 15px;\\\" ng-click=\\\"closeAside()\\\"></span>\\n                </h3>\\n            </div>\\n\\n            <div class=\\\"aside-body\\\" style=\\\"padding:20px;\\\">\\n                <div class=\\\"pull-left\\\" style=\\\"clear: both;\\\" ng-repeat=\\\"data in influencers\\\">\\n                    <a href=\\\"https://www.twitter.com/{$ data['username'] $}\\\" target=\\\"_blank\\\">\\n                        <h5 class=\\\"pull-left\\\" style=\\\"height: 2em;\\\">\\n                            <img class=\\\"img-circle\\\" ng-src=\\\"{$ data.profile_image_url $}\\\" alt=\\\"\\\" style=\\\"height:40px; width: 40px;\\\">&nbsp;&nbsp;&nbsp;&nbsp;</h5>\\n                        <h5 class=\\\"pull-left\\\" style=\\\"line-height: 2em;\\\">\\n                            <p style=\\\"line-height: 40px;\\\">{$ data.name $}</p>\\n                        </h5>\\n                    </a>\\n                </div>\\n            </div>\\n\\n        </div>\\n    </div>\\n</div>\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZGFzaGJvYXJkL3RlbXBsYXRlcy9hc2lkZS9pbmZsdWVuY2Vycy5odG1sPzAwMDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgaWQ9XFxcImluZmx1ZW5jZXJzX2FzaWRlXFxcIlxcbiAgICAgc3R5bGU9XFxcInBvc2l0aW9uOiBhYnNvbHV0ZVxcXCJcXG4gICAgIGNsYXNzPVxcXCJhc2lkZSBsZWZ0IGNvbC1sZy0yIGNvbC1tZC00IGNvbC1zbS02IGNvbC14cy0xMiBwYWRkaW5nLTBcXFwiXFxuICAgICB0YWJpbmRleD1cXFwiMVxcXCIgcm9sZT1cXFwiZGlhbG9nXFxcIlxcbj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYXNpZGUtZGlhbG9nXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImFzaWRlLWNvbnRlbnRcXFwiID5cXG5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJhc2lkZS1oZWFkZXIgYmctcmVkXFxcIj5cXG4gICAgICAgICAgICAgICAgPGgzPjxzcGFuPkluZmx1ZW5jZXJzPC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tcmVtb3ZlIHB1bGwtcmlnaHRcXFwiIHN0eWxlPVxcXCJjb2xvcjojZmZmOyBjdXJzb3I6cG9pbnRlcjsgZm9udC1zaXplOiAxNXB4O1xcXCIgbmctY2xpY2s9XFxcImNsb3NlQXNpZGUoKVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8L2gzPlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImFzaWRlLWJvZHlcXFwiIHN0eWxlPVxcXCJwYWRkaW5nOjIwcHg7XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicHVsbC1sZWZ0XFxcIiBzdHlsZT1cXFwiY2xlYXI6IGJvdGg7XFxcIiBuZy1yZXBlYXQ9XFxcImRhdGEgaW4gaW5mbHVlbmNlcnNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cudHdpdHRlci5jb20veyQgZGF0YVsndXNlcm5hbWUnXSAkfVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxoNSBjbGFzcz1cXFwicHVsbC1sZWZ0XFxcIiBzdHlsZT1cXFwiaGVpZ2h0OiAyZW07XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cXFwiaW1nLWNpcmNsZVxcXCIgbmctc3JjPVxcXCJ7JCBkYXRhLnByb2ZpbGVfaW1hZ2VfdXJsICR9XFxcIiBhbHQ9XFxcIlxcXCIgc3R5bGU9XFxcImhlaWdodDo0MHB4OyB3aWR0aDogNDBweDtcXFwiPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOzwvaDU+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGg1IGNsYXNzPVxcXCJwdWxsLWxlZnRcXFwiIHN0eWxlPVxcXCJsaW5lLWhlaWdodDogMmVtO1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIHN0eWxlPVxcXCJsaW5lLWhlaWdodDogNDBweDtcXFwiPnskIGRhdGEubmFtZSAkfTwvcD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2g1PlxcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rhc2hib2FyZC90ZW1wbGF0ZXMvYXNpZGUvaW5mbHVlbmNlcnMuaHRtbFxuLy8gbW9kdWxlIGlkID0gNjE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 620:
/* no static exports found */
/* all exports used */
/*!**********************************************************!*\
  !*** ./~/ng-infinite-scroll/build/ng-infinite-scroll.js ***!
  \**********************************************************/
/***/ (function(module, exports) {

eval("/* ng-infinite-scroll - v1.3.0 - 2016-06-30 */\nangular.module('infinite-scroll', []).value('THROTTLE_MILLISECONDS', null).directive('infiniteScroll', [\n  '$rootScope', '$window', '$interval', 'THROTTLE_MILLISECONDS', function($rootScope, $window, $interval, THROTTLE_MILLISECONDS) {\n    return {\n      scope: {\n        infiniteScroll: '&',\n        infiniteScrollContainer: '=',\n        infiniteScrollDistance: '=',\n        infiniteScrollDisabled: '=',\n        infiniteScrollUseDocumentBottom: '=',\n        infiniteScrollListenForEvent: '@'\n      },\n      link: function(scope, elem, attrs) {\n        var changeContainer, checkInterval, checkWhenEnabled, container, handleInfiniteScrollContainer, handleInfiniteScrollDisabled, handleInfiniteScrollDistance, handleInfiniteScrollUseDocumentBottom, handler, height, immediateCheck, offsetTop, pageYOffset, scrollDistance, scrollEnabled, throttle, unregisterEventListener, useDocumentBottom, windowElement;\n        windowElement = angular.element($window);\n        scrollDistance = null;\n        scrollEnabled = null;\n        checkWhenEnabled = null;\n        container = null;\n        immediateCheck = true;\n        useDocumentBottom = false;\n        unregisterEventListener = null;\n        checkInterval = false;\n        height = function(elem) {\n          elem = elem[0] || elem;\n          if (isNaN(elem.offsetHeight)) {\n            return elem.document.documentElement.clientHeight;\n          } else {\n            return elem.offsetHeight;\n          }\n        };\n        offsetTop = function(elem) {\n          if (!elem[0].getBoundingClientRect || elem.css('none')) {\n            return;\n          }\n          return elem[0].getBoundingClientRect().top + pageYOffset(elem);\n        };\n        pageYOffset = function(elem) {\n          elem = elem[0] || elem;\n          if (isNaN(window.pageYOffset)) {\n            return elem.document.documentElement.scrollTop;\n          } else {\n            return elem.ownerDocument.defaultView.pageYOffset;\n          }\n        };\n        handler = function() {\n          var containerBottom, containerTopOffset, elementBottom, remaining, shouldScroll;\n          if (container === windowElement) {\n            containerBottom = height(container) + pageYOffset(container[0].document.documentElement);\n            elementBottom = offsetTop(elem) + height(elem);\n          } else {\n            containerBottom = height(container);\n            containerTopOffset = 0;\n            if (offsetTop(container) !== void 0) {\n              containerTopOffset = offsetTop(container);\n            }\n            elementBottom = offsetTop(elem) - containerTopOffset + height(elem);\n          }\n          if (useDocumentBottom) {\n            elementBottom = height((elem[0].ownerDocument || elem[0].document).documentElement);\n          }\n          remaining = elementBottom - containerBottom;\n          shouldScroll = remaining <= height(container) * scrollDistance + 1;\n          if (shouldScroll) {\n            checkWhenEnabled = true;\n            if (scrollEnabled) {\n              if (scope.$$phase || $rootScope.$$phase) {\n                return scope.infiniteScroll();\n              } else {\n                return scope.$apply(scope.infiniteScroll);\n              }\n            }\n          } else {\n            if (checkInterval) {\n              $interval.cancel(checkInterval);\n            }\n            return checkWhenEnabled = false;\n          }\n        };\n        throttle = function(func, wait) {\n          var later, previous, timeout;\n          timeout = null;\n          previous = 0;\n          later = function() {\n            previous = new Date().getTime();\n            $interval.cancel(timeout);\n            timeout = null;\n            return func.call();\n          };\n          return function() {\n            var now, remaining;\n            now = new Date().getTime();\n            remaining = wait - (now - previous);\n            if (remaining <= 0) {\n              $interval.cancel(timeout);\n              timeout = null;\n              previous = now;\n              return func.call();\n            } else {\n              if (!timeout) {\n                return timeout = $interval(later, remaining, 1);\n              }\n            }\n          };\n        };\n        if (THROTTLE_MILLISECONDS != null) {\n          handler = throttle(handler, THROTTLE_MILLISECONDS);\n        }\n        scope.$on('$destroy', function() {\n          container.unbind('scroll', handler);\n          if (unregisterEventListener != null) {\n            unregisterEventListener();\n            unregisterEventListener = null;\n          }\n          if (checkInterval) {\n            return $interval.cancel(checkInterval);\n          }\n        });\n        handleInfiniteScrollDistance = function(v) {\n          return scrollDistance = parseFloat(v) || 0;\n        };\n        scope.$watch('infiniteScrollDistance', handleInfiniteScrollDistance);\n        handleInfiniteScrollDistance(scope.infiniteScrollDistance);\n        handleInfiniteScrollDisabled = function(v) {\n          scrollEnabled = !v;\n          if (scrollEnabled && checkWhenEnabled) {\n            checkWhenEnabled = false;\n            return handler();\n          }\n        };\n        scope.$watch('infiniteScrollDisabled', handleInfiniteScrollDisabled);\n        handleInfiniteScrollDisabled(scope.infiniteScrollDisabled);\n        handleInfiniteScrollUseDocumentBottom = function(v) {\n          return useDocumentBottom = v;\n        };\n        scope.$watch('infiniteScrollUseDocumentBottom', handleInfiniteScrollUseDocumentBottom);\n        handleInfiniteScrollUseDocumentBottom(scope.infiniteScrollUseDocumentBottom);\n        changeContainer = function(newContainer) {\n          if (container != null) {\n            container.unbind('scroll', handler);\n          }\n          container = newContainer;\n          if (newContainer != null) {\n            return container.bind('scroll', handler);\n          }\n        };\n        changeContainer(windowElement);\n        if (scope.infiniteScrollListenForEvent) {\n          unregisterEventListener = $rootScope.$on(scope.infiniteScrollListenForEvent, handler);\n        }\n        handleInfiniteScrollContainer = function(newContainer) {\n          if ((newContainer == null) || newContainer.length === 0) {\n            return;\n          }\n          if (newContainer.nodeType && newContainer.nodeType === 1) {\n            newContainer = angular.element(newContainer);\n          } else if (typeof newContainer.append === 'function') {\n            newContainer = angular.element(newContainer[newContainer.length - 1]);\n          } else if (typeof newContainer === 'string') {\n            newContainer = angular.element(document.querySelector(newContainer));\n          }\n          if (newContainer != null) {\n            return changeContainer(newContainer);\n          } else {\n            throw new Error(\"invalid infinite-scroll-container attribute.\");\n          }\n        };\n        scope.$watch('infiniteScrollContainer', handleInfiniteScrollContainer);\n        handleInfiniteScrollContainer(scope.infiniteScrollContainer || []);\n        if (attrs.infiniteScrollParent != null) {\n          changeContainer(angular.element(elem.parent()));\n        }\n        if (attrs.infiniteScrollImmediateCheck != null) {\n          immediateCheck = scope.$eval(attrs.infiniteScrollImmediateCheck);\n        }\n        return checkInterval = $interval((function() {\n          if (immediateCheck) {\n            handler();\n          }\n          return $interval.cancel(checkInterval);\n        }));\n      }\n    };\n  }\n]);\n\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports) {\n  module.exports = 'infinite-scroll';\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9uZy1pbmZpbml0ZS1zY3JvbGwvYnVpbGQvbmctaW5maW5pdGUtc2Nyb2xsLmpzPzY0MTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyogbmctaW5maW5pdGUtc2Nyb2xsIC0gdjEuMy4wIC0gMjAxNi0wNi0zMCAqL1xuYW5ndWxhci5tb2R1bGUoJ2luZmluaXRlLXNjcm9sbCcsIFtdKS52YWx1ZSgnVEhST1RUTEVfTUlMTElTRUNPTkRTJywgbnVsbCkuZGlyZWN0aXZlKCdpbmZpbml0ZVNjcm9sbCcsIFtcbiAgJyRyb290U2NvcGUnLCAnJHdpbmRvdycsICckaW50ZXJ2YWwnLCAnVEhST1RUTEVfTUlMTElTRUNPTkRTJywgZnVuY3Rpb24oJHJvb3RTY29wZSwgJHdpbmRvdywgJGludGVydmFsLCBUSFJPVFRMRV9NSUxMSVNFQ09ORFMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2NvcGU6IHtcbiAgICAgICAgaW5maW5pdGVTY3JvbGw6ICcmJyxcbiAgICAgICAgaW5maW5pdGVTY3JvbGxDb250YWluZXI6ICc9JyxcbiAgICAgICAgaW5maW5pdGVTY3JvbGxEaXN0YW5jZTogJz0nLFxuICAgICAgICBpbmZpbml0ZVNjcm9sbERpc2FibGVkOiAnPScsXG4gICAgICAgIGluZmluaXRlU2Nyb2xsVXNlRG9jdW1lbnRCb3R0b206ICc9JyxcbiAgICAgICAgaW5maW5pdGVTY3JvbGxMaXN0ZW5Gb3JFdmVudDogJ0AnXG4gICAgICB9LFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW0sIGF0dHJzKSB7XG4gICAgICAgIHZhciBjaGFuZ2VDb250YWluZXIsIGNoZWNrSW50ZXJ2YWwsIGNoZWNrV2hlbkVuYWJsZWQsIGNvbnRhaW5lciwgaGFuZGxlSW5maW5pdGVTY3JvbGxDb250YWluZXIsIGhhbmRsZUluZmluaXRlU2Nyb2xsRGlzYWJsZWQsIGhhbmRsZUluZmluaXRlU2Nyb2xsRGlzdGFuY2UsIGhhbmRsZUluZmluaXRlU2Nyb2xsVXNlRG9jdW1lbnRCb3R0b20sIGhhbmRsZXIsIGhlaWdodCwgaW1tZWRpYXRlQ2hlY2ssIG9mZnNldFRvcCwgcGFnZVlPZmZzZXQsIHNjcm9sbERpc3RhbmNlLCBzY3JvbGxFbmFibGVkLCB0aHJvdHRsZSwgdW5yZWdpc3RlckV2ZW50TGlzdGVuZXIsIHVzZURvY3VtZW50Qm90dG9tLCB3aW5kb3dFbGVtZW50O1xuICAgICAgICB3aW5kb3dFbGVtZW50ID0gYW5ndWxhci5lbGVtZW50KCR3aW5kb3cpO1xuICAgICAgICBzY3JvbGxEaXN0YW5jZSA9IG51bGw7XG4gICAgICAgIHNjcm9sbEVuYWJsZWQgPSBudWxsO1xuICAgICAgICBjaGVja1doZW5FbmFibGVkID0gbnVsbDtcbiAgICAgICAgY29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgaW1tZWRpYXRlQ2hlY2sgPSB0cnVlO1xuICAgICAgICB1c2VEb2N1bWVudEJvdHRvbSA9IGZhbHNlO1xuICAgICAgICB1bnJlZ2lzdGVyRXZlbnRMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIGNoZWNrSW50ZXJ2YWwgPSBmYWxzZTtcbiAgICAgICAgaGVpZ2h0ID0gZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgIGVsZW0gPSBlbGVtWzBdIHx8IGVsZW07XG4gICAgICAgICAgaWYgKGlzTmFOKGVsZW0ub2Zmc2V0SGVpZ2h0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgb2Zmc2V0VG9wID0gZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgIGlmICghZWxlbVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgfHwgZWxlbS5jc3MoJ25vbmUnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZWxlbVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyBwYWdlWU9mZnNldChlbGVtKTtcbiAgICAgICAgfTtcbiAgICAgICAgcGFnZVlPZmZzZXQgPSBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgZWxlbSA9IGVsZW1bMF0gfHwgZWxlbTtcbiAgICAgICAgICBpZiAoaXNOYU4od2luZG93LnBhZ2VZT2Zmc2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5wYWdlWU9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyQm90dG9tLCBjb250YWluZXJUb3BPZmZzZXQsIGVsZW1lbnRCb3R0b20sIHJlbWFpbmluZywgc2hvdWxkU2Nyb2xsO1xuICAgICAgICAgIGlmIChjb250YWluZXIgPT09IHdpbmRvd0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckJvdHRvbSA9IGhlaWdodChjb250YWluZXIpICsgcGFnZVlPZmZzZXQoY29udGFpbmVyWzBdLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgICAgICAgICBlbGVtZW50Qm90dG9tID0gb2Zmc2V0VG9wKGVsZW0pICsgaGVpZ2h0KGVsZW0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXJCb3R0b20gPSBoZWlnaHQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGNvbnRhaW5lclRvcE9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0VG9wKGNvbnRhaW5lcikgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb250YWluZXJUb3BPZmZzZXQgPSBvZmZzZXRUb3AoY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnRCb3R0b20gPSBvZmZzZXRUb3AoZWxlbSkgLSBjb250YWluZXJUb3BPZmZzZXQgKyBoZWlnaHQoZWxlbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1c2VEb2N1bWVudEJvdHRvbSkge1xuICAgICAgICAgICAgZWxlbWVudEJvdHRvbSA9IGhlaWdodCgoZWxlbVswXS5vd25lckRvY3VtZW50IHx8IGVsZW1bMF0uZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlbWFpbmluZyA9IGVsZW1lbnRCb3R0b20gLSBjb250YWluZXJCb3R0b207XG4gICAgICAgICAgc2hvdWxkU2Nyb2xsID0gcmVtYWluaW5nIDw9IGhlaWdodChjb250YWluZXIpICogc2Nyb2xsRGlzdGFuY2UgKyAxO1xuICAgICAgICAgIGlmIChzaG91bGRTY3JvbGwpIHtcbiAgICAgICAgICAgIGNoZWNrV2hlbkVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHNjcm9sbEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgaWYgKHNjb3BlLiQkcGhhc2UgfHwgJHJvb3RTY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmluZmluaXRlU2Nyb2xsKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLiRhcHBseShzY29wZS5pbmZpbml0ZVNjcm9sbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoZWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgJGludGVydmFsLmNhbmNlbChjaGVja0ludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGVja1doZW5FbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICAgICAgICB2YXIgbGF0ZXIsIHByZXZpb3VzLCB0aW1lb3V0O1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHByZXZpb3VzID0gMDtcbiAgICAgICAgICBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcHJldmlvdXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICRpbnRlcnZhbC5jYW5jZWwodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBub3csIHJlbWFpbmluZztcbiAgICAgICAgICAgIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgJGludGVydmFsLmNhbmNlbCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGltZW91dCA9ICRpbnRlcnZhbChsYXRlciwgcmVtYWluaW5nLCAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGlmIChUSFJPVFRMRV9NSUxMSVNFQ09ORFMgIT0gbnVsbCkge1xuICAgICAgICAgIGhhbmRsZXIgPSB0aHJvdHRsZShoYW5kbGVyLCBUSFJPVFRMRV9NSUxMSVNFQ09ORFMpO1xuICAgICAgICB9XG4gICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb250YWluZXIudW5iaW5kKCdzY3JvbGwnLCBoYW5kbGVyKTtcbiAgICAgICAgICBpZiAodW5yZWdpc3RlckV2ZW50TGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudExpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoZWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiAkaW50ZXJ2YWwuY2FuY2VsKGNoZWNrSW50ZXJ2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGhhbmRsZUluZmluaXRlU2Nyb2xsRGlzdGFuY2UgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIHNjcm9sbERpc3RhbmNlID0gcGFyc2VGbG9hdCh2KSB8fCAwO1xuICAgICAgICB9O1xuICAgICAgICBzY29wZS4kd2F0Y2goJ2luZmluaXRlU2Nyb2xsRGlzdGFuY2UnLCBoYW5kbGVJbmZpbml0ZVNjcm9sbERpc3RhbmNlKTtcbiAgICAgICAgaGFuZGxlSW5maW5pdGVTY3JvbGxEaXN0YW5jZShzY29wZS5pbmZpbml0ZVNjcm9sbERpc3RhbmNlKTtcbiAgICAgICAgaGFuZGxlSW5maW5pdGVTY3JvbGxEaXNhYmxlZCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICBzY3JvbGxFbmFibGVkID0gIXY7XG4gICAgICAgICAgaWYgKHNjcm9sbEVuYWJsZWQgJiYgY2hlY2tXaGVuRW5hYmxlZCkge1xuICAgICAgICAgICAgY2hlY2tXaGVuRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNjb3BlLiR3YXRjaCgnaW5maW5pdGVTY3JvbGxEaXNhYmxlZCcsIGhhbmRsZUluZmluaXRlU2Nyb2xsRGlzYWJsZWQpO1xuICAgICAgICBoYW5kbGVJbmZpbml0ZVNjcm9sbERpc2FibGVkKHNjb3BlLmluZmluaXRlU2Nyb2xsRGlzYWJsZWQpO1xuICAgICAgICBoYW5kbGVJbmZpbml0ZVNjcm9sbFVzZURvY3VtZW50Qm90dG9tID0gZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiB1c2VEb2N1bWVudEJvdHRvbSA9IHY7XG4gICAgICAgIH07XG4gICAgICAgIHNjb3BlLiR3YXRjaCgnaW5maW5pdGVTY3JvbGxVc2VEb2N1bWVudEJvdHRvbScsIGhhbmRsZUluZmluaXRlU2Nyb2xsVXNlRG9jdW1lbnRCb3R0b20pO1xuICAgICAgICBoYW5kbGVJbmZpbml0ZVNjcm9sbFVzZURvY3VtZW50Qm90dG9tKHNjb3BlLmluZmluaXRlU2Nyb2xsVXNlRG9jdW1lbnRCb3R0b20pO1xuICAgICAgICBjaGFuZ2VDb250YWluZXIgPSBmdW5jdGlvbihuZXdDb250YWluZXIpIHtcbiAgICAgICAgICBpZiAoY29udGFpbmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci51bmJpbmQoJ3Njcm9sbCcsIGhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250YWluZXIgPSBuZXdDb250YWluZXI7XG4gICAgICAgICAgaWYgKG5ld0NvbnRhaW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyLmJpbmQoJ3Njcm9sbCcsIGhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2hhbmdlQ29udGFpbmVyKHdpbmRvd0VsZW1lbnQpO1xuICAgICAgICBpZiAoc2NvcGUuaW5maW5pdGVTY3JvbGxMaXN0ZW5Gb3JFdmVudCkge1xuICAgICAgICAgIHVucmVnaXN0ZXJFdmVudExpc3RlbmVyID0gJHJvb3RTY29wZS4kb24oc2NvcGUuaW5maW5pdGVTY3JvbGxMaXN0ZW5Gb3JFdmVudCwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlSW5maW5pdGVTY3JvbGxDb250YWluZXIgPSBmdW5jdGlvbihuZXdDb250YWluZXIpIHtcbiAgICAgICAgICBpZiAoKG5ld0NvbnRhaW5lciA9PSBudWxsKSB8fCBuZXdDb250YWluZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdDb250YWluZXIubm9kZVR5cGUgJiYgbmV3Q29udGFpbmVyLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICBuZXdDb250YWluZXIgPSBhbmd1bGFyLmVsZW1lbnQobmV3Q29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXdDb250YWluZXIuYXBwZW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBuZXdDb250YWluZXIgPSBhbmd1bGFyLmVsZW1lbnQobmV3Q29udGFpbmVyW25ld0NvbnRhaW5lci5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV3Q29udGFpbmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbmV3Q29udGFpbmVyID0gYW5ndWxhci5lbGVtZW50KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IobmV3Q29udGFpbmVyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdDb250YWluZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZUNvbnRhaW5lcihuZXdDb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGluZmluaXRlLXNjcm9sbC1jb250YWluZXIgYXR0cmlidXRlLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNjb3BlLiR3YXRjaCgnaW5maW5pdGVTY3JvbGxDb250YWluZXInLCBoYW5kbGVJbmZpbml0ZVNjcm9sbENvbnRhaW5lcik7XG4gICAgICAgIGhhbmRsZUluZmluaXRlU2Nyb2xsQ29udGFpbmVyKHNjb3BlLmluZmluaXRlU2Nyb2xsQ29udGFpbmVyIHx8IFtdKTtcbiAgICAgICAgaWYgKGF0dHJzLmluZmluaXRlU2Nyb2xsUGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBjaGFuZ2VDb250YWluZXIoYW5ndWxhci5lbGVtZW50KGVsZW0ucGFyZW50KCkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMuaW5maW5pdGVTY3JvbGxJbW1lZGlhdGVDaGVjayAhPSBudWxsKSB7XG4gICAgICAgICAgaW1tZWRpYXRlQ2hlY2sgPSBzY29wZS4kZXZhbChhdHRycy5pbmZpbml0ZVNjcm9sbEltbWVkaWF0ZUNoZWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hlY2tJbnRlcnZhbCA9ICRpbnRlcnZhbCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGltbWVkaWF0ZUNoZWNrKSB7XG4gICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAkaW50ZXJ2YWwuY2FuY2VsKGNoZWNrSW50ZXJ2YWwpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXSk7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzID09PSBleHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gJ2luZmluaXRlLXNjcm9sbCc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbmctaW5maW5pdGUtc2Nyb2xsL2J1aWxkL25nLWluZmluaXRlLXNjcm9sbC5qc1xuLy8gbW9kdWxlIGlkID0gNjIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 621:
/* no static exports found */
/* all exports used */
/*!*****************************************!*\
  !*** ./~/ngmap/build/scripts/ng-map.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("(function(root, factory) {\r\nif (true) {\r\nmodule.exports = factory(__webpack_require__(/*! angular */ 50));\r\n} else if (typeof define === \"function\" && define.amd) {\r\ndefine(['angular'], factory);\r\n} else{\r\nfactory(root.angular);\r\n}\r\n}(this, function(angular) {\r\n/**\n * AngularJS Google Maps Ver. 1.18.3\n *\n * The MIT License (MIT)\n * \n * Copyright (c) 2014, 2015, 1016 Allen Kim\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nangular.module('ngMap', []);\n\n/**\n * @ngdoc controller\n * @name MapController\n */\n(function() {\n  'use strict';\n  var Attr2MapOptions;\n\n  var __MapController = function(\n      $scope, $element, $attrs, $parse, $interpolate, _Attr2MapOptions_, NgMap, NgMapPool, escapeRegExp\n    ) {\n    Attr2MapOptions = _Attr2MapOptions_;\n    var vm = this;\n    var exprStartSymbol = $interpolate.startSymbol();\n    var exprEndSymbol = $interpolate.endSymbol();\n\n    vm.mapOptions; /** @memberof __MapController */\n    vm.mapEvents;  /** @memberof __MapController */\n    vm.eventListeners;  /** @memberof __MapController */\n\n    /**\n     * Add an object to the collection of group\n     * @memberof __MapController\n     * @function addObject\n     * @param groupName the name of collection that object belongs to\n     * @param obj  an object to add into a collection, i.e. marker, shape\n     */\n    vm.addObject = function(groupName, obj) {\n      if (vm.map) {\n        vm.map[groupName] = vm.map[groupName] || {};\n        var len = Object.keys(vm.map[groupName]).length;\n        vm.map[groupName][obj.id || len] = obj;\n\n        if (vm.map instanceof google.maps.Map) {\n          //infoWindow.setMap works like infoWindow.open\n          if (groupName != \"infoWindows\" && obj.setMap) {\n            obj.setMap && obj.setMap(vm.map);\n          }\n          if (obj.centered && obj.position) {\n            vm.map.setCenter(obj.position);\n          }\n          (groupName == 'markers') && vm.objectChanged('markers');\n          (groupName == 'customMarkers') && vm.objectChanged('customMarkers');\n        }\n      }\n    };\n\n    /**\n     * Delete an object from the collection and remove from map\n     * @memberof __MapController\n     * @function deleteObject\n     * @param {Array} objs the collection of objects. i.e., map.markers\n     * @param {Object} obj the object to be removed. i.e., marker\n     */\n    vm.deleteObject = function(groupName, obj) {\n      /* delete from group */\n      if (obj.map) {\n        var objs = obj.map[groupName];\n        for (var name in objs) {\n          if (objs[name] === obj) {\n            void 0;\n            google.maps.event.clearInstanceListeners(obj);\n            delete objs[name];\n          }\n        }\n\n        /* delete from map */\n        obj.map && obj.setMap && obj.setMap(null);\n\n        (groupName == 'markers') && vm.objectChanged('markers');\n        (groupName == 'customMarkers') && vm.objectChanged('customMarkers');\n      }\n    };\n\n    /**\n     * @memberof __MapController\n     * @function observeAttrSetObj\n     * @param {Hash} orgAttrs attributes before its initialization\n     * @param {Hash} attrs    attributes after its initialization\n     * @param {Object} obj    map object that an action is to be done\n     * @description watch changes of attribute values and\n     * do appropriate action based on attribute name\n     */\n    vm.observeAttrSetObj = function(orgAttrs, attrs, obj) {\n      if (attrs.noWatcher) {\n        return false;\n      }\n      var attrsToObserve = Attr2MapOptions.getAttrsToObserve(orgAttrs);\n      for (var i=0; i<attrsToObserve.length; i++) {\n        var attrName = attrsToObserve[i];\n        attrs.$observe(attrName, NgMap.observeAndSet(attrName, obj));\n      }\n    };\n\n    /**\n     * @memberof __MapController\n     * @function zoomToIncludeMarkers\n     */\n    vm.zoomToIncludeMarkers = function() {\n      // Only fit to bounds if we have any markers\n      // object.keys is supported in all major browsers (IE9+)\n      if ((vm.map.markers != null && Object.keys(vm.map.markers).length > 0) || (vm.map.customMarkers != null && Object.keys(vm.map.customMarkers).length > 0)) {\n        var bounds = new google.maps.LatLngBounds();\n        for (var k1 in vm.map.markers) {\n          bounds.extend(vm.map.markers[k1].getPosition());\n        }\n        for (var k2 in vm.map.customMarkers) {\n          bounds.extend(vm.map.customMarkers[k2].getPosition());\n        }\n    \t  if (vm.mapOptions.maximumZoom) {\n    \t\t  vm.enableMaximumZoomCheck = true; //enable zoom check after resizing for markers\n    \t  }\n        vm.map.fitBounds(bounds);\n      }\n    };\n\n    /**\n     * @memberof __MapController\n     * @function objectChanged\n     * @param {String} group name of group e.g., markers\n     */\n    vm.objectChanged = function(group) {\n      if ( vm.map &&\n        (group == 'markers' || group == 'customMarkers') &&\n        vm.map.zoomToIncludeMarkers == 'auto'\n      ) {\n        vm.zoomToIncludeMarkers();\n      }\n    };\n\n    /**\n     * @memberof __MapController\n     * @function initializeMap\n     * @description\n     *  . initialize Google map on <div> tag\n     *  . set map options, events, and observers\n     *  . reset zoom to include all (custom)markers\n     */\n    vm.initializeMap = function() {\n      var mapOptions = vm.mapOptions,\n          mapEvents = vm.mapEvents;\n\n      var lazyInitMap = vm.map; //prepared for lazy init\n      vm.map = NgMapPool.getMapInstance($element[0]);\n      NgMap.setStyle($element[0]);\n\n      // set objects for lazyInit\n      if (lazyInitMap) {\n\n        /**\n         * rebuild mapOptions for lazyInit\n         * because attributes values might have been changed\n         */\n        var filtered = Attr2MapOptions.filter($attrs);\n        var options = Attr2MapOptions.getOptions(filtered);\n        var controlOptions = Attr2MapOptions.getControlOptions(filtered);\n        mapOptions = angular.extend(options, controlOptions);\n        void 0;\n\n        for (var group in lazyInitMap) {\n          var groupMembers = lazyInitMap[group]; //e.g. markers\n          if (typeof groupMembers == 'object') {\n            for (var id in groupMembers) {\n              vm.addObject(group, groupMembers[id]);\n            }\n          }\n        }\n        vm.map.showInfoWindow = vm.showInfoWindow;\n        vm.map.hideInfoWindow = vm.hideInfoWindow;\n      }\n\n      // set options\n      mapOptions.zoom = mapOptions.zoom || 15;\n      var center = mapOptions.center;\n      var exprRegExp = new RegExp(escapeRegExp(exprStartSymbol) + '.*' + escapeRegExp(exprEndSymbol));\n\n      if (!mapOptions.center ||\n        ((typeof center === 'string') && center.match(exprRegExp))\n      ) {\n        mapOptions.center = new google.maps.LatLng(0, 0);\n      } else if( (typeof center === 'string') && center.match(/^[0-9.-]*,[0-9.-]*$/) ){\n        var lat = parseFloat(center.split(',')[0]);\n        var lng = parseFloat(center.split(',')[1]);\n        mapOptions.center = new google.maps.LatLng(lat, lng);\n      } else if (!(center instanceof google.maps.LatLng)) {\n        var geoCenter = mapOptions.center;\n        delete mapOptions.center;\n        NgMap.getGeoLocation(geoCenter, mapOptions.geoLocationOptions).\n          then(function (latlng) {\n            vm.map.setCenter(latlng);\n            var geoCallback = mapOptions.geoCallback;\n            geoCallback && $parse(geoCallback)($scope);\n          }, function () {\n            if (mapOptions.geoFallbackCenter) {\n              vm.map.setCenter(mapOptions.geoFallbackCenter);\n            }\n          });\n      }\n      vm.map.setOptions(mapOptions);\n\n      // set events\n      for (var eventName in mapEvents) {\n        var event = mapEvents[eventName];\n        var listener = google.maps.event.addListener(vm.map, eventName, event);\n        vm.eventListeners[eventName] = listener;\n      }\n\n      // set observers\n      vm.observeAttrSetObj(orgAttrs, $attrs, vm.map);\n      vm.singleInfoWindow = mapOptions.singleInfoWindow;\n\n      google.maps.event.trigger(vm.map, 'resize');\n\n      google.maps.event.addListenerOnce(vm.map, \"idle\", function () {\n        NgMap.addMap(vm);\n        if (mapOptions.zoomToIncludeMarkers) {\n          vm.zoomToIncludeMarkers();\n        }\n        //TODO: it's for backward compatibiliy. will be removed\n        $scope.map = vm.map;\n        $scope.$emit('mapInitialized', vm.map);\n\n        //callback\n        if ($attrs.mapInitialized) {\n          $parse($attrs.mapInitialized)($scope, {map: vm.map});\n        }\n      });\n\n\t  //add maximum zoom listeners if zoom-to-include-markers and and maximum-zoom are valid attributes\n\t  if (mapOptions.zoomToIncludeMarkers && mapOptions.maximumZoom) {\n\t    google.maps.event.addListener(vm.map, 'zoom_changed', function() {\n          if (vm.enableMaximumZoomCheck == true) {\n\t\t\tvm.enableMaximumZoomCheck = false;\n\t        google.maps.event.addListenerOnce(vm.map, 'bounds_changed', function() {\n\t\t      vm.map.setZoom(Math.min(mapOptions.maximumZoom, vm.map.getZoom()));\n\t\t    });\n\t  \t  }\n\t    });\n\t  }\n    };\n\n    $scope.google = google; //used by $scope.eval to avoid eval()\n\n    /**\n     * get map options and events\n     */\n    var orgAttrs = Attr2MapOptions.orgAttributes($element);\n    var filtered = Attr2MapOptions.filter($attrs);\n    var options = Attr2MapOptions.getOptions(filtered, {scope: $scope});\n    var controlOptions = Attr2MapOptions.getControlOptions(filtered);\n    var mapOptions = angular.extend(options, controlOptions);\n    var mapEvents = Attr2MapOptions.getEvents($scope, filtered);\n    void 0;\n    Object.keys(mapEvents).length && void 0;\n\n    vm.mapOptions = mapOptions;\n    vm.mapEvents = mapEvents;\n    vm.eventListeners = {};\n\n    if (options.lazyInit) { // allows controlled initialization\n      // parse angular expression for dynamic ids\n      if (!!$attrs.id &&\n      \t  // starts with, at position 0\n\t  $attrs.id.indexOf(exprStartSymbol, 0) === 0 &&\n\t  // ends with\n\t  $attrs.id.indexOf(exprEndSymbol, $attrs.id.length - exprEndSymbol.length) !== -1) {\n        var idExpression = $attrs.id.slice(2,-2);\n        var mapId = $parse(idExpression)($scope);\n      } else {\n        var mapId = $attrs.id;\n      }\n      vm.map = {id: mapId}; //set empty, not real, map\n      NgMap.addMap(vm);\n    } else {\n      vm.initializeMap();\n    }\n\n    //Trigger Resize\n    if(options.triggerResize) {\n      google.maps.event.trigger(vm.map, 'resize');\n    }\n\n    $element.bind('$destroy', function() {\n      NgMapPool.returnMapInstance(vm.map);\n      NgMap.deleteMap(vm);\n    });\n  }; // __MapController\n\n  __MapController.$inject = [\n    '$scope', '$element', '$attrs', '$parse', '$interpolate', 'Attr2MapOptions', 'NgMap', 'NgMapPool', 'escapeRegexpFilter'\n  ];\n  angular.module('ngMap').controller('__MapController', __MapController);\n})();\n\n/**\n * @ngdoc directive\n * @name bicycling-layer\n * @param Attr2Options {service}\n *   convert html attribute to Google map api options\n * @description\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n *\n *   <map zoom=\"13\" center=\"34.04924594193164, -118.24104309082031\">\n *     <bicycling-layer></bicycling-layer>\n *    </map>\n */\n(function() {\n  'use strict';\n  var parser;\n\n  var linkFunc = function(scope, element, attrs, mapController) {\n    mapController = mapController[0]||mapController[1];\n    var orgAttrs = parser.orgAttributes(element);\n    var filtered = parser.filter(attrs);\n    var options = parser.getOptions(filtered, {scope: scope});\n    var events = parser.getEvents(scope, filtered);\n\n    void 0;\n\n    var layer = getLayer(options, events);\n    mapController.addObject('bicyclingLayers', layer);\n    mapController.observeAttrSetObj(orgAttrs, attrs, layer);  //observers\n    element.bind('$destroy', function() {\n      mapController.deleteObject('bicyclingLayers', layer);\n    });\n  };\n\n  var getLayer = function(options, events) {\n    var layer = new google.maps.BicyclingLayer(options);\n    for (var eventName in events) {\n      google.maps.event.addListener(layer, eventName, events[eventName]);\n    }\n    return layer;\n  };\n\n  var bicyclingLayer= function(Attr2MapOptions) {\n    parser = Attr2MapOptions;\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n      link: linkFunc\n     };\n  };\n  bicyclingLayer.$inject = ['Attr2MapOptions'];\n\n  angular.module('ngMap').directive('bicyclingLayer', bicyclingLayer);\n})();\n\n/**\n * @ngdoc directive\n * @name custom-control\n * @param Attr2Options {service} convert html attribute to Google map api options\n * @param $compile {service} AngularJS $compile service\n * @description\n *   Build custom control and set to the map with position\n *\n *   Requires:  map directive\n *\n *   Restrict To:  Element\n *\n * @attr {String} position position of this control\n *        i.e. TOP_RIGHT\n * @attr {Number} index index of the control\n * @example\n *\n * Example:\n *  <map center=\"41.850033,-87.6500523\" zoom=\"3\">\n *    <custom-control id=\"home\" position=\"TOP_LEFT\" index=\"1\">\n *      <div style=\"background-color: white;\">\n *        <b>Home</b>\n *      </div>\n *    </custom-control>\n *  </map>\n *\n */\n(function() {\n  'use strict';\n  var parser, NgMap;\n\n  var linkFunc = function(scope, element, attrs, mapController, $transclude) {\n    mapController = mapController[0]||mapController[1];\n    var filtered = parser.filter(attrs);\n    var options = parser.getOptions(filtered, {scope: scope});\n    var events = parser.getEvents(scope, filtered);\n\n    /**\n     * build a custom control element\n     */\n    var customControlEl = element[0].parentElement.removeChild(element[0]);\n    var content = $transclude();\n    angular.element(customControlEl).append(content);\n\n    /**\n     * set events\n     */\n    for (var eventName in events) {\n      google.maps.event.addDomListener(customControlEl, eventName, events[eventName]);\n    }\n\n    mapController.addObject('customControls', customControlEl);\n    var position = options.position;\n    mapController.map.controls[google.maps.ControlPosition[position]].push(customControlEl);\n\n    element.bind('$destroy', function() {\n      mapController.deleteObject('customControls', customControlEl);\n    });\n  };\n\n  var customControl =  function(Attr2MapOptions, _NgMap_)  {\n    parser = Attr2MapOptions, NgMap = _NgMap_;\n\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n      link: linkFunc,\n      transclude: true\n    }; // return\n  };\n  customControl.$inject = ['Attr2MapOptions', 'NgMap'];\n\n  angular.module('ngMap').directive('customControl', customControl);\n})();\n\n/**\n * @ngdoc directive\n * @memberof ngmap\n * @name custom-marker\n * @param Attr2Options {service} convert html attribute to Google map api options\n * @param $timeout {service} AngularJS $timeout\n * @description\n *   Marker with html\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @attr {String} position required, position on map\n * @attr {Number} z-index optional\n * @attr {Boolean} visible optional\n * @example\n *\n * Example:\n *   <map center=\"41.850033,-87.6500523\" zoom=\"3\">\n *     <custom-marker position=\"41.850033,-87.6500523\">\n *       <div>\n *         <b>Home</b>\n *       </div>\n *     </custom-marker>\n *   </map>\n *\n */\n/* global document */\n(function() {\n  'use strict';\n  var parser, $timeout, $compile, NgMap;\n\n  var CustomMarker = function(options) {\n    options = options || {};\n\n    this.el = document.createElement('div');\n    this.el.style.display = 'inline-block';\n    this.el.style.visibility = \"hidden\";\n    this.visible = true;\n    for (var key in options) { /* jshint ignore:line */\n     this[key] = options[key];\n    }\n  };\n\n  var setCustomMarker = function() {\n\n    CustomMarker.prototype = new google.maps.OverlayView();\n\n    CustomMarker.prototype.setContent = function(html, scope) {\n      this.el.innerHTML = html;\n      this.el.style.position = 'absolute';\n      if (scope) {\n        $compile(angular.element(this.el).contents())(scope);\n      }\n    };\n\n    CustomMarker.prototype.getDraggable = function() {\n      return this.draggable;\n    };\n\n    CustomMarker.prototype.setDraggable = function(draggable) {\n      this.draggable = draggable;\n    };\n\n    CustomMarker.prototype.getPosition = function() {\n      return this.position;\n    };\n\n    CustomMarker.prototype.setPosition = function(position) {\n      position && (this.position = position); /* jshint ignore:line */\n      var _this = this;\n      if (this.getProjection() && typeof this.position.lng == 'function') {\n        void 0;\n        var setPosition = function() {\n          if (!_this.getProjection()) { return; }\n          var posPixel = _this.getProjection().fromLatLngToDivPixel(_this.position);\n          var x = Math.round(posPixel.x - (_this.el.offsetWidth/2));\n          var y = Math.round(posPixel.y - _this.el.offsetHeight - 10); // 10px for anchor\n          _this.el.style.left = x + \"px\";\n          _this.el.style.top = y + \"px\";\n          _this.el.style.visibility = \"visible\";\n        };\n        if (_this.el.offsetWidth && _this.el.offsetHeight) {\n          setPosition();\n        } else {\n          //delayed left/top calculation when width/height are not set instantly\n          $timeout(setPosition, 300);\n        }\n      }\n    };\n\n    CustomMarker.prototype.setZIndex = function(zIndex) {\n      zIndex && (this.zIndex = zIndex); /* jshint ignore:line */\n      this.el.style.zIndex = this.zIndex;\n    };\n\n    CustomMarker.prototype.getVisible = function() {\n      return this.visible;\n    };\n\n    CustomMarker.prototype.setVisible = function(visible) {\n      this.el.style.display = visible ? 'inline-block' : 'none';\n      this.visible = visible;\n    };\n\n    CustomMarker.prototype.addClass = function(className) {\n      var classNames = this.el.className.trim().split(' ');\n      (classNames.indexOf(className) == -1) && classNames.push(className); /* jshint ignore:line */\n      this.el.className = classNames.join(' ');\n    };\n\n    CustomMarker.prototype.removeClass = function(className) {\n      var classNames = this.el.className.split(' ');\n      var index = classNames.indexOf(className);\n      (index > -1) && classNames.splice(index, 1); /* jshint ignore:line */\n      this.el.className = classNames.join(' ');\n    };\n\n    CustomMarker.prototype.onAdd = function() {\n      this.getPanes().overlayMouseTarget.appendChild(this.el);\n    };\n\n    CustomMarker.prototype.draw = function() {\n      this.setPosition();\n      this.setZIndex(this.zIndex);\n      this.setVisible(this.visible);\n    };\n\n    CustomMarker.prototype.onRemove = function() {\n      this.el.parentNode.removeChild(this.el);\n      //this.el = null;\n    };\n  };\n\n  var linkFunc = function(orgHtml, varsToWatch) {\n    //console.log('orgHtml', orgHtml, 'varsToWatch', varsToWatch);\n\n    return function(scope, element, attrs, mapController) {\n      mapController = mapController[0]||mapController[1];\n      var orgAttrs = parser.orgAttributes(element);\n\n      var filtered = parser.filter(attrs);\n      var options = parser.getOptions(filtered, {scope: scope});\n      var events = parser.getEvents(scope, filtered);\n\n      /**\n       * build a custom marker element\n       */\n      element[0].style.display = 'none';\n      void 0;\n      var customMarker = new CustomMarker(options);\n\n      $timeout(function() { //apply contents, class, and location after it is compiled\n\n        scope.$watch('[' + varsToWatch.join(',') + ']', function() {\n          customMarker.setContent(orgHtml, scope);\n        }, true);\n\n        customMarker.setContent(element[0].innerHTML, scope);\n        var classNames = element[0].firstElementChild.className;\n        customMarker.addClass('custom-marker');\n        customMarker.addClass(classNames);\n        void 0;\n\n        if (!(options.position instanceof google.maps.LatLng)) {\n          NgMap.getGeoLocation(options.position).then(\n                function(latlng) {\n                  customMarker.setPosition(latlng);\n                }\n          );\n        }\n\n      });\n\n      void 0;\n      for (var eventName in events) { /* jshint ignore:line */\n        google.maps.event.addDomListener(\n          customMarker.el, eventName, events[eventName]);\n      }\n      mapController.addObject('customMarkers', customMarker);\n\n      //set observers\n      mapController.observeAttrSetObj(orgAttrs, attrs, customMarker);\n\n      element.bind('$destroy', function() {\n        //Is it required to remove event listeners when DOM is removed?\n        mapController.deleteObject('customMarkers', customMarker);\n      });\n\n    }; // linkFunc\n  };\n\n\n  var customMarkerDirective = function(\n      _$timeout_, _$compile_, $interpolate, Attr2MapOptions, _NgMap_, escapeRegExp\n    )  {\n    parser = Attr2MapOptions;\n    $timeout = _$timeout_;\n    $compile = _$compile_;\n    NgMap = _NgMap_;\n\n    var exprStartSymbol = $interpolate.startSymbol();\n    var exprEndSymbol = $interpolate.endSymbol();\n    var exprRegExp = new RegExp(escapeRegExp(exprStartSymbol) + '([^' + exprEndSymbol.substring(0, 1) + ']+)' + escapeRegExp(exprEndSymbol), 'g');\n\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n      compile: function(element) {\n        setCustomMarker();\n        element[0].style.display ='none';\n        var orgHtml = element.html();\n        var matches = orgHtml.match(exprRegExp);\n        var varsToWatch = [];\n        //filter out that contains '::', 'this.'\n        (matches || []).forEach(function(match) {\n          var toWatch = match.replace(exprStartSymbol,'').replace(exprEndSymbol,'');\n          if (match.indexOf('::') == -1 &&\n            match.indexOf('this.') == -1 &&\n            varsToWatch.indexOf(toWatch) == -1) {\n            varsToWatch.push(match.replace(exprStartSymbol,'').replace(exprEndSymbol,''));\n          }\n        });\n\n        return linkFunc(orgHtml, varsToWatch);\n      }\n    }; // return\n  };// function\n  customMarkerDirective.$inject =\n    ['$timeout', '$compile', '$interpolate', 'Attr2MapOptions', 'NgMap', 'escapeRegexpFilter'];\n\n  angular.module('ngMap').directive('customMarker', customMarkerDirective);\n})();\n\n/**\n * @ngdoc directive\n * @name directions\n * @description\n *   Enable directions on map.\n *   e.g., origin, destination, draggable, waypoints, etc\n *\n *   Requires:  map directive\n *\n *   Restrict To:  Element\n *\n * @attr {String} DirectionsRendererOptions\n *   [Any DirectionsRendererOptions](https://developers.google.com/maps/documentation/javascript/reference#DirectionsRendererOptions)\n * @attr {String} DirectionsRequestOptions\n *   [Any DirectionsRequest options](https://developers.google.com/maps/documentation/javascript/reference#DirectionsRequest)\n * @example\n *  <map zoom=\"14\" center=\"37.7699298, -122.4469157\">\n *    <directions\n *      draggable=\"true\"\n *      panel=\"directions-panel\"\n *      travel-mode=\"{{travelMode}}\"\n *      waypoints=\"[{location:'kingston', stopover:true}]\"\n *      origin=\"{{origin}}\"\n *      destination=\"{{destination}}\">\n *    </directions>\n *  </map>\n */\n/* global document */\n(function() {\n  'use strict';\n  var NgMap, $timeout, NavigatorGeolocation;\n\n  var getDirectionsRenderer = function(options, events) {\n    if (options.panel) {\n      options.panel = document.getElementById(options.panel) ||\n        document.querySelector(options.panel);\n    }\n    var renderer = new google.maps.DirectionsRenderer(options);\n    for (var eventName in events) {\n      google.maps.event.addListener(renderer, eventName, events[eventName]);\n    }\n    return renderer;\n  };\n\n  var updateRoute = function(renderer, options) {\n    var directionsService = new google.maps.DirectionsService();\n\n    /* filter out valid keys only for DirectionsRequest object*/\n    var request = options;\n    request.travelMode = request.travelMode || 'DRIVING';\n    var validKeys = [\n      'origin', 'destination', 'travelMode', 'transitOptions', 'unitSystem',\n      'durationInTraffic', 'waypoints', 'optimizeWaypoints', \n      'provideRouteAlternatives', 'avoidHighways', 'avoidTolls', 'region'\n    ];\n    for(var key in request){\n      (validKeys.indexOf(key) === -1) && (delete request[key]);\n    }\n\n    if(request.waypoints) {\n      // Check fo valid values\n      if(request.waypoints == \"[]\" || request.waypoints === \"\") {\n        delete request.waypoints;\n      }\n    }\n\n    var showDirections = function(request) {\n      directionsService.route(request, function(response, status) {\n        if (status == google.maps.DirectionsStatus.OK) {\n          $timeout(function() {\n            renderer.setDirections(response);\n          });\n        }\n      });\n    };\n\n    if (request.origin && request.destination) {\n      if (request.origin == 'current-location') {\n        NavigatorGeolocation.getCurrentPosition().then(function(ll) {\n          request.origin = new google.maps.LatLng(ll.coords.latitude, ll.coords.longitude);\n          showDirections(request);\n        });\n      } else if (request.destination == 'current-location') {\n        NavigatorGeolocation.getCurrentPosition().then(function(ll) {\n          request.destination = new google.maps.LatLng(ll.coords.latitude, ll.coords.longitude);\n          showDirections(request);\n        });\n      } else {\n        showDirections(request);\n      }\n    }\n  };\n\n  var directions = function(\n      Attr2MapOptions, _$timeout_, _NavigatorGeolocation_, _NgMap_) {\n    var parser = Attr2MapOptions;\n    NgMap = _NgMap_;\n    $timeout = _$timeout_;\n    NavigatorGeolocation = _NavigatorGeolocation_;\n\n    var linkFunc = function(scope, element, attrs, mapController) {\n      mapController = mapController[0]||mapController[1];\n\n      var orgAttrs = parser.orgAttributes(element);\n      var filtered = parser.filter(attrs);\n      var options = parser.getOptions(filtered, {scope: scope});\n      var events = parser.getEvents(scope, filtered);\n      var attrsToObserve = parser.getAttrsToObserve(orgAttrs);\n\n      var renderer = getDirectionsRenderer(options, events);\n      mapController.addObject('directionsRenderers', renderer);\n\n      attrsToObserve.forEach(function(attrName) {\n        (function(attrName) {\n          attrs.$observe(attrName, function(val) {\n            if (attrName == 'panel') {\n              $timeout(function(){\n                var panel =\n                  document.getElementById(val) || document.querySelector(val);\n                void 0;\n                panel && renderer.setPanel(panel);\n              });\n            } else if (options[attrName] !== val) { //apply only if changed\n              var optionValue = parser.toOptionValue(val, {key: attrName});\n              void 0;\n              options[attrName] = optionValue;\n              updateRoute(renderer, options);\n            }\n          });\n        })(attrName);\n      });\n\n      NgMap.getMap().then(function() {\n        updateRoute(renderer, options);\n      });\n      element.bind('$destroy', function() {\n        mapController.deleteObject('directionsRenderers', renderer);\n      });\n    };\n\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n      link: linkFunc\n    };\n  }; // var directions\n  directions.$inject =\n    ['Attr2MapOptions', '$timeout', 'NavigatorGeolocation', 'NgMap'];\n\n  angular.module('ngMap').directive('directions', directions);\n})();\n\n\n/**\n * @ngdoc directive\n * @name drawing-manager\n * @param Attr2Options {service} convert html attribute to Google map api options\n * @description\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example:\n *\n *  <map zoom=\"13\" center=\"37.774546, -122.433523\" map-type-id=\"SATELLITE\">\n *    <drawing-manager\n *      on-overlaycomplete=\"onMapOverlayCompleted()\"\n *      position=\"ControlPosition.TOP_CENTER\"\n *      drawingModes=\"POLYGON,CIRCLE\"\n *      drawingControl=\"true\"\n *      circleOptions=\"fillColor: '#FFFF00';fillOpacity: 1;strokeWeight: 5;clickable: false;zIndex: 1;editable: true;\" >\n *    </drawing-manager>\n *  </map>\n *\n *  TODO: Add remove button.\n *  currently, for our solution, we have the shapes/markers in our own\n *  controller, and we use some css classes to change the shape button\n *  to a remove button (<div>X</div>) and have the remove operation in our own controller.\n */\n(function() {\n  'use strict';\n  angular.module('ngMap').directive('drawingManager', [\n    'Attr2MapOptions', function(Attr2MapOptions) {\n    var parser = Attr2MapOptions;\n\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n\n      link: function(scope, element, attrs, mapController) {\n        mapController = mapController[0]||mapController[1];\n\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered, {scope: scope});\n        var controlOptions = parser.getControlOptions(filtered);\n        var events = parser.getEvents(scope, filtered);\n\n        /**\n         * set options\n         */\n        var drawingManager = new google.maps.drawing.DrawingManager({\n          drawingMode: options.drawingmode,\n          drawingControl: options.drawingcontrol,\n          drawingControlOptions: controlOptions.drawingControlOptions,\n          circleOptions:options.circleoptions,\n          markerOptions:options.markeroptions,\n          polygonOptions:options.polygonoptions,\n          polylineOptions:options.polylineoptions,\n          rectangleOptions:options.rectangleoptions\n        });\n\n        //Observers\n        attrs.$observe('drawingControlOptions', function (newValue) {\n          drawingManager.drawingControlOptions = parser.getControlOptions({drawingControlOptions: newValue}).drawingControlOptions;\n          drawingManager.setDrawingMode(null);\n          drawingManager.setMap(mapController.map);\n        });\n\n\n        /**\n         * set events\n         */\n        for (var eventName in events) {\n          google.maps.event.addListener(drawingManager, eventName, events[eventName]);\n        }\n\n        mapController.addObject('mapDrawingManager', drawingManager);\n\n        element.bind('$destroy', function() {\n          mapController.deleteObject('mapDrawingManager', drawingManager);\n        });\n      }\n    }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name dynamic-maps-engine-layer\n * @description\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example:\n *   <map zoom=\"14\" center=\"[59.322506, 18.010025]\">\n *     <dynamic-maps-engine-layer\n *       layer-id=\"06673056454046135537-08896501997766553811\">\n *     </dynamic-maps-engine-layer>\n *    </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('dynamicMapsEngineLayer', [\n    'Attr2MapOptions', function(Attr2MapOptions) {\n    var parser = Attr2MapOptions;\n\n    var getDynamicMapsEngineLayer = function(options, events) {\n      var layer = new google.maps.visualization.DynamicMapsEngineLayer(options);\n\n      for (var eventName in events) {\n        google.maps.event.addListener(layer, eventName, events[eventName]);\n      }\n\n      return layer;\n    };\n\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n\n      link: function(scope, element, attrs, mapController) {\n        mapController = mapController[0]||mapController[1];\n\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered, {scope: scope});\n        var events = parser.getEvents(scope, filtered, events);\n\n        var layer = getDynamicMapsEngineLayer(options, events);\n        mapController.addObject('mapsEngineLayers', layer);\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name fusion-tables-layer\n * @description\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example:\n *   <map zoom=\"11\" center=\"41.850033, -87.6500523\">\n *     <fusion-tables-layer query=\"{\n *       select: 'Geocodable address',\n *       from: '1mZ53Z70NsChnBMm-qEYmSDOvLXgrreLTkQUvvg'}\">\n *     </fusion-tables-layer>\n *   </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('fusionTablesLayer', [\n    'Attr2MapOptions', function(Attr2MapOptions) {\n    var parser = Attr2MapOptions;\n\n    var getLayer = function(options, events) {\n      var layer = new google.maps.FusionTablesLayer(options);\n\n      for (var eventName in events) {\n        google.maps.event.addListener(layer, eventName, events[eventName]);\n      }\n\n      return layer;\n    };\n\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n\n      link: function(scope, element, attrs, mapController) {\n        mapController = mapController[0]||mapController[1];\n\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered, {scope: scope});\n        var events = parser.getEvents(scope, filtered, events);\n        void 0;\n\n        var layer = getLayer(options, events);\n        mapController.addObject('fusionTablesLayers', layer);\n        element.bind('$destroy', function() {\n          mapController.deleteObject('fusionTablesLayers', layer);\n        });\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name heatmap-layer\n * @param Attr2Options {service} convert html attribute to Google map api options\n * @description\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n *\n * <map zoom=\"11\" center=\"[41.875696,-87.624207]\">\n *   <heatmap-layer data=\"taxiData\"></heatmap-layer>\n * </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('heatmapLayer', [\n    'Attr2MapOptions', '$window', function(Attr2MapOptions, $window) {\n    var parser = Attr2MapOptions;\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n\n      link: function(scope, element, attrs, mapController) {\n        mapController = mapController[0]||mapController[1];\n\n        var filtered = parser.filter(attrs);\n\n        /**\n         * set options\n         */\n        var options = parser.getOptions(filtered, {scope: scope});\n        options.data = $window[attrs.data] || scope[attrs.data];\n        if (options.data instanceof Array) {\n          options.data = new google.maps.MVCArray(options.data);\n        } else {\n          throw \"invalid heatmap data\";\n        }\n        var layer = new google.maps.visualization.HeatmapLayer(options);\n\n        /**\n         * set events\n         */\n        var events = parser.getEvents(scope, filtered);\n        void 0;\n\n        mapController.addObject('heatmapLayers', layer);\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name info-window\n * @param Attr2MapOptions {service}\n *   convert html attribute to Google map api options\n * @param $compile {service} $compile service\n * @description\n *  Defines infoWindow and provides compile method\n *\n *  Requires:  map directive\n *\n *  Restrict To:  Element\n *\n *  NOTE: this directive should **NOT** be used with `ng-repeat`\n *  because InfoWindow itself is a template, and a template must be\n *  reused by each marker, thus, should not be redefined repeatedly\n *  by `ng-repeat`.\n *\n * @attr {Boolean} visible\n *   Indicates to show it when map is initialized\n * @attr {Boolean} visible-on-marker\n *   Indicates to show it on a marker when map is initialized\n * @attr {Expression} geo-callback\n *   if position is an address, the expression is will be performed\n *   when geo-lookup is successful. e.g., geo-callback=\"showDetail()\"\n * @attr {String} &lt;InfoWindowOption> Any InfoWindow options,\n *   https://developers.google.com/maps/documentation/javascript/reference?csw=1#InfoWindowOptions\n * @attr {String} &lt;InfoWindowEvent> Any InfoWindow events,\n *   https://developers.google.com/maps/documentation/javascript/reference\n * @example\n * Usage:\n *   <map MAP_ATTRIBUTES>\n *    <info-window id=\"foo\" ANY_OPTIONS ANY_EVENTS\"></info-window>\n *   </map>\n *\n * Example:\n *  <map center=\"41.850033,-87.6500523\" zoom=\"3\">\n *    <info-window id=\"1\" position=\"41.850033,-87.6500523\" >\n *      <div ng-non-bindable>\n *        Chicago, IL<br/>\n *        LatLng: {{chicago.lat()}}, {{chicago.lng()}}, <br/>\n *        World Coordinate: {{worldCoordinate.x}}, {{worldCoordinate.y}}, <br/>\n *        Pixel Coordinate: {{pixelCoordinate.x}}, {{pixelCoordinate.y}}, <br/>\n *        Tile Coordinate: {{tileCoordinate.x}}, {{tileCoordinate.y}} at Zoom Level {{map.getZoom()}}\n *      </div>\n *    </info-window>\n *  </map>\n */\n/* global google */\n(function() {\n  'use strict';\n\n  var infoWindow = function(Attr2MapOptions, $compile, $q, $templateRequest, $timeout, $parse, NgMap)  {\n    var parser = Attr2MapOptions;\n\n    var getInfoWindow = function(options, events, element) {\n      var infoWindow;\n\n      /**\n       * set options\n       */\n      if (options.position && !(options.position instanceof google.maps.LatLng)) {\n        delete options.position;\n      }\n      infoWindow = new google.maps.InfoWindow(options);\n\n      /**\n       * set events\n       */\n      for (var eventName in events) {\n        if (eventName) {\n          google.maps.event.addListener(infoWindow, eventName, events[eventName]);\n        }\n      }\n\n      /**\n       * set template and template-related functions\n       * it must have a container element with ng-non-bindable\n       */\n      var templatePromise = $q(function(resolve) {\n        if (angular.isString(element)) {\n          $templateRequest(element).then(function (requestedTemplate) {\n            resolve(angular.element(requestedTemplate).wrap('<div>').parent());\n          }, function(message) {\n            throw \"info-window template request failed: \" + message;\n          });\n        }\n        else {\n          resolve(element);\n        }\n      }).then(function(resolvedTemplate) {\n        var template = resolvedTemplate.html().trim();\n        if (angular.element(template).length != 1) {\n          throw \"info-window working as a template must have a container\";\n        }\n        infoWindow.__template = template.replace(/\\s?ng-non-bindable[='\"]+/,\"\");\n      });\n\n      infoWindow.__open = function(map, scope, anchor) {\n        templatePromise.then(function() {\n          $timeout(function() {\n            anchor && (scope.anchor = anchor);\n            var el = $compile(infoWindow.__template)(scope);\n            infoWindow.setContent(el[0]);\n            scope.$apply();\n            if (anchor && anchor.getPosition) {\n              infoWindow.open(map, anchor);\n            } else if (anchor && anchor instanceof google.maps.LatLng) {\n              infoWindow.open(map);\n              infoWindow.setPosition(anchor);\n            } else {\n              infoWindow.open(map);\n            }\n            var infoWindowContainerEl = infoWindow.content.parentElement.parentElement.parentElement;\n            infoWindowContainerEl.className = \"ng-map-info-window\";\n          });\n        });\n      };\n\n      return infoWindow;\n    };\n\n    var linkFunc = function(scope, element, attrs, mapController) {\n      mapController = mapController[0]||mapController[1];\n\n      element.css('display','none');\n\n      var orgAttrs = parser.orgAttributes(element);\n      var filtered = parser.filter(attrs);\n      var options = parser.getOptions(filtered, {scope: scope});\n      var events = parser.getEvents(scope, filtered);\n\n      var infoWindow = getInfoWindow(options, events, options.template || element);\n      var address;\n      if (options.position && !(options.position instanceof google.maps.LatLng)) {\n        address = options.position;\n      }\n      if (address) {\n        NgMap.getGeoLocation(address).then(function(latlng) {\n          infoWindow.setPosition(latlng);\n          infoWindow.__open(mapController.map, scope, latlng);\n          var geoCallback = attrs.geoCallback;\n          geoCallback && $parse(geoCallback)(scope);\n        });\n      }\n\n      mapController.addObject('infoWindows', infoWindow);\n      mapController.observeAttrSetObj(orgAttrs, attrs, infoWindow);\n\n      mapController.showInfoWindow =\n      mapController.map.showInfoWindow = mapController.showInfoWindow ||\n        function(p1, p2, p3) { //event, id, marker\n          var id = typeof p1 == 'string' ? p1 : p2;\n          var marker = typeof p1 == 'string' ? p2 : p3;\n          if (typeof marker == 'string') {\n            //Check if markers if defined to avoid odd 'undefined' errors\n            if (\n              typeof mapController.map.markers != \"undefined\"\n              && typeof mapController.map.markers[marker] != \"undefined\") {\n                marker = mapController.map.markers[marker];\n            } else if (\n              //additionally check if that marker is a custom marker\n              typeof mapController.map.customMarkers !== \"undefined\"\n              && typeof mapController.map.customMarkers[marker] !== \"undefined\") {\n                marker = mapController.map.customMarkers[marker];\n            } else {\n              //Better error output if marker with that id is not defined\n              throw new Error(\"Cant open info window for id \" + marker + \". Marker or CustomMarker is not defined\")\n            }\n          }\n\n          var infoWindow = mapController.map.infoWindows[id];\n          var anchor = marker ? marker : (this.getPosition ? this : null);\n          infoWindow.__open(mapController.map, scope, anchor);\n          if(mapController.singleInfoWindow) {\n            if(mapController.lastInfoWindow) {\n              scope.hideInfoWindow(mapController.lastInfoWindow);\n            }\n            mapController.lastInfoWindow = id;\n          }\n        };\n\n      mapController.hideInfoWindow =\n      mapController.map.hideInfoWindow = mapController.hideInfoWindow ||\n        function(p1, p2) {\n          var id = typeof p1 == 'string' ? p1 : p2;\n          var infoWindow = mapController.map.infoWindows[id];\n          infoWindow.close();\n        };\n\n      //TODO DEPRECATED\n      scope.showInfoWindow = mapController.map.showInfoWindow;\n      scope.hideInfoWindow = mapController.map.hideInfoWindow;\n\n      var map = infoWindow.mapId ? {id:infoWindow.mapId} : 0;\n      NgMap.getMap(map).then(function(map) {\n        infoWindow.visible && infoWindow.__open(map, scope);\n        if (infoWindow.visibleOnMarker) {\n          var markerId = infoWindow.visibleOnMarker;\n          infoWindow.__open(map, scope, map.markers[markerId]);\n        }\n      });\n\n    }; //link\n\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n      link: linkFunc\n    };\n\n  }; // infoWindow\n  infoWindow.$inject =\n    ['Attr2MapOptions', '$compile', '$q', '$templateRequest', '$timeout', '$parse', 'NgMap'];\n\n  angular.module('ngMap').directive('infoWindow', infoWindow);\n})();\n\n/**\n * @ngdoc directive\n * @name kml-layer\n * @param Attr2MapOptions {service} convert html attribute to Google map api options\n * @description\n *   renders Kml layer on a map\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @attr {Url} url url of the kml layer\n * @attr {KmlLayerOptions} KmlLayerOptions\n *   (https://developers.google.com/maps/documentation/javascript/reference#KmlLayerOptions) \n * @attr {String} &lt;KmlLayerEvent> Any KmlLayer events,\n *   https://developers.google.com/maps/documentation/javascript/reference\n * @example\n * Usage:\n *   <map MAP_ATTRIBUTES>\n *    <kml-layer ANY_KML_LAYER ANY_KML_LAYER_EVENTS\"></kml-layer>\n *   </map>\n *\n * Example:\n *\n * <map zoom=\"11\" center=\"[41.875696,-87.624207]\">\n *   <kml-layer url=\"https://gmaps-samples.googlecode.com/svn/trunk/ggeoxml/cta.kml\" >\n *   </kml-layer>\n * </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('kmlLayer', [\n    'Attr2MapOptions', function(Attr2MapOptions) {\n    var parser = Attr2MapOptions;\n\n    var getKmlLayer = function(options, events) {\n      var kmlLayer = new google.maps.KmlLayer(options);\n      for (var eventName in events) {\n        google.maps.event.addListener(kmlLayer, eventName, events[eventName]);\n      }\n      return kmlLayer;\n    };\n\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n\n      link: function(scope, element, attrs, mapController) {\n        mapController = mapController[0]||mapController[1];\n\n        var orgAttrs = parser.orgAttributes(element);\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered, {scope: scope});\n        var events = parser.getEvents(scope, filtered);\n        void 0;\n\n        var kmlLayer = getKmlLayer(options, events);\n        mapController.addObject('kmlLayers', kmlLayer);\n        mapController.observeAttrSetObj(orgAttrs, attrs, kmlLayer);  //observers\n        element.bind('$destroy', function() {\n          mapController.deleteObject('kmlLayers', kmlLayer);\n        });\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name map-data\n * @param Attr2MapOptions {service}\n *   convert html attribute to Google map api options\n * @description\n *   set map data\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @wn {String} method-name, run map.data[method-name] with attribute value\n * @example\n * Example:\n *\n *  <map zoom=\"11\" center=\"[41.875696,-87.624207]\">\n *    <map-data load-geo-json=\"https://storage.googleapis.com/maps-devrel/google.json\"></map-data>\n *   </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('mapData', [\n    'Attr2MapOptions', 'NgMap', function(Attr2MapOptions, NgMap) {\n    var parser = Attr2MapOptions;\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n\n      link: function(scope, element, attrs, mapController) {\n        mapController = mapController[0] || mapController[1];\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered, {scope: scope});\n        var events = parser.getEvents(scope, filtered, events);\n\n        void 0;\n        NgMap.getMap(mapController.map.id).then(function(map) {\n          //options\n          for (var key in options) {\n            var val = options[key];\n            if (typeof scope[val] === \"function\") {\n              map.data[key](scope[val]);\n            } else {\n              map.data[key](val);\n            }\n          }\n\n          //events\n          for (var eventName in events) {\n            map.data.addListener(eventName, events[eventName]);\n          }\n        });\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name map-lazy-load\n * @param Attr2Options {service} convert html attribute to Google map api options\n * @description\n *  Requires: Delay the initialization of map directive\n *    until the map is ready to be rendered\n *  Restrict To: Attribute\n *\n * @attr {String} map-lazy-load\n *    Maps api script source file location.\n *    Example:\n *      'https://maps.google.com/maps/api/js'\n * @attr {String} map-lazy-load-params\n *   Maps api script source file location via angular scope variable.\n *   Also requires the map-lazy-load attribute to be present in the directive.\n *   Example: In your controller, set\n *     $scope.googleMapsURL = 'https://maps.google.com/maps/api/js?v=3.20&client=XXXXXenter-api-key-hereXXXX'\n *\n * @example\n * Example:\n *\n *   <div map-lazy-load=\"http://maps.google.com/maps/api/js\">\n *     <map center=\"Brampton\" zoom=\"10\">\n *       <marker position=\"Brampton\"></marker>\n *     </map>\n *   </div>\n *\n *   <div map-lazy-load=\"http://maps.google.com/maps/api/js\"\n *        map-lazy-load-params=\"{{googleMapsUrl}}\">\n *     <map center=\"Brampton\" zoom=\"10\">\n *       <marker position=\"Brampton\"></marker>\n *     </map>\n *   </div>\n */\n/* global window, document */\n(function() {\n  'use strict';\n  var $timeout, $compile, src, savedHtml = [], elements = [];\n\n  var preLinkFunc = function(scope, element, attrs) {\n    var mapsUrl = attrs.mapLazyLoadParams || attrs.mapLazyLoad;\n\n    if(window.google === undefined || window.google.maps === undefined) {\n      elements.push({\n        scope: scope,\n        element: element,\n        savedHtml: savedHtml[elements.length],\n      });\n\n      window.lazyLoadCallback = function() {\n        void 0;\n        $timeout(function() { /* give some time to load */\n          elements.forEach(function(elm) {\n              elm.element.html(elm.savedHtml);\n              $compile(elm.element.contents())(elm.scope);\n          });\n        }, 100);\n      };\n\n      var scriptEl = document.createElement('script');\n      void 0;\n\n      scriptEl.src = mapsUrl +\n        (mapsUrl.indexOf('?') > -1 ? '&' : '?') +\n        'callback=lazyLoadCallback';\n\n        if (!document.querySelector('script[src=\"' + scriptEl.src + '\"]')) {\n          document.body.appendChild(scriptEl);\n        }\n    } else {\n      element.html(savedHtml);\n      $compile(element.contents())(scope);\n    }\n  };\n\n  var compileFunc = function(tElement, tAttrs) {\n\n    (!tAttrs.mapLazyLoad) && void 0;\n    savedHtml.push(tElement.html());\n    src = tAttrs.mapLazyLoad;\n\n    /**\n     * if already loaded, stop processing it\n     */\n    if(window.google !== undefined && window.google.maps !== undefined) {\n      return false;\n    }\n\n    tElement.html('');  // will compile again after script is loaded\n\n    return {\n      pre: preLinkFunc\n    };\n  };\n\n  var mapLazyLoad = function(_$compile_, _$timeout_) {\n    $compile = _$compile_, $timeout = _$timeout_;\n    return {\n      compile: compileFunc\n    };\n  };\n  mapLazyLoad.$inject = ['$compile','$timeout'];\n\n  angular.module('ngMap').directive('mapLazyLoad', mapLazyLoad);\n})();\n\n/**\n * @ngdoc directive\n * @name map-type\n * @param Attr2MapOptions {service} \n *   convert html attribute to Google map api options\n * @description\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example:\n *\n *   <map zoom=\"13\" center=\"34.04924594193164, -118.24104309082031\">\n *     <map-type name=\"coordinate\" object=\"coordinateMapType\"></map-type>\n *   </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('mapType', ['$parse', 'NgMap',\n    function($parse, NgMap) {\n\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n\n      link: function(scope, element, attrs, mapController) {\n        mapController = mapController[0]||mapController[1];\n\n        var mapTypeName = attrs.name, mapTypeObject;\n        if (!mapTypeName) {\n          throw \"invalid map-type name\";\n        }\n        mapTypeObject = $parse(attrs.object)(scope);\n        if (!mapTypeObject) {\n          throw \"invalid map-type object\";\n        }\n\n        NgMap.getMap().then(function(map) {\n          map.mapTypes.set(mapTypeName, mapTypeObject);\n        });\n        mapController.addObject('mapTypes', mapTypeObject);\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @memberof ngMap\n * @name ng-map\n * @param Attr2Options {service}\n *  convert html attribute to Google map api options\n * @description\n * Implementation of {@link __MapController}\n * Initialize a Google map within a `<div>` tag\n *   with given options and register events\n *\n * @attr {Expression} map-initialized\n *   callback function when map is initialized\n *   e.g., map-initialized=\"mycallback(map)\"\n * @attr {Expression} geo-callback if center is an address or current location,\n *   the expression is will be executed when geo-lookup is successful.\n *   e.g., geo-callback=\"showMyStoreInfo()\"\n * @attr {Array} geo-fallback-center\n *   The center of map incase geolocation failed. i.e. [0,0]\n * @attr {Object} geo-location-options\n *  The navigator geolocation options.\n *  e.g., { maximumAge: 3000, timeout: 5000, enableHighAccuracy: true }.\n *  If none specified, { timeout: 5000 }.\n *  If timeout not specified, timeout: 5000 added\n * @attr {Boolean} zoom-to-include-markers\n *  When true, map boundary will be changed automatially\n *  to include all markers when initialized\n * @attr {Boolean} default-style\n *  When false, the default styling,\n *  `display:block;height:300px`, will be ignored.\n * @attr {String} &lt;MapOption> Any Google map options,\n *  https://developers.google.com/maps/documentation/javascript/reference?csw=1#MapOptions\n * @attr {String} &lt;MapEvent> Any Google map events,\n *  https://rawgit.com/allenhwkim/angularjs-google-maps/master/build/map_events.html\n * @attr {Boolean} single-info-window\n *  When true the map will only display one info window at the time,\n *  if not set or false,\n *  everytime an info window is open it will be displayed with the othe one.\n * @attr {Boolean} trigger-resize\n *  Default to false.  Set to true to trigger resize of the map.  Needs to be done anytime you resize the map\n * @example\n * Usage:\n *   <map MAP_OPTIONS_OR_MAP_EVENTS ..>\n *     ... Any children directives\n *   </map>\n *\n * Example:\n *   <map center=\"[40.74, -74.18]\" on-click=\"doThat()\">\n *   </map>\n *\n *   <map geo-fallback-center=\"[40.74, -74.18]\" zoom-to-inlude-markers=\"true\">\n *   </map>\n */\n(function () {\n  'use strict';\n\n  var mapDirective = function () {\n    return {\n      restrict: 'AE',\n      controller: '__MapController',\n      controllerAs: 'ngmap'\n    };\n  };\n\n  angular.module('ngMap').directive('map', [mapDirective]);\n  angular.module('ngMap').directive('ngMap', [mapDirective]);\n})();\n\n/**\n * @ngdoc directive\n * @name maps-engine-layer\n * @description\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example:\n *  <map zoom=\"14\" center=\"[59.322506, 18.010025]\">\n *    <maps-engine-layer layer-id=\"06673056454046135537-08896501997766553811\">\n *    </maps-engine-layer>\n *  </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('mapsEngineLayer', ['Attr2MapOptions', function(Attr2MapOptions) {\n    var parser = Attr2MapOptions;\n\n    var getMapsEngineLayer = function(options, events) {\n      var layer = new google.maps.visualization.MapsEngineLayer(options);\n\n      for (var eventName in events) {\n        google.maps.event.addListener(layer, eventName, events[eventName]);\n      }\n\n      return layer;\n    };\n\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n\n      link: function(scope, element, attrs, mapController) {\n        mapController = mapController[0]||mapController[1];\n\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered, {scope: scope});\n        var events = parser.getEvents(scope, filtered, events);\n        void 0;\n\n        var layer = getMapsEngineLayer(options, events);\n        mapController.addObject('mapsEngineLayers', layer);\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name marker\n * @param Attr2Options {service} convert html attribute to Google map api options\n * @param NavigatorGeolocation It is used to find the current location\n * @description\n *  Draw a Google map marker on a map with given options and register events\n *\n *  Requires:  map directive\n *\n *  Restrict To:  Element\n *\n * @attr {String} position address, 'current', or [latitude, longitude]\n *  example:\n *    '1600 Pennsylvania Ave, 20500  Washingtion DC',\n *    'current position',\n *    '[40.74, -74.18]'\n * @attr {Boolean} centered if set, map will be centered with this marker\n * @attr {Expression} geo-callback if position is an address,\n *   the expression is will be performed when geo-lookup is successful.\n *   e.g., geo-callback=\"showStoreInfo()\"\n * @attr {Boolean} no-watcher if true, no attribute observer is added.\n *   Useful for many ng-repeat\n * @attr {String} &lt;MarkerOption>\n *   [Any Marker options](https://developers.google.com/maps/documentation/javascript/reference?csw=1#MarkerOptions)\n * @attr {String} &lt;MapEvent>\n *   [Any Marker events](https://developers.google.com/maps/documentation/javascript/reference)\n * @example\n * Usage:\n *   <map MAP_ATTRIBUTES>\n *    <marker ANY_MARKER_OPTIONS ANY_MARKER_EVENTS\"></MARKER>\n *   </map>\n *\n * Example:\n *   <map center=\"[40.74, -74.18]\">\n *    <marker position=\"[40.74, -74.18]\" on-click=\"myfunc()\"></div>\n *   </map>\n *\n *   <map center=\"the cn tower\">\n *    <marker position=\"the cn tower\" on-click=\"myfunc()\"></div>\n *   </map>\n */\n/* global google */\n(function() {\n  'use strict';\n  var parser, $parse, NgMap;\n\n  var getMarker = function(options, events) {\n    var marker;\n\n    if (NgMap.defaultOptions.marker) {\n      for (var key in NgMap.defaultOptions.marker) {\n        if (typeof options[key] == 'undefined') {\n          void 0;\n          options[key] = NgMap.defaultOptions.marker[key];\n        }\n      }\n    }\n\n    if (!(options.position instanceof google.maps.LatLng)) {\n      options.position = new google.maps.LatLng(0,0);\n    }\n    marker = new google.maps.Marker(options);\n\n    /**\n     * set events\n     */\n    if (Object.keys(events).length > 0) {\n      void 0;\n    }\n    for (var eventName in events) {\n      if (eventName) {\n        google.maps.event.addListener(marker, eventName, events[eventName]);\n      }\n    }\n\n    return marker;\n  };\n\n  var linkFunc = function(scope, element, attrs, mapController) {\n    mapController = mapController[0]||mapController[1];\n\n    var orgAttrs = parser.orgAttributes(element);\n    var filtered = parser.filter(attrs);\n    var markerOptions = parser.getOptions(filtered, scope, {scope: scope});\n    var markerEvents = parser.getEvents(scope, filtered);\n    void 0;\n\n    var address;\n    if (!(markerOptions.position instanceof google.maps.LatLng)) {\n      address = markerOptions.position;\n    }\n    var marker = getMarker(markerOptions, markerEvents);\n    mapController.addObject('markers', marker);\n    if (address) {\n      NgMap.getGeoLocation(address).then(function(latlng) {\n        marker.setPosition(latlng);\n        markerOptions.centered && marker.map.setCenter(latlng);\n        var geoCallback = attrs.geoCallback;\n        geoCallback && $parse(geoCallback)(scope);\n      });\n    }\n\n    //set observers\n    mapController.observeAttrSetObj(orgAttrs, attrs, marker); /* observers */\n\n    element.bind('$destroy', function() {\n      mapController.deleteObject('markers', marker);\n    });\n  };\n\n  var marker = function(Attr2MapOptions, _$parse_, _NgMap_) {\n    parser = Attr2MapOptions;\n    $parse = _$parse_;\n    NgMap = _NgMap_;\n\n    return {\n      restrict: 'E',\n      require: ['^?map','?^ngMap'],\n      link: linkFunc\n    };\n  };\n\n  marker.$inject = ['Attr2MapOptions', '$parse', 'NgMap'];\n  angular.module('ngMap').directive('marker', marker);\n\n})();\n\n/**\n * @ngdoc directive\n * @name overlay-map-type\n * @param Attr2MapOptions {service} convert html attribute to Google map api options\n * @param $window {service}\n * @description\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example:\n *\n * <map zoom=\"13\" center=\"34.04924594193164, -118.24104309082031\">\n *   <overlay-map-type index=\"0\" object=\"coordinateMapType\"></map-type>\n * </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('overlayMapType', [\n    'NgMap', function(NgMap) {\n\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n\n      link: function(scope, element, attrs, mapController) {\n        mapController = mapController[0]||mapController[1];\n\n        var initMethod = attrs.initMethod || \"insertAt\";\n        var overlayMapTypeObject = scope[attrs.object];\n\n        NgMap.getMap().then(function(map) {\n          if (initMethod == \"insertAt\") {\n            var index = parseInt(attrs.index, 10);\n            map.overlayMapTypes.insertAt(index, overlayMapTypeObject);\n          } else if (initMethod == \"push\") {\n            map.overlayMapTypes.push(overlayMapTypeObject);\n          }\n        });\n        mapController.addObject('overlayMapTypes', overlayMapTypeObject);\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name places-auto-complete\n * @param Attr2MapOptions {service} convert html attribute to Google map api options\n * @description\n *   Provides address auto complete feature to an input element\n *   Requires: input tag\n *   Restrict To: Attribute\n *\n * @attr {AutoCompleteOptions}\n *   [Any AutocompleteOptions](https://developers.google.com/maps/documentation/javascript/3.exp/reference#AutocompleteOptions)\n *\n * @example\n * Example:\n *   <script src=\"https://maps.googleapis.com/maps/api/js?libraries=places\"></script>\n *   <input places-auto-complete types=\"['geocode']\" on-place-changed=\"myCallback(place)\" component-restrictions=\"{country:'au'}\"/>\n */\n/* global google */\n(function() {\n  'use strict';\n\n  var placesAutoComplete = function(Attr2MapOptions, $timeout) {\n    var parser = Attr2MapOptions;\n\n    var linkFunc = function(scope, element, attrs, ngModelCtrl) {\n      if (attrs.placesAutoComplete ==='false') {\n        return false;\n      }\n      var filtered = parser.filter(attrs);\n      var options = parser.getOptions(filtered, {scope: scope});\n      var events = parser.getEvents(scope, filtered);\n      var autocomplete = new google.maps.places.Autocomplete(element[0], options);\n      for (var eventName in events) {\n        google.maps.event.addListener(autocomplete, eventName, events[eventName]);\n      }\n\n      var updateModel = function() {\n        $timeout(function(){\n          ngModelCtrl && ngModelCtrl.$setViewValue(element.val());\n        },100);\n      };\n      google.maps.event.addListener(autocomplete, 'place_changed', updateModel);\n      element[0].addEventListener('change', updateModel);\n\n      attrs.$observe('types', function(val) {\n        if (val) {\n          var optionValue = parser.toOptionValue(val, {key: 'types'});\n          autocomplete.setTypes(optionValue);\n        }\n      });\n\t  \n\t  attrs.$observe('componentRestrictions', function (val) {\n\t\t if (val) {\n\t\t   autocomplete.setComponentRestrictions(scope.$eval(val));\n\t\t }\n\t   });\n    };\n\t\n    return {\n      restrict: 'A',\n      require: '?ngModel',\n      link: linkFunc\n    };\n  };\n\n  placesAutoComplete.$inject = ['Attr2MapOptions', '$timeout'];\n  angular.module('ngMap').directive('placesAutoComplete', placesAutoComplete);\n})();\n\n/**\n * @ngdoc directive\n * @name shape\n * @param Attr2MapOptions {service} convert html attribute to Google map api options\n * @description\n *   Initialize a Google map shape in map with given options and register events\n *   The shapes are:\n *     . circle\n *     . polygon\n *     . polyline\n *     . rectangle\n *     . groundOverlay(or image)\n *\n *   Requires:  map directive\n *\n *   Restrict To:  Element\n *\n * @attr {Boolean} centered if set, map will be centered with this marker\n * @attr {Expression} geo-callback if shape is a circle and the center is\n *   an address, the expression is will be performed when geo-lookup\n *   is successful. e.g., geo-callback=\"showDetail()\"\n * @attr {String} &lt;OPTIONS>\n *   For circle, [any circle options](https://developers.google.com/maps/documentation/javascript/reference#CircleOptions)\n *   For polygon, [any polygon options](https://developers.google.com/maps/documentation/javascript/reference#PolygonOptions)\n *   For polyline, [any polyline options](https://developers.google.com/maps/documentation/javascript/reference#PolylineOptions)\n *   For rectangle, [any rectangle options](https://developers.google.com/maps/documentation/javascript/reference#RectangleOptions)\n *   For image, [any groundOverlay options](https://developers.google.com/maps/documentation/javascript/reference#GroundOverlayOptions)\n * @attr {String} &lt;MapEvent> [Any Shape events](https://developers.google.com/maps/documentation/javascript/reference)\n * @example\n * Usage:\n *   <map MAP_ATTRIBUTES>\n *    <shape name=SHAPE_NAME ANY_SHAPE_OPTIONS ANY_SHAPE_EVENTS\"></MARKER>\n *   </map>\n *\n * Example:\n *\n *   <map zoom=\"11\" center=\"[40.74, -74.18]\">\n *     <shape id=\"polyline\" name=\"polyline\" geodesic=\"true\"\n *       stroke-color=\"#FF0000\" stroke-opacity=\"1.0\" stroke-weight=\"2\"\n *       path=\"[[40.74,-74.18],[40.64,-74.10],[40.54,-74.05],[40.44,-74]]\" >\n *     </shape>\n *   </map>\n *\n *   <map zoom=\"11\" center=\"[40.74, -74.18]\">\n *     <shape id=\"polygon\" name=\"polygon\" stroke-color=\"#FF0000\"\n *       stroke-opacity=\"1.0\" stroke-weight=\"2\"\n *       paths=\"[[40.74,-74.18],[40.64,-74.18],[40.84,-74.08],[40.74,-74.18]]\" >\n *     </shape>\n *   </map>\n *\n *   <map zoom=\"11\" center=\"[40.74, -74.18]\">\n *     <shape id=\"rectangle\" name=\"rectangle\" stroke-color='#FF0000'\n *       stroke-opacity=\"0.8\" stroke-weight=\"2\"\n *       bounds=\"[[40.74,-74.18], [40.78,-74.14]]\" editable=\"true\" >\n *     </shape>\n *   </map>\n *\n *   <map zoom=\"11\" center=\"[40.74, -74.18]\">\n *     <shape id=\"circle\" name=\"circle\" stroke-color='#FF0000'\n *       stroke-opacity=\"0.8\"stroke-weight=\"2\"\n *       center=\"[40.70,-74.14]\" radius=\"4000\" editable=\"true\" >\n *     </shape>\n *   </map>\n *\n *   <map zoom=\"11\" center=\"[40.74, -74.18]\">\n *     <shape id=\"image\" name=\"image\"\n *       url=\"https://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg\"\n *       bounds=\"[[40.71,-74.22],[40.77,-74.12]]\" opacity=\"0.7\"\n *       clickable=\"true\">\n *     </shape>\n *   </map>\n *\n *  For full-working example, please visit\n *    [shape example](https://rawgit.com/allenhwkim/angularjs-google-maps/master/build/shape.html)\n */\n/* global google */\n(function() {\n  'use strict';\n\n  var getShape = function(options, events) {\n    var shape;\n\n    var shapeName = options.name;\n    delete options.name;  //remove name bcoz it's not for options\n    void 0;\n\n    /**\n     * set options\n     */\n    switch(shapeName) {\n      case \"circle\":\n        if (!(options.center instanceof google.maps.LatLng)) {\n          options.center = new google.maps.LatLng(0,0);\n        } \n        shape = new google.maps.Circle(options);\n        break;\n      case \"polygon\":\n        shape = new google.maps.Polygon(options);\n        break;\n      case \"polyline\":\n        shape = new google.maps.Polyline(options);\n        break;\n      case \"rectangle\":\n        shape = new google.maps.Rectangle(options);\n        break;\n      case \"groundOverlay\":\n      case \"image\":\n        var url = options.url;\n        var opts = {opacity: options.opacity, clickable: options.clickable, id:options.id};\n        shape = new google.maps.GroundOverlay(url, options.bounds, opts);\n        break;\n    }\n\n    /**\n     * set events\n     */\n    for (var eventName in events) {\n      if (events[eventName]) {\n        google.maps.event.addListener(shape, eventName, events[eventName]);\n      }\n    }\n    return shape;\n  };\n\n  var shape = function(Attr2MapOptions, $parse, NgMap) {\n    var parser = Attr2MapOptions;\n\n    var linkFunc = function(scope, element, attrs, mapController) {\n      mapController = mapController[0]||mapController[1];\n\n      var orgAttrs = parser.orgAttributes(element);\n      var filtered = parser.filter(attrs);\n      var shapeOptions = parser.getOptions(filtered, {scope: scope});\n      var shapeEvents = parser.getEvents(scope, filtered);\n\n      var address, shapeType;\n      shapeType = shapeOptions.name;\n      if (!(shapeOptions.center instanceof google.maps.LatLng)) {\n        address = shapeOptions.center;\n      }\n      var shape = getShape(shapeOptions, shapeEvents);\n      mapController.addObject('shapes', shape);\n\n      if (address && shapeType == 'circle') {\n        NgMap.getGeoLocation(address).then(function(latlng) {\n          shape.setCenter(latlng);\n          shape.centered && shape.map.setCenter(latlng);\n          var geoCallback = attrs.geoCallback;\n          geoCallback && $parse(geoCallback)(scope);\n        });\n      }\n\n      //set observers\n      mapController.observeAttrSetObj(orgAttrs, attrs, shape);\n      element.bind('$destroy', function() {\n        mapController.deleteObject('shapes', shape);\n      });\n    };\n\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n      link: linkFunc\n     }; // return\n  };\n  shape.$inject = ['Attr2MapOptions', '$parse', 'NgMap'];\n\n  angular.module('ngMap').directive('shape', shape);\n\n})();\n\n/**\n * @ngdoc directive\n * @name streetview-panorama\n * @param Attr2MapOptions {service} convert html attribute to Google map api options\n * @description\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @attr container Optional, id or css selector, if given, streetview will be in the given html element\n * @attr {String} &lt;StreetViewPanoramaOption>\n *   [Any Google StreetViewPanorama options](https://developers.google.com/maps/documentation/javascript/reference?csw=1#StreetViewPanoramaOptions)\n * @attr {String} &lt;StreetViewPanoramaEvent>\n *   [Any Google StreetViewPanorama events](https://developers.google.com/maps/documentation/javascript/reference#StreetViewPanorama)\n *\n * @example\n *   <map zoom=\"11\" center=\"[40.688738,-74.043871]\" >\n *     <street-view-panorama\n *       click-to-go=\"true\"\n *       disable-default-ui=\"true\"\n *       disable-double-click-zoom=\"true\"\n *       enable-close-button=\"true\"\n *       pano=\"my-pano\"\n *       position=\"40.688738,-74.043871\"\n *       pov=\"{heading:0, pitch: 90}\"\n *       scrollwheel=\"false\"\n *       visible=\"true\">\n *     </street-view-panorama>\n *   </map>\n */\n/* global google, document */\n(function() {\n  'use strict';\n\n  var streetViewPanorama = function(Attr2MapOptions, NgMap) {\n    var parser = Attr2MapOptions;\n\n    var getStreetViewPanorama = function(map, options, events) {\n      var svp, container;\n      if (options.container) {\n        container = document.getElementById(options.container);\n        container = container || document.querySelector(options.container);\n      }\n      if (container) {\n        svp = new google.maps.StreetViewPanorama(container, options);\n      } else {\n        svp = map.getStreetView();\n        svp.setOptions(options);\n      }\n\n      for (var eventName in events) {\n        eventName &&\n          google.maps.event.addListener(svp, eventName, events[eventName]);\n      }\n      return svp;\n    };\n\n    var linkFunc = function(scope, element, attrs) {\n      var filtered = parser.filter(attrs);\n      var options = parser.getOptions(filtered, {scope: scope});\n      var controlOptions = parser.getControlOptions(filtered);\n      var svpOptions = angular.extend(options, controlOptions);\n\n      var svpEvents = parser.getEvents(scope, filtered);\n      void 0;\n\n      NgMap.getMap().then(function(map) {\n        var svp = getStreetViewPanorama(map, svpOptions, svpEvents);\n\n        map.setStreetView(svp);\n        (!svp.getPosition()) && svp.setPosition(map.getCenter());\n        google.maps.event.addListener(svp, 'position_changed', function() {\n          if (svp.getPosition() !== map.getCenter()) {\n            map.setCenter(svp.getPosition());\n          }\n        });\n        //needed for geo-callback\n        var listener =\n          google.maps.event.addListener(map, 'center_changed', function() {\n            svp.setPosition(map.getCenter());\n            google.maps.event.removeListener(listener);\n          });\n      });\n\n    }; //link\n\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n      link: linkFunc\n    };\n\n  };\n  streetViewPanorama.$inject = ['Attr2MapOptions', 'NgMap'];\n\n  angular.module('ngMap').directive('streetViewPanorama', streetViewPanorama);\n})();\n\n/**\n * @ngdoc directive\n * @name traffic-layer\n * @param Attr2MapOptions {service} convert html attribute to Google map api options\n * @description\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example:\n *\n *   <map zoom=\"13\" center=\"34.04924594193164, -118.24104309082031\">\n *     <traffic-layer></traffic-layer>\n *    </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('trafficLayer', [\n    'Attr2MapOptions', function(Attr2MapOptions) {\n    var parser = Attr2MapOptions;\n\n    var getLayer = function(options, events) {\n      var layer = new google.maps.TrafficLayer(options);\n      for (var eventName in events) {\n        google.maps.event.addListener(layer, eventName, events[eventName]);\n      }\n      return layer;\n    };\n\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n\n      link: function(scope, element, attrs, mapController) {\n        mapController = mapController[0]||mapController[1];\n\n        var orgAttrs = parser.orgAttributes(element);\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered, {scope: scope});\n        var events = parser.getEvents(scope, filtered);\n        void 0;\n\n        var layer = getLayer(options, events);\n        mapController.addObject('trafficLayers', layer);\n        mapController.observeAttrSetObj(orgAttrs, attrs, layer);  //observers\n        element.bind('$destroy', function() {\n          mapController.deleteObject('trafficLayers', layer);\n        });\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc directive\n * @name transit-layer\n * @param Attr2MapOptions {service} convert html attribute to Google map api options\n * @description\n *   Requires:  map directive\n *   Restrict To:  Element\n *\n * @example\n * Example:\n *\n *  <map zoom=\"13\" center=\"34.04924594193164, -118.24104309082031\">\n *    <transit-layer></transit-layer>\n *  </map>\n */\n(function() {\n  'use strict';\n\n  angular.module('ngMap').directive('transitLayer', [\n    'Attr2MapOptions', function(Attr2MapOptions) {\n    var parser = Attr2MapOptions;\n\n    var getLayer = function(options, events) {\n      var layer = new google.maps.TransitLayer(options);\n      for (var eventName in events) {\n        google.maps.event.addListener(layer, eventName, events[eventName]);\n      }\n      return layer;\n    };\n\n    return {\n      restrict: 'E',\n      require: ['?^map','?^ngMap'],\n\n      link: function(scope, element, attrs, mapController) {\n        mapController = mapController[0]||mapController[1];\n\n        var orgAttrs = parser.orgAttributes(element);\n        var filtered = parser.filter(attrs);\n        var options = parser.getOptions(filtered, {scope: scope});\n        var events = parser.getEvents(scope, filtered);\n        void 0;\n\n        var layer = getLayer(options, events);\n        mapController.addObject('transitLayers', layer);\n        mapController.observeAttrSetObj(orgAttrs, attrs, layer);  //observers\n        element.bind('$destroy', function() {\n          mapController.deleteObject('transitLayers', layer);\n        });\n      }\n     }; // return\n  }]);\n})();\n\n/**\n * @ngdoc filter\n * @name camel-case\n * @description\n *   Converts string to camel cased\n */\n(function() {\n  'use strict';\n\n  var SPECIAL_CHARS_REGEXP = /([\\:\\-\\_]+(.))/g;\n  var MOZ_HACK_REGEXP = /^moz([A-Z])/;\n\n  var camelCaseFilter = function() {\n    return function(name) {\n      return name.\n        replace(SPECIAL_CHARS_REGEXP,\n          function(_, separator, letter, offset) {\n            return offset ? letter.toUpperCase() : letter;\n        }).\n        replace(MOZ_HACK_REGEXP, 'Moz$1');\n    };\n  };\n\n  angular.module('ngMap').filter('camelCase', camelCaseFilter);\n})();\n\n/**\n * @ngdoc filter\n * @name escape-regex\n * @description\n *   Escapes all regex special characters in a string\n */\n(function() {\n  'use strict';\n\n\n\n  var escapeRegexpFilter = function() {\n    return function(string) {\n\t\t\treturn string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n\t\t};\n  };\n\n  angular.module('ngMap').filter('escapeRegexp', escapeRegexpFilter);\n})();\n\n/**\n * @ngdoc filter\n * @name jsonize\n * @description\n *   Converts json-like string to json string\n */\n(function() {\n  'use strict';\n\n  var jsonizeFilter = function() {\n    return function(str) {\n      try {       // if parsable already, return as it is\n        JSON.parse(str);\n        return str;\n      } catch(e) { // if not parsable, change little\n        return str\n          // wrap keys without quote with valid double quote\n          .replace(/([\\$\\w]+)\\s*:/g,\n            function(_, $1) {\n              return '\"'+$1+'\":';\n            }\n          )\n          // replacing single quote wrapped ones to double quote\n          .replace(/'([^']+)'/g,\n            function(_, $1) {\n              return '\"'+$1+'\"';\n            }\n          )\n          .replace(/''/g, '\"\"');\n      }\n    };\n  };\n\n  angular.module('ngMap').filter('jsonize', jsonizeFilter);\n})();\n\n/**\n * @ngdoc service\n * @name Attr2MapOptions\n * @description\n *   Converts tag attributes to options used by google api v3 objects\n */\n/* global google */\n(function() {\n  'use strict';\n\n  //i.e. \"2015-08-12T06:12:40.858Z\"\n  var isoDateRE =\n    /^(\\d{4}\\-\\d\\d\\-\\d\\d([tT][\\d:\\.]*)?)([zZ]|([+\\-])(\\d\\d):?(\\d\\d))?$/;\n\n  var Attr2MapOptions = function(\n      $parse, $timeout, $log, $interpolate, NavigatorGeolocation, GeoCoder,\n      camelCaseFilter, jsonizeFilter, escapeRegExp\n    ) {\n\n    var exprStartSymbol = $interpolate.startSymbol();\n    var exprEndSymbol = $interpolate.endSymbol();\n\n    /**\n     * Returns the attributes of an element as hash\n     * @memberof Attr2MapOptions\n     * @param {HTMLElement} el html element\n     * @returns {Hash} attributes\n     */\n    var orgAttributes = function(el) {\n      (el.length > 0) && (el = el[0]);\n      var orgAttributes = {};\n      for (var i=0; i<el.attributes.length; i++) {\n        var attr = el.attributes[i];\n        orgAttributes[attr.name] = attr.value;\n      }\n      return orgAttributes;\n    };\n\n    var getJSON = function(input) {\n      var re =/^[\\+\\-]?[0-9\\.]+,[ ]*\\ ?[\\+\\-]?[0-9\\.]+$/; //lat,lng\n      if (input.match(re)) {\n        input = \"[\"+input+\"]\";\n      }\n      return JSON.parse(jsonizeFilter(input));\n    };\n    \n    var getLatLng = function(input) {\n      var output = input;\n      if (input[0].constructor == Array) { \n        if ((input[0][0].constructor == Array && input[0][0].length == 2) || input[0][0].constructor == Object) {\n            var preoutput;\n            var outputArray = [];\n            for (var i = 0; i < input.length; i++) {\n                preoutput = input[i].map(function(el){\n                    return new google.maps.LatLng(el[0], el[1]);\n                });\n                outputArray.push(preoutput);\n            }\n            output = outputArray;\n        } else {\n            output = input.map(function(el) {\n                return new google.maps.LatLng(el[0], el[1]);\n            });\n        }\n      } else if (!isNaN(parseFloat(input[0])) && isFinite(input[0])) {\n        output = new google.maps.LatLng(output[0], output[1]);\n      }\n      return output;\n    };\n\n    var toOptionValue = function(input, options) {\n      var output;\n      try { // 1. Number?\n        output = getNumber(input);\n      } catch(err) {\n        try { // 2. JSON?\n          var output = getJSON(input);\n          if (output instanceof Array) {\n            if (output[0].constructor == Object) {\n              output = output;\n            } else if (output[0] instanceof Array) {\n              if (output[0][0].constructor == Object) {\n                output = output;\n              } else {\n                output = getLatLng(output);\n              }\n            } else {\n                output = getLatLng(output);\n            }\n          }\n          // JSON is an object (not array or null)\n          else if (output === Object(output)) {\n            // check for nested hashes and convert to Google API options\n            var newOptions = options;\n            newOptions.doNotConverStringToNumber = true;\n            output = getOptions(output, newOptions);\n          }\n        } catch(err2) {\n          // 3. Google Map Object function Expression. i.e. LatLng(80,-49)\n          if (input.match(/^[A-Z][a-zA-Z0-9]+\\(.*\\)$/)) {\n            try {\n              var exp = \"new google.maps.\"+input;\n              output = eval(exp); /* jshint ignore:line */\n            } catch(e) {\n              output = input;\n            }\n          // 4. Google Map Object constant Expression. i.e. MayTypeId.HYBRID\n          } else if (input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/)) {\n            try {\n              var matches = input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/);\n              output = google.maps[matches[1]][matches[2]];\n            } catch(e) {\n              output = input;\n            }\n          // 5. Google Map Object constant Expression. i.e. HYBRID\n          } else if (input.match(/^[A-Z]+$/)) {\n            try {\n              var capitalizedKey = options.key.charAt(0).toUpperCase() +\n                options.key.slice(1);\n              if (options.key.match(/temperatureUnit|windSpeedUnit|labelColor/)) {\n                capitalizedKey = capitalizedKey.replace(/s$/,\"\");\n                output = google.maps.weather[capitalizedKey][input];\n              } else {\n                output = google.maps[capitalizedKey][input];\n              }\n            } catch(e) {\n              output = input;\n            }\n          // 6. Date Object as ISO String\n          } else if (input.match(isoDateRE)) {\n            try {\n              output = new Date(input);\n            } catch(e) {\n              output = input;\n            }\n          // 7. evaluate dynamically bound values\n        } else if (input.match(new RegExp('^' + escapeRegExp(exprStartSymbol))) && options.scope) {\n            try {\n              var expr = input.replace(new RegExp(escapeRegExp(exprStartSymbol)),'').replace(new RegExp(escapeRegExp(exprEndSymbol), 'g'),'');\n              output = options.scope.$eval(expr);\n            } catch (err) {\n              output = input;\n            }\n          } else {\n            output = input;\n          }\n        } // catch(err2)\n      } // catch(err)\n\n      // convert output more for center and position\n      if (\n        (options.key == 'center' || options.key == 'position') &&\n        output instanceof Array\n      ) {\n        output = new google.maps.LatLng(output[0], output[1]);\n      }\n\n      // convert output more for shape bounds\n      if (options.key == 'bounds' && output instanceof Array) {\n        output = new google.maps.LatLngBounds(output[0], output[1]);\n      }\n\n      // convert output more for shape icons\n      if (options.key == 'icons' && output instanceof Array) {\n\n        for (var i=0; i<output.length; i++) {\n          var el = output[i];\n          if (el.icon.path.match(/^[A-Z_]+$/)) {\n            el.icon.path =  google.maps.SymbolPath[el.icon.path];\n          }\n        }\n      }\n\n      // convert output more for marker icon\n      if (options.key == 'icon' && output instanceof Object) {\n        if ((\"\"+output.path).match(/^[A-Z_]+$/)) {\n          output.path = google.maps.SymbolPath[output.path];\n        }\n        for (var key in output) { //jshint ignore:line\n          var arr = output[key];\n          if (key == \"anchor\" || key == \"origin\" || key == \"labelOrigin\") {\n            output[key] = new google.maps.Point(arr[0], arr[1]);\n          } else if (key == \"size\" || key == \"scaledSize\") {\n            output[key] = new google.maps.Size(arr[0], arr[1]);\n          }\n        }\n      }\n\n      return output;\n    };\n\n    var getAttrsToObserve = function(attrs) {\n      var attrsToObserve = [];\n      var exprRegExp = new RegExp(escapeRegExp(exprStartSymbol) + '.*' + escapeRegExp(exprEndSymbol), 'g');\n\n      if (!attrs.noWatcher) {\n        for (var attrName in attrs) { //jshint ignore:line\n          var attrValue = attrs[attrName];\n          if (attrValue && attrValue.match(exprRegExp)) { // if attr value is {{..}}\n            attrsToObserve.push(camelCaseFilter(attrName));\n          }\n        }\n      }\n\n      return attrsToObserve;\n    };\n\n    /**\n     * filters attributes by skipping angularjs methods $.. $$..\n     * @memberof Attr2MapOptions\n     * @param {Hash} attrs tag attributes\n     * @returns {Hash} filterd attributes\n     */\n    var filter = function(attrs) {\n      var options = {};\n      for(var key in attrs) {\n        if (key.match(/^\\$/) || key.match(/^ng[A-Z]/)) {\n          void(0);\n        } else {\n          options[key] = attrs[key];\n        }\n      }\n      return options;\n    };\n\n    /**\n     * converts attributes hash to Google Maps API v3 options\n     * ```\n     *  . converts numbers to number\n     *  . converts class-like string to google maps instance\n     *    i.e. `LatLng(1,1)` to `new google.maps.LatLng(1,1)`\n     *  . converts constant-like string to google maps constant\n     *    i.e. `MapTypeId.HYBRID` to `google.maps.MapTypeId.HYBRID`\n     *    i.e. `HYBRID\"` to `google.maps.MapTypeId.HYBRID`\n     * ```\n     * @memberof Attr2MapOptions\n     * @param {Hash} attrs tag attributes\n     * @param {Hash} options\n     * @returns {Hash} options converted attributess\n     */\n    var getOptions = function(attrs, params) {\n      params = params || {};\n      var options = {};\n      for(var key in attrs) {\n        if (attrs[key] || attrs[key] === 0) {\n          if (key.match(/^on[A-Z]/)) { //skip events, i.e. on-click\n            continue;\n          } else if (key.match(/ControlOptions$/)) { // skip controlOptions\n            continue;\n          } else {\n            // nested conversions need to be typechecked\n            // (non-strings are fully converted)\n            if (typeof attrs[key] !== 'string') {\n              options[key] = attrs[key];\n            } else {\n              if (params.doNotConverStringToNumber &&\n                attrs[key].match(/^[0-9]+$/)\n              ) {\n                options[key] = attrs[key];\n              } else {\n                options[key] = toOptionValue(attrs[key], {key: key, scope: params.scope});\n              }\n            }\n          }\n        } // if (attrs[key])\n      } // for(var key in attrs)\n      return options;\n    };\n\n    /**\n     * converts attributes hash to scope-specific event function\n     * @memberof Attr2MapOptions\n     * @param {scope} scope angularjs scope\n     * @param {Hash} attrs tag attributes\n     * @returns {Hash} events converted events\n     */\n    var getEvents = function(scope, attrs) {\n      var events = {};\n      var toLowercaseFunc = function($1){\n        return \"_\"+$1.toLowerCase();\n      };\n      var EventFunc = function(attrValue) {\n        // funcName(argsStr)\n        var matches = attrValue.match(/([^\\(]+)\\(([^\\)]*)\\)/);\n        var funcName = matches[1];\n        var argsStr = matches[2].replace(/event[ ,]*/,'');  //remove string 'event'\n        var argsExpr = $parse(\"[\"+argsStr+\"]\"); //for perf when triggering event\n        return function(event) {\n          var args = argsExpr(scope); //get args here to pass updated model values\n          function index(obj,i) {return obj[i];}\n          var f = funcName.split('.').reduce(index, scope);\n          f && f.apply(this, [event].concat(args));\n          $timeout( function() {\n            scope.$apply();\n          });\n        };\n      };\n\n      for(var key in attrs) {\n        if (attrs[key]) {\n          if (!key.match(/^on[A-Z]/)) { //skip if not events\n            continue;\n          }\n\n          //get event name as underscored. i.e. zoom_changed\n          var eventName = key.replace(/^on/,'');\n          eventName = eventName.charAt(0).toLowerCase() + eventName.slice(1);\n          eventName = eventName.replace(/([A-Z])/g, toLowercaseFunc);\n\n          var attrValue = attrs[key];\n          events[eventName] = new EventFunc(attrValue);\n        }\n      }\n      return events;\n    };\n\n    /**\n     * control means map controls, i.e streetview, pan, etc, not a general control\n     * @memberof Attr2MapOptions\n     * @param {Hash} filtered filtered tag attributes\n     * @returns {Hash} Google Map options\n     */\n    var getControlOptions = function(filtered) {\n      var controlOptions = {};\n      if (typeof filtered != 'object') {\n        return false;\n      }\n\n      for (var attr in filtered) {\n        if (filtered[attr]) {\n          if (!attr.match(/(.*)ControlOptions$/)) {\n            continue; // if not controlOptions, skip it\n          }\n\n          //change invalid json to valid one, i.e. {foo:1} to {\"foo\": 1}\n          var orgValue = filtered[attr];\n          var newValue = orgValue.replace(/'/g, '\"');\n          newValue = newValue.replace(/([^\"]+)|(\"[^\"]+\")/g, function($0, $1, $2) {\n            if ($1) {\n              return $1.replace(/([a-zA-Z0-9]+?):/g, '\"$1\":');\n            } else {\n              return $2;\n            }\n          });\n          try {\n            var options = JSON.parse(newValue);\n            for (var key in options) { //assign the right values\n              if (options[key]) {\n                var value = options[key];\n                if (typeof value === 'string') {\n                  value = value.toUpperCase();\n                } else if (key === \"mapTypeIds\") {\n                  value = value.map( function(str) {\n                    if (str.match(/^[A-Z]+$/)) { // if constant\n                      return google.maps.MapTypeId[str.toUpperCase()];\n                    } else { // else, custom map-type\n                      return str;\n                    }\n                  });\n                }\n\n                if (key === \"style\") {\n                  var str = attr.charAt(0).toUpperCase() + attr.slice(1);\n                  var objName = str.replace(/Options$/,'')+\"Style\";\n                  options[key] = google.maps[objName][value];\n                } else if (key === \"position\") {\n                  options[key] = google.maps.ControlPosition[value];\n                } else {\n                  options[key] = value;\n                }\n              }\n            }\n            controlOptions[attr] = options;\n          } catch (e) {\n            void 0;\n          }\n        }\n      } // for\n\n      return controlOptions;\n    };\n\n    return {\n      filter: filter,\n      getOptions: getOptions,\n      getEvents: getEvents,\n      getControlOptions: getControlOptions,\n      toOptionValue: toOptionValue,\n      getAttrsToObserve: getAttrsToObserve,\n      orgAttributes: orgAttributes\n    }; // return\n\n  };\n  Attr2MapOptions.$inject= [\n    '$parse', '$timeout', '$log', '$interpolate', 'NavigatorGeolocation', 'GeoCoder',\n    'camelCaseFilter', 'jsonizeFilter', 'escapeRegexpFilter'\n  ];\n\n  angular.module('ngMap').service('Attr2MapOptions', Attr2MapOptions);\n})();\n\n/**\n * @ngdoc service\n * @name GeoCoder\n * @description\n *   Provides [defered/promise API](https://docs.angularjs.org/api/ng/service/$q)\n *   service for Google Geocoder service\n */\n(function() {\n  'use strict';\n  var $q;\n  /**\n   * @memberof GeoCoder\n   * @param {Hash} options\n   *   https://developers.google.com/maps/documentation/geocoding/#geocoding\n   * @example\n   * ```\n   *   GeoCoder.geocode({address: 'the cn tower'}).then(function(result) {\n   *     //... do something with result\n   *   });\n   * ```\n   * @returns {HttpPromise} Future object\n   */\n  var geocodeFunc = function(options) {\n    var deferred = $q.defer();\n    var geocoder = new google.maps.Geocoder();\n    geocoder.geocode(options, function (results, status) {\n      if (status == google.maps.GeocoderStatus.OK) {\n        deferred.resolve(results);\n      } else {\n        deferred.reject(status);\n      }\n    });\n    return deferred.promise;\n  };\n\n  var GeoCoder = function(_$q_) {\n    $q = _$q_;\n    return {\n      geocode : geocodeFunc\n    };\n  };\n  GeoCoder.$inject = ['$q'];\n\n  angular.module('ngMap').service('GeoCoder', GeoCoder);\n})();\n\n/**\n * @ngdoc service\n * @name GoogleMapsApi\n * @description\n *   Load Google Maps API Service\n */\n(function() {\n  'use strict';\n  var $q;\n  var $timeout;\n\n  var GoogleMapsApi = function(_$q_, _$timeout_) {\n    $q = _$q_;\n    $timeout = _$timeout_;\n\n    return {\n\n      /**\n       * Load google maps into document by creating a script tag\n       * @memberof GoogleMapsApi\n       * @param {string} mapsUrl\n       * @example\n       *   GoogleMapsApi.load(myUrl).then(function() {\n       *     console.log('google map has been loaded')\n       *   });\n       */\n      load: function (mapsUrl) {\n\n        var deferred = $q.defer();\n\n        if (window.google === undefined || window.google.maps === undefined) {\n\n          window.lazyLoadCallback = function() {\n            $timeout(function() { /* give some time to load */\n              deferred.resolve(window.google)\n            }, 100);\n          };\n\n          var scriptEl = document.createElement('script');\n          scriptEl.src = mapsUrl +\n            (mapsUrl.indexOf('?') > -1 ? '&' : '?') +\n            'callback=lazyLoadCallback';\n\n          if (!document.querySelector('script[src=\"' + scriptEl.src + '\"]')) {\n            document.body.appendChild(scriptEl);\n          }\n        } else {\n          deferred.resolve(window.google)\n        }\n\n        return deferred.promise;\n      }\n\n    }\n  }\n  GoogleMapsApi.$inject = ['$q', '$timeout'];\n\n  angular.module('ngMap').service('GoogleMapsApi', GoogleMapsApi);\n})();\n\n\n\n/**\n * @ngdoc service\n * @name NavigatorGeolocation\n * @description\n *  Provides [defered/promise API](https://docs.angularjs.org/api/ng/service/$q)\n *  service for navigator.geolocation methods\n */\n/* global google */\n(function() {\n  'use strict';\n  var $q;\n\n  /**\n   * @memberof NavigatorGeolocation\n   * @param {Object} geoLocationOptions the navigator geolocations options.\n   *  i.e. { maximumAge: 3000, timeout: 5000, enableHighAccuracy: true }.\n   *  If none specified, { timeout: 5000 }. \n   *  If timeout not specified, timeout: 5000 added\n   * @param {function} success success callback function\n   * @param {function} failure failure callback function\n   * @example\n   * ```\n   *  NavigatorGeolocation.getCurrentPosition()\n   *    .then(function(position) {\n   *      var lat = position.coords.latitude, lng = position.coords.longitude;\n   *      .. do something lat and lng\n   *    });\n   * ```\n   * @returns {HttpPromise} Future object\n   */\n  var getCurrentPosition = function(geoLocationOptions) {\n    var deferred = $q.defer();\n    if (navigator.geolocation) {\n\n      if (geoLocationOptions === undefined) {\n        geoLocationOptions = { timeout: 5000 };\n      }\n      else if (geoLocationOptions.timeout === undefined) {\n        geoLocationOptions.timeout = 5000;\n      }\n\n      navigator.geolocation.getCurrentPosition(\n        function(position) {\n          deferred.resolve(position);\n        }, function(evt) {\n          void 0;\n          deferred.reject(evt);\n        },\n        geoLocationOptions\n      );\n    } else {\n      deferred.reject(\"Browser Geolocation service failed.\");\n    }\n    return deferred.promise;\n  };\n\n  var NavigatorGeolocation = function(_$q_) {\n    $q = _$q_;\n    return {\n      getCurrentPosition: getCurrentPosition\n    };\n  };\n  NavigatorGeolocation.$inject = ['$q'];\n\n  angular.module('ngMap').\n    service('NavigatorGeolocation', NavigatorGeolocation);\n})();\n\n/**\n * @ngdoc factory\n * @name NgMapPool\n * @description\n *   Provide map instance to avoid memory leak\n */\n(function() {\n  'use strict';\n  /**\n   * @memberof NgMapPool\n   * @desc map instance pool\n   */\n  var mapInstances = [];\n  var $window, $document, $timeout;\n\n  var add = function(el) {\n    var mapDiv = $document.createElement(\"div\");\n    mapDiv.style.width = \"100%\";\n    mapDiv.style.height = \"100%\";\n    el.appendChild(mapDiv);\n    var map = new $window.google.maps.Map(mapDiv, {});\n    mapInstances.push(map);\n    return map;\n  };\n\n  var findById = function(el, id) {\n    var notInUseMap;\n    for (var i=0; i<mapInstances.length; i++) {\n      var map = mapInstances[i];\n      if (map.id == id && !map.inUse) {\n        var mapDiv = map.getDiv();\n        el.appendChild(mapDiv);\n        notInUseMap = map;\n        break;\n      }\n    }\n    return notInUseMap;\n  };\n\n  var findUnused = function(el) { //jshint ignore:line\n    var notInUseMap;\n    for (var i=0; i<mapInstances.length; i++) {\n      var map = mapInstances[i];\n      if (map.id) {\n        continue;\n      }\n      if (!map.inUse) {\n        var mapDiv = map.getDiv();\n        el.appendChild(mapDiv);\n        notInUseMap = map;\n        break;\n      }\n    }\n    return notInUseMap;\n  };\n\n  /**\n   * @memberof NgMapPool\n   * @function getMapInstance\n   * @param {HtmlElement} el map container element\n   * @return map instance for the given element\n   */\n  var getMapInstance = function(el) {\n    var map = findById(el, el.id) || findUnused(el);\n    if (!map) {\n      map = add(el);\n    } else {\n      /* firing map idle event, which is used by map controller */\n      $timeout(function() {\n        google.maps.event.trigger(map, 'idle');\n      }, 100);\n    }\n    map.inUse = true;\n    return map;\n  };\n\n  /**\n   * @memberof NgMapPool\n   * @function returnMapInstance\n   * @param {Map} an instance of google.maps.Map\n   * @desc sets the flag inUse of the given map instance to false, so that it \n   * can be reused later\n   */\n  var returnMapInstance = function(map) {\n    map.inUse = false;\n  };\n  \n  /**\n   * @memberof NgMapPool\n   * @function resetMapInstances\n   * @desc resets mapInstance array\n   */\n  var resetMapInstances = function() {\n    for(var i = 0;i < mapInstances.length;i++) {\n        mapInstances[i] = null;\n    }\n    mapInstances = [];\n  };\n  \n  /**\n   * @memberof NgMapPool\n   * @function deleteMapInstance\n   * @desc delete a mapInstance\n   */\n  var deleteMapInstance= function(mapId) {\n\t  for( var i=0; i<mapInstances.length; i++ ) {\n\t\t  if( (mapInstances[i] !== null) && (mapInstances[i].id == mapId)) {\n\t\t\t  mapInstances[i]= null;\n\t\t\t  mapInstances.splice( i, 1 );\n\t\t  }\n\t  }\n  };\n\n  var NgMapPool = function(_$document_, _$window_, _$timeout_) {\n    $document = _$document_[0], $window = _$window_, $timeout = _$timeout_;\n\n    return {\n\t  mapInstances: mapInstances,\n      resetMapInstances: resetMapInstances,\n      getMapInstance: getMapInstance,\n      returnMapInstance: returnMapInstance,\n      deleteMapInstance: deleteMapInstance\n    };\n  };\n\n  NgMapPool.$inject = [ '$document', '$window', '$timeout'];\n\n  angular.module('ngMap').factory('NgMapPool', NgMapPool);\n\n})();\n\n/**\n * @ngdoc provider\n * @name NgMap\n * @description\n *  common utility service for ng-map\n */\n(function() {\n  'use strict';\n  var $window, $document, $q;\n  var NavigatorGeolocation, Attr2MapOptions, GeoCoder, camelCaseFilter, NgMapPool;\n\n  var mapControllers = {};\n\n  var getStyle = function(el, styleProp) {\n    var y;\n    if (el.currentStyle) {\n      y = el.currentStyle[styleProp];\n    } else if ($window.getComputedStyle) {\n      y = $document.defaultView.\n        getComputedStyle(el, null).\n        getPropertyValue(styleProp);\n    }\n    return y;\n  };\n\n  /**\n   * @memberof NgMap\n   * @function initMap\n   * @param id optional, id of the map. default 0\n   */\n  var initMap = function(id) {\n    var ctrl = mapControllers[id || 0];\n    if (!(ctrl.map instanceof google.maps.Map)) {\n      ctrl.initializeMap();\n      return ctrl.map;\n    } else {\n      void 0;\n    }\n  };\n\n  /**\n   * @memberof NgMap\n   * @function getMap\n   * @param {String} optional, id e.g., 'foo'\n   * @returns promise\n   */\n  var getMap = function(id, options) {\n    options = options || {};\n    id = typeof id === 'object' ? id.id : id;\n\n    var deferred = $q.defer();\n    var timeout = options.timeout || 10000;\n\n    function waitForMap(timeElapsed){\n      var keys = Object.keys(mapControllers);\n      var theFirstController = mapControllers[keys[0]];\n      if(id && mapControllers[id]){\n        deferred.resolve(mapControllers[id].map);\n      } else if (!id && theFirstController && theFirstController.map) {\n        deferred.resolve(theFirstController.map);\n      } else if (timeElapsed > timeout) {\n        deferred.reject('could not find map');\n      } else {\n        $window.setTimeout( function(){\n          waitForMap(timeElapsed+100);\n        }, 100);\n      }\n    }\n    waitForMap(0);\n\n    return deferred.promise;\n  };\n\n  /**\n   * @memberof NgMap\n   * @function addMap\n   * @param mapController {__MapContoller} a map controller\n   * @returns promise\n   */\n  var addMap = function(mapCtrl) {\n    if (mapCtrl.map) {\n      var len = Object.keys(mapControllers).length;\n      mapControllers[mapCtrl.map.id || len] = mapCtrl;\n    }\n  };\n\n  /**\n   * @memberof NgMap\n   * @function deleteMap\n   * @param mapController {__MapContoller} a map controller\n   */\n  var deleteMap = function(mapCtrl) {\n    var len = Object.keys(mapControllers).length - 1;\n    var mapId = mapCtrl.map.id || len;\n    if (mapCtrl.map) {\n      for (var eventName in mapCtrl.eventListeners) {\n        void 0;\n        var listener = mapCtrl.eventListeners[eventName];\n        google.maps.event.removeListener(listener);\n      }\n      if (mapCtrl.map.controls) {\n        mapCtrl.map.controls.forEach(function(ctrl) {\n          ctrl.clear();\n        });\n      }\n    }\n\n    //Remove Heatmap Layers\n    if (mapCtrl.map.heatmapLayers) {\n      Object.keys(mapCtrl.map.heatmapLayers).forEach(function (layer) {\n        mapCtrl.deleteObject('heatmapLayers', mapCtrl.map.heatmapLayers[layer]);\n      });\n    }\n\n    NgMapPool.deleteMapInstance(mapId);\n\n    delete mapControllers[mapId];\n  };\n\n  /**\n   * @memberof NgMap\n   * @function getGeoLocation\n   * @param {String} address\n   * @param {Hash} options geo options\n   * @returns promise\n   */\n  var getGeoLocation = function(string, options) {\n    var deferred = $q.defer();\n    if (!string || string.match(/^current/i)) { // current location\n      NavigatorGeolocation.getCurrentPosition(options).then(\n        function(position) {\n          var lat = position.coords.latitude;\n          var lng = position.coords.longitude;\n          var latLng = new google.maps.LatLng(lat,lng);\n          deferred.resolve(latLng);\n        },\n        function(error) {\n          deferred.reject(error);\n        }\n      );\n    } else {\n      GeoCoder.geocode({address: string}).then(\n        function(results) {\n          deferred.resolve(results[0].geometry.location);\n        },\n        function(error) {\n          deferred.reject(error);\n        }\n      );\n      // var geocoder = new google.maps.Geocoder();\n      // geocoder.geocode(options, function (results, status) {\n      //   if (status == google.maps.GeocoderStatus.OK) {\n      //     deferred.resolve(results);\n      //   } else {\n      //     deferred.reject(status);\n      //   }\n      // });\n    }\n\n    return deferred.promise;\n  };\n\n  /**\n   * @memberof NgMap\n   * @function observeAndSet\n   * @param {String} attrName attribute name\n   * @param {Object} object A Google maps object to be changed\n   * @returns attribue observe function\n   */\n  var observeAndSet = function(attrName, object) {\n    void 0;\n    return function(val) {\n      if (val) {\n        var setMethod = camelCaseFilter('set-'+attrName);\n        var optionValue = Attr2MapOptions.toOptionValue(val, {key: attrName});\n        if (object[setMethod]) { //if set method does exist\n          void 0;\n          /* if an location is being observed */\n          if (attrName.match(/center|position/) &&\n            typeof optionValue == 'string') {\n            getGeoLocation(optionValue).then(function(latlng) {\n              object[setMethod](latlng);\n            });\n          } else {\n            object[setMethod](optionValue);\n          }\n        }\n      }\n    };\n  };\n\n  /**\n   * @memberof NgMap\n   * @function setStyle\n   * @param {HtmlElement} map contriner element\n   * @desc set display, width, height of map container element\n   */\n  var setStyle = function(el) {\n    //if style is not given to the map element, set display and height\n    var defaultStyle = el.getAttribute('default-style');\n    if (defaultStyle == \"true\") {\n      el.style.display = 'block';\n      el.style.height = '300px';\n    } else {\n      if (getStyle(el, 'display') != \"block\") {\n        el.style.display = 'block';\n      }\n      if (getStyle(el, 'height').match(/^(0|auto)/)) {\n        el.style.height = '300px';\n      }\n    }\n  };\n\n  angular.module('ngMap').provider('NgMap', function() {\n    var defaultOptions = {};\n\n    /**\n     * @memberof NgMap\n     * @function setDefaultOptions\n     * @param {Hash} options\n     * @example\n     *  app.config(function(NgMapProvider) {\n     *    NgMapProvider.setDefaultOptions({\n     *      marker: {\n     *        optimized: false\n     *      }\n     *    });\n     *  });\n     */\n    this.setDefaultOptions = function(options) {\n      defaultOptions = options;\n    };\n\n    var NgMap = function(\n        _$window_, _$document_, _$q_,\n        _NavigatorGeolocation_, _Attr2MapOptions_,\n        _GeoCoder_, _camelCaseFilter_, _NgMapPool_\n      ) {\n      $window = _$window_;\n      $document = _$document_[0];\n      $q = _$q_;\n      NavigatorGeolocation = _NavigatorGeolocation_;\n      Attr2MapOptions = _Attr2MapOptions_;\n      GeoCoder = _GeoCoder_;\n      camelCaseFilter = _camelCaseFilter_;\n      NgMapPool = _NgMapPool_;\n\n      return {\n        defaultOptions: defaultOptions,\n        addMap: addMap,\n        deleteMap: deleteMap,\n        getMap: getMap,\n        initMap: initMap,\n        setStyle: setStyle,\n        getGeoLocation: getGeoLocation,\n        observeAndSet: observeAndSet\n      };\n    };\n    NgMap.$inject = [\n      '$window', '$document', '$q',\n      'NavigatorGeolocation', 'Attr2MapOptions',\n      'GeoCoder', 'camelCaseFilter', 'NgMapPool'\n    ];\n\n    this.$get = NgMap;\n  });\n})();\n\n/**\n * @ngdoc service\n * @name StreetView\n * @description\n *  Provides [defered/promise API](https://docs.angularjs.org/api/ng/service/$q)\n *  service for [Google StreetViewService]\n *  (https://developers.google.com/maps/documentation/javascript/streetview)\n */\n(function() {\n  'use strict';\n  var $q;\n\n  /**\n   * Retrieves panorama id from the given map (and or position)\n   * @memberof StreetView\n   * @param {map} map Google map instance\n   * @param {LatLng} latlng Google LatLng instance\n   *   default: the center of the map\n   * @example\n   *   StreetView.getPanorama(map).then(function(panoId) {\n   *     $scope.panoId = panoId;\n   *   });\n   * @returns {HttpPromise} Future object\n   */\n  var getPanorama = function(map, latlng) {\n    latlng = latlng || map.getCenter();\n    var deferred = $q.defer();\n    var svs = new google.maps.StreetViewService();\n    svs.getPanoramaByLocation( (latlng||map.getCenter), 100,\n      function (data, status) {\n        // if streetView available\n        if (status === google.maps.StreetViewStatus.OK) {\n          deferred.resolve(data.location.pano);\n        } else {\n          // no street view available in this range, or some error occurred\n          deferred.resolve(false);\n          //deferred.reject('Geocoder failed due to: '+ status);\n        }\n      }\n    );\n    return deferred.promise;\n  };\n\n  /**\n   * Set panorama view on the given map with the panorama id\n   * @memberof StreetView\n   * @param {map} map Google map instance\n   * @param {String} panoId Panorama id fro getPanorama method\n   * @example\n   *   StreetView.setPanorama(map, panoId);\n   */\n  var setPanorama = function(map, panoId) {\n    var svp = new google.maps.StreetViewPanorama(\n      map.getDiv(), {enableCloseButton: true}\n    );\n    svp.setPano(panoId);\n  };\n\n  var StreetView = function(_$q_) {\n    $q = _$q_;\n\n    return {\n      getPanorama: getPanorama,\n      setPanorama: setPanorama\n    };\n  };\n  StreetView.$inject = ['$q'];\n\n  angular.module('ngMap').service('StreetView', StreetView);\n})();\n\r\nreturn 'ngMap';\r\n}));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9uZ21hcC9idWlsZC9zY3JpcHRzL25nLW1hcC5qcz8wYWUxIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XHJcbmlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnYW5ndWxhcicpKTtcclxufSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG5kZWZpbmUoWydhbmd1bGFyJ10sIGZhY3RvcnkpO1xyXG59IGVsc2V7XHJcbmZhY3Rvcnkocm9vdC5hbmd1bGFyKTtcclxufVxyXG59KHRoaXMsIGZ1bmN0aW9uKGFuZ3VsYXIpIHtcclxuLyoqXG4gKiBBbmd1bGFySlMgR29vZ2xlIE1hcHMgVmVyLiAxLjE4LjNcbiAqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE0LCAyMDE1LCAxMDE2IEFsbGVuIEtpbVxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZlxuICogdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1NcbiAqIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUlxuICogQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSXG4gKiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICogQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuYW5ndWxhci5tb2R1bGUoJ25nTWFwJywgW10pO1xuXG4vKipcbiAqIEBuZ2RvYyBjb250cm9sbGVyXG4gKiBAbmFtZSBNYXBDb250cm9sbGVyXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICB2YXIgQXR0cjJNYXBPcHRpb25zO1xuXG4gIHZhciBfX01hcENvbnRyb2xsZXIgPSBmdW5jdGlvbihcbiAgICAgICRzY29wZSwgJGVsZW1lbnQsICRhdHRycywgJHBhcnNlLCAkaW50ZXJwb2xhdGUsIF9BdHRyMk1hcE9wdGlvbnNfLCBOZ01hcCwgTmdNYXBQb29sLCBlc2NhcGVSZWdFeHBcbiAgICApIHtcbiAgICBBdHRyMk1hcE9wdGlvbnMgPSBfQXR0cjJNYXBPcHRpb25zXztcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciBleHByU3RhcnRTeW1ib2wgPSAkaW50ZXJwb2xhdGUuc3RhcnRTeW1ib2woKTtcbiAgICB2YXIgZXhwckVuZFN5bWJvbCA9ICRpbnRlcnBvbGF0ZS5lbmRTeW1ib2woKTtcblxuICAgIHZtLm1hcE9wdGlvbnM7IC8qKiBAbWVtYmVyb2YgX19NYXBDb250cm9sbGVyICovXG4gICAgdm0ubWFwRXZlbnRzOyAgLyoqIEBtZW1iZXJvZiBfX01hcENvbnRyb2xsZXIgKi9cbiAgICB2bS5ldmVudExpc3RlbmVyczsgIC8qKiBAbWVtYmVyb2YgX19NYXBDb250cm9sbGVyICovXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gb2JqZWN0IHRvIHRoZSBjb2xsZWN0aW9uIG9mIGdyb3VwXG4gICAgICogQG1lbWJlcm9mIF9fTWFwQ29udHJvbGxlclxuICAgICAqIEBmdW5jdGlvbiBhZGRPYmplY3RcbiAgICAgKiBAcGFyYW0gZ3JvdXBOYW1lIHRoZSBuYW1lIG9mIGNvbGxlY3Rpb24gdGhhdCBvYmplY3QgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSBvYmogIGFuIG9iamVjdCB0byBhZGQgaW50byBhIGNvbGxlY3Rpb24sIGkuZS4gbWFya2VyLCBzaGFwZVxuICAgICAqL1xuICAgIHZtLmFkZE9iamVjdCA9IGZ1bmN0aW9uKGdyb3VwTmFtZSwgb2JqKSB7XG4gICAgICBpZiAodm0ubWFwKSB7XG4gICAgICAgIHZtLm1hcFtncm91cE5hbWVdID0gdm0ubWFwW2dyb3VwTmFtZV0gfHwge307XG4gICAgICAgIHZhciBsZW4gPSBPYmplY3Qua2V5cyh2bS5tYXBbZ3JvdXBOYW1lXSkubGVuZ3RoO1xuICAgICAgICB2bS5tYXBbZ3JvdXBOYW1lXVtvYmouaWQgfHwgbGVuXSA9IG9iajtcblxuICAgICAgICBpZiAodm0ubWFwIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTWFwKSB7XG4gICAgICAgICAgLy9pbmZvV2luZG93LnNldE1hcCB3b3JrcyBsaWtlIGluZm9XaW5kb3cub3BlblxuICAgICAgICAgIGlmIChncm91cE5hbWUgIT0gXCJpbmZvV2luZG93c1wiICYmIG9iai5zZXRNYXApIHtcbiAgICAgICAgICAgIG9iai5zZXRNYXAgJiYgb2JqLnNldE1hcCh2bS5tYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqLmNlbnRlcmVkICYmIG9iai5wb3NpdGlvbikge1xuICAgICAgICAgICAgdm0ubWFwLnNldENlbnRlcihvYmoucG9zaXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoZ3JvdXBOYW1lID09ICdtYXJrZXJzJykgJiYgdm0ub2JqZWN0Q2hhbmdlZCgnbWFya2VycycpO1xuICAgICAgICAgIChncm91cE5hbWUgPT0gJ2N1c3RvbU1hcmtlcnMnKSAmJiB2bS5vYmplY3RDaGFuZ2VkKCdjdXN0b21NYXJrZXJzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFuIG9iamVjdCBmcm9tIHRoZSBjb2xsZWN0aW9uIGFuZCByZW1vdmUgZnJvbSBtYXBcbiAgICAgKiBAbWVtYmVyb2YgX19NYXBDb250cm9sbGVyXG4gICAgICogQGZ1bmN0aW9uIGRlbGV0ZU9iamVjdFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ianMgdGhlIGNvbGxlY3Rpb24gb2Ygb2JqZWN0cy4gaS5lLiwgbWFwLm1hcmtlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gYmUgcmVtb3ZlZC4gaS5lLiwgbWFya2VyXG4gICAgICovXG4gICAgdm0uZGVsZXRlT2JqZWN0ID0gZnVuY3Rpb24oZ3JvdXBOYW1lLCBvYmopIHtcbiAgICAgIC8qIGRlbGV0ZSBmcm9tIGdyb3VwICovXG4gICAgICBpZiAob2JqLm1hcCkge1xuICAgICAgICB2YXIgb2JqcyA9IG9iai5tYXBbZ3JvdXBOYW1lXTtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvYmpzKSB7XG4gICAgICAgICAgaWYgKG9ianNbbmFtZV0gPT09IG9iaikge1xuICAgICAgICAgICAgdm9pZCAwO1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuY2xlYXJJbnN0YW5jZUxpc3RlbmVycyhvYmopO1xuICAgICAgICAgICAgZGVsZXRlIG9ianNbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogZGVsZXRlIGZyb20gbWFwICovXG4gICAgICAgIG9iai5tYXAgJiYgb2JqLnNldE1hcCAmJiBvYmouc2V0TWFwKG51bGwpO1xuXG4gICAgICAgIChncm91cE5hbWUgPT0gJ21hcmtlcnMnKSAmJiB2bS5vYmplY3RDaGFuZ2VkKCdtYXJrZXJzJyk7XG4gICAgICAgIChncm91cE5hbWUgPT0gJ2N1c3RvbU1hcmtlcnMnKSAmJiB2bS5vYmplY3RDaGFuZ2VkKCdjdXN0b21NYXJrZXJzJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBfX01hcENvbnRyb2xsZXJcbiAgICAgKiBAZnVuY3Rpb24gb2JzZXJ2ZUF0dHJTZXRPYmpcbiAgICAgKiBAcGFyYW0ge0hhc2h9IG9yZ0F0dHJzIGF0dHJpYnV0ZXMgYmVmb3JlIGl0cyBpbml0aWFsaXphdGlvblxuICAgICAqIEBwYXJhbSB7SGFzaH0gYXR0cnMgICAgYXR0cmlidXRlcyBhZnRlciBpdHMgaW5pdGlhbGl6YXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqICAgIG1hcCBvYmplY3QgdGhhdCBhbiBhY3Rpb24gaXMgdG8gYmUgZG9uZVxuICAgICAqIEBkZXNjcmlwdGlvbiB3YXRjaCBjaGFuZ2VzIG9mIGF0dHJpYnV0ZSB2YWx1ZXMgYW5kXG4gICAgICogZG8gYXBwcm9wcmlhdGUgYWN0aW9uIGJhc2VkIG9uIGF0dHJpYnV0ZSBuYW1lXG4gICAgICovXG4gICAgdm0ub2JzZXJ2ZUF0dHJTZXRPYmogPSBmdW5jdGlvbihvcmdBdHRycywgYXR0cnMsIG9iaikge1xuICAgICAgaWYgKGF0dHJzLm5vV2F0Y2hlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgYXR0cnNUb09ic2VydmUgPSBBdHRyMk1hcE9wdGlvbnMuZ2V0QXR0cnNUb09ic2VydmUob3JnQXR0cnMpO1xuICAgICAgZm9yICh2YXIgaT0wOyBpPGF0dHJzVG9PYnNlcnZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhdHRyTmFtZSA9IGF0dHJzVG9PYnNlcnZlW2ldO1xuICAgICAgICBhdHRycy4kb2JzZXJ2ZShhdHRyTmFtZSwgTmdNYXAub2JzZXJ2ZUFuZFNldChhdHRyTmFtZSwgb2JqKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBfX01hcENvbnRyb2xsZXJcbiAgICAgKiBAZnVuY3Rpb24gem9vbVRvSW5jbHVkZU1hcmtlcnNcbiAgICAgKi9cbiAgICB2bS56b29tVG9JbmNsdWRlTWFya2VycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gT25seSBmaXQgdG8gYm91bmRzIGlmIHdlIGhhdmUgYW55IG1hcmtlcnNcbiAgICAgIC8vIG9iamVjdC5rZXlzIGlzIHN1cHBvcnRlZCBpbiBhbGwgbWFqb3IgYnJvd3NlcnMgKElFOSspXG4gICAgICBpZiAoKHZtLm1hcC5tYXJrZXJzICE9IG51bGwgJiYgT2JqZWN0LmtleXModm0ubWFwLm1hcmtlcnMpLmxlbmd0aCA+IDApIHx8ICh2bS5tYXAuY3VzdG9tTWFya2VycyAhPSBudWxsICYmIE9iamVjdC5rZXlzKHZtLm1hcC5jdXN0b21NYXJrZXJzKS5sZW5ndGggPiAwKSkge1xuICAgICAgICB2YXIgYm91bmRzID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kcygpO1xuICAgICAgICBmb3IgKHZhciBrMSBpbiB2bS5tYXAubWFya2Vycykge1xuICAgICAgICAgIGJvdW5kcy5leHRlbmQodm0ubWFwLm1hcmtlcnNbazFdLmdldFBvc2l0aW9uKCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGsyIGluIHZtLm1hcC5jdXN0b21NYXJrZXJzKSB7XG4gICAgICAgICAgYm91bmRzLmV4dGVuZCh2bS5tYXAuY3VzdG9tTWFya2Vyc1trMl0uZ2V0UG9zaXRpb24oKSk7XG4gICAgICAgIH1cbiAgICBcdCAgaWYgKHZtLm1hcE9wdGlvbnMubWF4aW11bVpvb20pIHtcbiAgICBcdFx0ICB2bS5lbmFibGVNYXhpbXVtWm9vbUNoZWNrID0gdHJ1ZTsgLy9lbmFibGUgem9vbSBjaGVjayBhZnRlciByZXNpemluZyBmb3IgbWFya2Vyc1xuICAgIFx0ICB9XG4gICAgICAgIHZtLm1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIF9fTWFwQ29udHJvbGxlclxuICAgICAqIEBmdW5jdGlvbiBvYmplY3RDaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwIG5hbWUgb2YgZ3JvdXAgZS5nLiwgbWFya2Vyc1xuICAgICAqL1xuICAgIHZtLm9iamVjdENoYW5nZWQgPSBmdW5jdGlvbihncm91cCkge1xuICAgICAgaWYgKCB2bS5tYXAgJiZcbiAgICAgICAgKGdyb3VwID09ICdtYXJrZXJzJyB8fCBncm91cCA9PSAnY3VzdG9tTWFya2VycycpICYmXG4gICAgICAgIHZtLm1hcC56b29tVG9JbmNsdWRlTWFya2VycyA9PSAnYXV0bydcbiAgICAgICkge1xuICAgICAgICB2bS56b29tVG9JbmNsdWRlTWFya2VycygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgX19NYXBDb250cm9sbGVyXG4gICAgICogQGZ1bmN0aW9uIGluaXRpYWxpemVNYXBcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgLiBpbml0aWFsaXplIEdvb2dsZSBtYXAgb24gPGRpdj4gdGFnXG4gICAgICogIC4gc2V0IG1hcCBvcHRpb25zLCBldmVudHMsIGFuZCBvYnNlcnZlcnNcbiAgICAgKiAgLiByZXNldCB6b29tIHRvIGluY2x1ZGUgYWxsIChjdXN0b20pbWFya2Vyc1xuICAgICAqL1xuICAgIHZtLmluaXRpYWxpemVNYXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXBPcHRpb25zID0gdm0ubWFwT3B0aW9ucyxcbiAgICAgICAgICBtYXBFdmVudHMgPSB2bS5tYXBFdmVudHM7XG5cbiAgICAgIHZhciBsYXp5SW5pdE1hcCA9IHZtLm1hcDsgLy9wcmVwYXJlZCBmb3IgbGF6eSBpbml0XG4gICAgICB2bS5tYXAgPSBOZ01hcFBvb2wuZ2V0TWFwSW5zdGFuY2UoJGVsZW1lbnRbMF0pO1xuICAgICAgTmdNYXAuc2V0U3R5bGUoJGVsZW1lbnRbMF0pO1xuXG4gICAgICAvLyBzZXQgb2JqZWN0cyBmb3IgbGF6eUluaXRcbiAgICAgIGlmIChsYXp5SW5pdE1hcCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZWJ1aWxkIG1hcE9wdGlvbnMgZm9yIGxhenlJbml0XG4gICAgICAgICAqIGJlY2F1c2UgYXR0cmlidXRlcyB2YWx1ZXMgbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBmaWx0ZXJlZCA9IEF0dHIyTWFwT3B0aW9ucy5maWx0ZXIoJGF0dHJzKTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBBdHRyMk1hcE9wdGlvbnMuZ2V0T3B0aW9ucyhmaWx0ZXJlZCk7XG4gICAgICAgIHZhciBjb250cm9sT3B0aW9ucyA9IEF0dHIyTWFwT3B0aW9ucy5nZXRDb250cm9sT3B0aW9ucyhmaWx0ZXJlZCk7XG4gICAgICAgIG1hcE9wdGlvbnMgPSBhbmd1bGFyLmV4dGVuZChvcHRpb25zLCBjb250cm9sT3B0aW9ucyk7XG4gICAgICAgIHZvaWQgMDtcblxuICAgICAgICBmb3IgKHZhciBncm91cCBpbiBsYXp5SW5pdE1hcCkge1xuICAgICAgICAgIHZhciBncm91cE1lbWJlcnMgPSBsYXp5SW5pdE1hcFtncm91cF07IC8vZS5nLiBtYXJrZXJzXG4gICAgICAgICAgaWYgKHR5cGVvZiBncm91cE1lbWJlcnMgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIGdyb3VwTWVtYmVycykge1xuICAgICAgICAgICAgICB2bS5hZGRPYmplY3QoZ3JvdXAsIGdyb3VwTWVtYmVyc1tpZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2bS5tYXAuc2hvd0luZm9XaW5kb3cgPSB2bS5zaG93SW5mb1dpbmRvdztcbiAgICAgICAgdm0ubWFwLmhpZGVJbmZvV2luZG93ID0gdm0uaGlkZUluZm9XaW5kb3c7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBvcHRpb25zXG4gICAgICBtYXBPcHRpb25zLnpvb20gPSBtYXBPcHRpb25zLnpvb20gfHwgMTU7XG4gICAgICB2YXIgY2VudGVyID0gbWFwT3B0aW9ucy5jZW50ZXI7XG4gICAgICB2YXIgZXhwclJlZ0V4cCA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKGV4cHJTdGFydFN5bWJvbCkgKyAnLionICsgZXNjYXBlUmVnRXhwKGV4cHJFbmRTeW1ib2wpKTtcblxuICAgICAgaWYgKCFtYXBPcHRpb25zLmNlbnRlciB8fFxuICAgICAgICAoKHR5cGVvZiBjZW50ZXIgPT09ICdzdHJpbmcnKSAmJiBjZW50ZXIubWF0Y2goZXhwclJlZ0V4cCkpXG4gICAgICApIHtcbiAgICAgICAgbWFwT3B0aW9ucy5jZW50ZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKDAsIDApO1xuICAgICAgfSBlbHNlIGlmKCAodHlwZW9mIGNlbnRlciA9PT0gJ3N0cmluZycpICYmIGNlbnRlci5tYXRjaCgvXlswLTkuLV0qLFswLTkuLV0qJC8pICl7XG4gICAgICAgIHZhciBsYXQgPSBwYXJzZUZsb2F0KGNlbnRlci5zcGxpdCgnLCcpWzBdKTtcbiAgICAgICAgdmFyIGxuZyA9IHBhcnNlRmxvYXQoY2VudGVyLnNwbGl0KCcsJylbMV0pO1xuICAgICAgICBtYXBPcHRpb25zLmNlbnRlciA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcobGF0LCBsbmcpO1xuICAgICAgfSBlbHNlIGlmICghKGNlbnRlciBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLkxhdExuZykpIHtcbiAgICAgICAgdmFyIGdlb0NlbnRlciA9IG1hcE9wdGlvbnMuY2VudGVyO1xuICAgICAgICBkZWxldGUgbWFwT3B0aW9ucy5jZW50ZXI7XG4gICAgICAgIE5nTWFwLmdldEdlb0xvY2F0aW9uKGdlb0NlbnRlciwgbWFwT3B0aW9ucy5nZW9Mb2NhdGlvbk9wdGlvbnMpLlxuICAgICAgICAgIHRoZW4oZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgdm0ubWFwLnNldENlbnRlcihsYXRsbmcpO1xuICAgICAgICAgICAgdmFyIGdlb0NhbGxiYWNrID0gbWFwT3B0aW9ucy5nZW9DYWxsYmFjaztcbiAgICAgICAgICAgIGdlb0NhbGxiYWNrICYmICRwYXJzZShnZW9DYWxsYmFjaykoJHNjb3BlKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobWFwT3B0aW9ucy5nZW9GYWxsYmFja0NlbnRlcikge1xuICAgICAgICAgICAgICB2bS5tYXAuc2V0Q2VudGVyKG1hcE9wdGlvbnMuZ2VvRmFsbGJhY2tDZW50ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdm0ubWFwLnNldE9wdGlvbnMobWFwT3B0aW9ucyk7XG5cbiAgICAgIC8vIHNldCBldmVudHNcbiAgICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBtYXBFdmVudHMpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gbWFwRXZlbnRzW2V2ZW50TmFtZV07XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHZtLm1hcCwgZXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgIHZtLmV2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBsaXN0ZW5lcjtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IG9ic2VydmVyc1xuICAgICAgdm0ub2JzZXJ2ZUF0dHJTZXRPYmoob3JnQXR0cnMsICRhdHRycywgdm0ubWFwKTtcbiAgICAgIHZtLnNpbmdsZUluZm9XaW5kb3cgPSBtYXBPcHRpb25zLnNpbmdsZUluZm9XaW5kb3c7XG5cbiAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodm0ubWFwLCAncmVzaXplJyk7XG5cbiAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyT25jZSh2bS5tYXAsIFwiaWRsZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIE5nTWFwLmFkZE1hcCh2bSk7XG4gICAgICAgIGlmIChtYXBPcHRpb25zLnpvb21Ub0luY2x1ZGVNYXJrZXJzKSB7XG4gICAgICAgICAgdm0uem9vbVRvSW5jbHVkZU1hcmtlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICAvL1RPRE86IGl0J3MgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpeS4gd2lsbCBiZSByZW1vdmVkXG4gICAgICAgICRzY29wZS5tYXAgPSB2bS5tYXA7XG4gICAgICAgICRzY29wZS4kZW1pdCgnbWFwSW5pdGlhbGl6ZWQnLCB2bS5tYXApO1xuXG4gICAgICAgIC8vY2FsbGJhY2tcbiAgICAgICAgaWYgKCRhdHRycy5tYXBJbml0aWFsaXplZCkge1xuICAgICAgICAgICRwYXJzZSgkYXR0cnMubWFwSW5pdGlhbGl6ZWQpKCRzY29wZSwge21hcDogdm0ubWFwfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG5cdCAgLy9hZGQgbWF4aW11bSB6b29tIGxpc3RlbmVycyBpZiB6b29tLXRvLWluY2x1ZGUtbWFya2VycyBhbmQgYW5kIG1heGltdW0tem9vbSBhcmUgdmFsaWQgYXR0cmlidXRlc1xuXHQgIGlmIChtYXBPcHRpb25zLnpvb21Ub0luY2x1ZGVNYXJrZXJzICYmIG1hcE9wdGlvbnMubWF4aW11bVpvb20pIHtcblx0ICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHZtLm1hcCwgJ3pvb21fY2hhbmdlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh2bS5lbmFibGVNYXhpbXVtWm9vbUNoZWNrID09IHRydWUpIHtcblx0XHRcdHZtLmVuYWJsZU1heGltdW1ab29tQ2hlY2sgPSBmYWxzZTtcblx0ICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lck9uY2Uodm0ubWFwLCAnYm91bmRzX2NoYW5nZWQnLCBmdW5jdGlvbigpIHtcblx0XHQgICAgICB2bS5tYXAuc2V0Wm9vbShNYXRoLm1pbihtYXBPcHRpb25zLm1heGltdW1ab29tLCB2bS5tYXAuZ2V0Wm9vbSgpKSk7XG5cdFx0ICAgIH0pO1xuXHQgIFx0ICB9XG5cdCAgICB9KTtcblx0ICB9XG4gICAgfTtcblxuICAgICRzY29wZS5nb29nbGUgPSBnb29nbGU7IC8vdXNlZCBieSAkc2NvcGUuZXZhbCB0byBhdm9pZCBldmFsKClcblxuICAgIC8qKlxuICAgICAqIGdldCBtYXAgb3B0aW9ucyBhbmQgZXZlbnRzXG4gICAgICovXG4gICAgdmFyIG9yZ0F0dHJzID0gQXR0cjJNYXBPcHRpb25zLm9yZ0F0dHJpYnV0ZXMoJGVsZW1lbnQpO1xuICAgIHZhciBmaWx0ZXJlZCA9IEF0dHIyTWFwT3B0aW9ucy5maWx0ZXIoJGF0dHJzKTtcbiAgICB2YXIgb3B0aW9ucyA9IEF0dHIyTWFwT3B0aW9ucy5nZXRPcHRpb25zKGZpbHRlcmVkLCB7c2NvcGU6ICRzY29wZX0pO1xuICAgIHZhciBjb250cm9sT3B0aW9ucyA9IEF0dHIyTWFwT3B0aW9ucy5nZXRDb250cm9sT3B0aW9ucyhmaWx0ZXJlZCk7XG4gICAgdmFyIG1hcE9wdGlvbnMgPSBhbmd1bGFyLmV4dGVuZChvcHRpb25zLCBjb250cm9sT3B0aW9ucyk7XG4gICAgdmFyIG1hcEV2ZW50cyA9IEF0dHIyTWFwT3B0aW9ucy5nZXRFdmVudHMoJHNjb3BlLCBmaWx0ZXJlZCk7XG4gICAgdm9pZCAwO1xuICAgIE9iamVjdC5rZXlzKG1hcEV2ZW50cykubGVuZ3RoICYmIHZvaWQgMDtcblxuICAgIHZtLm1hcE9wdGlvbnMgPSBtYXBPcHRpb25zO1xuICAgIHZtLm1hcEV2ZW50cyA9IG1hcEV2ZW50cztcbiAgICB2bS5ldmVudExpc3RlbmVycyA9IHt9O1xuXG4gICAgaWYgKG9wdGlvbnMubGF6eUluaXQpIHsgLy8gYWxsb3dzIGNvbnRyb2xsZWQgaW5pdGlhbGl6YXRpb25cbiAgICAgIC8vIHBhcnNlIGFuZ3VsYXIgZXhwcmVzc2lvbiBmb3IgZHluYW1pYyBpZHNcbiAgICAgIGlmICghISRhdHRycy5pZCAmJlxuICAgICAgXHQgIC8vIHN0YXJ0cyB3aXRoLCBhdCBwb3NpdGlvbiAwXG5cdCAgJGF0dHJzLmlkLmluZGV4T2YoZXhwclN0YXJ0U3ltYm9sLCAwKSA9PT0gMCAmJlxuXHQgIC8vIGVuZHMgd2l0aFxuXHQgICRhdHRycy5pZC5pbmRleE9mKGV4cHJFbmRTeW1ib2wsICRhdHRycy5pZC5sZW5ndGggLSBleHByRW5kU3ltYm9sLmxlbmd0aCkgIT09IC0xKSB7XG4gICAgICAgIHZhciBpZEV4cHJlc3Npb24gPSAkYXR0cnMuaWQuc2xpY2UoMiwtMik7XG4gICAgICAgIHZhciBtYXBJZCA9ICRwYXJzZShpZEV4cHJlc3Npb24pKCRzY29wZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWFwSWQgPSAkYXR0cnMuaWQ7XG4gICAgICB9XG4gICAgICB2bS5tYXAgPSB7aWQ6IG1hcElkfTsgLy9zZXQgZW1wdHksIG5vdCByZWFsLCBtYXBcbiAgICAgIE5nTWFwLmFkZE1hcCh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLmluaXRpYWxpemVNYXAoKTtcbiAgICB9XG5cbiAgICAvL1RyaWdnZXIgUmVzaXplXG4gICAgaWYob3B0aW9ucy50cmlnZ2VyUmVzaXplKSB7XG4gICAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKHZtLm1hcCwgJ3Jlc2l6ZScpO1xuICAgIH1cblxuICAgICRlbGVtZW50LmJpbmQoJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICBOZ01hcFBvb2wucmV0dXJuTWFwSW5zdGFuY2Uodm0ubWFwKTtcbiAgICAgIE5nTWFwLmRlbGV0ZU1hcCh2bSk7XG4gICAgfSk7XG4gIH07IC8vIF9fTWFwQ29udHJvbGxlclxuXG4gIF9fTWFwQ29udHJvbGxlci4kaW5qZWN0ID0gW1xuICAgICckc2NvcGUnLCAnJGVsZW1lbnQnLCAnJGF0dHJzJywgJyRwYXJzZScsICckaW50ZXJwb2xhdGUnLCAnQXR0cjJNYXBPcHRpb25zJywgJ05nTWFwJywgJ05nTWFwUG9vbCcsICdlc2NhcGVSZWdleHBGaWx0ZXInXG4gIF07XG4gIGFuZ3VsYXIubW9kdWxlKCduZ01hcCcpLmNvbnRyb2xsZXIoJ19fTWFwQ29udHJvbGxlcicsIF9fTWFwQ29udHJvbGxlcik7XG59KSgpO1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIGJpY3ljbGluZy1sYXllclxuICogQHBhcmFtIEF0dHIyT3B0aW9ucyB7c2VydmljZX1cbiAqICAgY29udmVydCBodG1sIGF0dHJpYnV0ZSB0byBHb29nbGUgbWFwIGFwaSBvcHRpb25zXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgUmVxdWlyZXM6ICBtYXAgZGlyZWN0aXZlXG4gKiAgIFJlc3RyaWN0IFRvOiAgRWxlbWVudFxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICA8bWFwIHpvb209XCIxM1wiIGNlbnRlcj1cIjM0LjA0OTI0NTk0MTkzMTY0LCAtMTE4LjI0MTA0MzA5MDgyMDMxXCI+XG4gKiAgICAgPGJpY3ljbGluZy1sYXllcj48L2JpY3ljbGluZy1sYXllcj5cbiAqICAgIDwvbWFwPlxuICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIHBhcnNlcjtcblxuICB2YXIgbGlua0Z1bmMgPSBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG1hcENvbnRyb2xsZXIpIHtcbiAgICBtYXBDb250cm9sbGVyID0gbWFwQ29udHJvbGxlclswXXx8bWFwQ29udHJvbGxlclsxXTtcbiAgICB2YXIgb3JnQXR0cnMgPSBwYXJzZXIub3JnQXR0cmlidXRlcyhlbGVtZW50KTtcbiAgICB2YXIgZmlsdGVyZWQgPSBwYXJzZXIuZmlsdGVyKGF0dHJzKTtcbiAgICB2YXIgb3B0aW9ucyA9IHBhcnNlci5nZXRPcHRpb25zKGZpbHRlcmVkLCB7c2NvcGU6IHNjb3BlfSk7XG4gICAgdmFyIGV2ZW50cyA9IHBhcnNlci5nZXRFdmVudHMoc2NvcGUsIGZpbHRlcmVkKTtcblxuICAgIHZvaWQgMDtcblxuICAgIHZhciBsYXllciA9IGdldExheWVyKG9wdGlvbnMsIGV2ZW50cyk7XG4gICAgbWFwQ29udHJvbGxlci5hZGRPYmplY3QoJ2JpY3ljbGluZ0xheWVycycsIGxheWVyKTtcbiAgICBtYXBDb250cm9sbGVyLm9ic2VydmVBdHRyU2V0T2JqKG9yZ0F0dHJzLCBhdHRycywgbGF5ZXIpOyAgLy9vYnNlcnZlcnNcbiAgICBlbGVtZW50LmJpbmQoJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICBtYXBDb250cm9sbGVyLmRlbGV0ZU9iamVjdCgnYmljeWNsaW5nTGF5ZXJzJywgbGF5ZXIpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnZXRMYXllciA9IGZ1bmN0aW9uKG9wdGlvbnMsIGV2ZW50cykge1xuICAgIHZhciBsYXllciA9IG5ldyBnb29nbGUubWFwcy5CaWN5Y2xpbmdMYXllcihvcHRpb25zKTtcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnRzKSB7XG4gICAgICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihsYXllciwgZXZlbnROYW1lLCBldmVudHNbZXZlbnROYW1lXSk7XG4gICAgfVxuICAgIHJldHVybiBsYXllcjtcbiAgfTtcblxuICB2YXIgYmljeWNsaW5nTGF5ZXI9IGZ1bmN0aW9uKEF0dHIyTWFwT3B0aW9ucykge1xuICAgIHBhcnNlciA9IEF0dHIyTWFwT3B0aW9ucztcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgIHJlcXVpcmU6IFsnP15tYXAnLCc/Xm5nTWFwJ10sXG4gICAgICBsaW5rOiBsaW5rRnVuY1xuICAgICB9O1xuICB9O1xuICBiaWN5Y2xpbmdMYXllci4kaW5qZWN0ID0gWydBdHRyMk1hcE9wdGlvbnMnXTtcblxuICBhbmd1bGFyLm1vZHVsZSgnbmdNYXAnKS5kaXJlY3RpdmUoJ2JpY3ljbGluZ0xheWVyJywgYmljeWNsaW5nTGF5ZXIpO1xufSkoKTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBjdXN0b20tY29udHJvbFxuICogQHBhcmFtIEF0dHIyT3B0aW9ucyB7c2VydmljZX0gY29udmVydCBodG1sIGF0dHJpYnV0ZSB0byBHb29nbGUgbWFwIGFwaSBvcHRpb25zXG4gKiBAcGFyYW0gJGNvbXBpbGUge3NlcnZpY2V9IEFuZ3VsYXJKUyAkY29tcGlsZSBzZXJ2aWNlXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgQnVpbGQgY3VzdG9tIGNvbnRyb2wgYW5kIHNldCB0byB0aGUgbWFwIHdpdGggcG9zaXRpb25cbiAqXG4gKiAgIFJlcXVpcmVzOiAgbWFwIGRpcmVjdGl2ZVxuICpcbiAqICAgUmVzdHJpY3QgVG86ICBFbGVtZW50XG4gKlxuICogQGF0dHIge1N0cmluZ30gcG9zaXRpb24gcG9zaXRpb24gb2YgdGhpcyBjb250cm9sXG4gKiAgICAgICAgaS5lLiBUT1BfUklHSFRcbiAqIEBhdHRyIHtOdW1iZXJ9IGluZGV4IGluZGV4IG9mIHRoZSBjb250cm9sXG4gKiBAZXhhbXBsZVxuICpcbiAqIEV4YW1wbGU6XG4gKiAgPG1hcCBjZW50ZXI9XCI0MS44NTAwMzMsLTg3LjY1MDA1MjNcIiB6b29tPVwiM1wiPlxuICogICAgPGN1c3RvbS1jb250cm9sIGlkPVwiaG9tZVwiIHBvc2l0aW9uPVwiVE9QX0xFRlRcIiBpbmRleD1cIjFcIj5cbiAqICAgICAgPGRpdiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6IHdoaXRlO1wiPlxuICogICAgICAgIDxiPkhvbWU8L2I+XG4gKiAgICAgIDwvZGl2PlxuICogICAgPC9jdXN0b20tY29udHJvbD5cbiAqICA8L21hcD5cbiAqXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICB2YXIgcGFyc2VyLCBOZ01hcDtcblxuICB2YXIgbGlua0Z1bmMgPSBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG1hcENvbnRyb2xsZXIsICR0cmFuc2NsdWRlKSB7XG4gICAgbWFwQ29udHJvbGxlciA9IG1hcENvbnRyb2xsZXJbMF18fG1hcENvbnRyb2xsZXJbMV07XG4gICAgdmFyIGZpbHRlcmVkID0gcGFyc2VyLmZpbHRlcihhdHRycyk7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJzZXIuZ2V0T3B0aW9ucyhmaWx0ZXJlZCwge3Njb3BlOiBzY29wZX0pO1xuICAgIHZhciBldmVudHMgPSBwYXJzZXIuZ2V0RXZlbnRzKHNjb3BlLCBmaWx0ZXJlZCk7XG5cbiAgICAvKipcbiAgICAgKiBidWlsZCBhIGN1c3RvbSBjb250cm9sIGVsZW1lbnRcbiAgICAgKi9cbiAgICB2YXIgY3VzdG9tQ29udHJvbEVsID0gZWxlbWVudFswXS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnRbMF0pO1xuICAgIHZhciBjb250ZW50ID0gJHRyYW5zY2x1ZGUoKTtcbiAgICBhbmd1bGFyLmVsZW1lbnQoY3VzdG9tQ29udHJvbEVsKS5hcHBlbmQoY29udGVudCk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgZXZlbnRzXG4gICAgICovXG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50cykge1xuICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkRG9tTGlzdGVuZXIoY3VzdG9tQ29udHJvbEVsLCBldmVudE5hbWUsIGV2ZW50c1tldmVudE5hbWVdKTtcbiAgICB9XG5cbiAgICBtYXBDb250cm9sbGVyLmFkZE9iamVjdCgnY3VzdG9tQ29udHJvbHMnLCBjdXN0b21Db250cm9sRWwpO1xuICAgIHZhciBwb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgbWFwQ29udHJvbGxlci5tYXAuY29udHJvbHNbZ29vZ2xlLm1hcHMuQ29udHJvbFBvc2l0aW9uW3Bvc2l0aW9uXV0ucHVzaChjdXN0b21Db250cm9sRWwpO1xuXG4gICAgZWxlbWVudC5iaW5kKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgbWFwQ29udHJvbGxlci5kZWxldGVPYmplY3QoJ2N1c3RvbUNvbnRyb2xzJywgY3VzdG9tQ29udHJvbEVsKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgY3VzdG9tQ29udHJvbCA9ICBmdW5jdGlvbihBdHRyMk1hcE9wdGlvbnMsIF9OZ01hcF8pICB7XG4gICAgcGFyc2VyID0gQXR0cjJNYXBPcHRpb25zLCBOZ01hcCA9IF9OZ01hcF87XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgIHJlcXVpcmU6IFsnP15tYXAnLCc/Xm5nTWFwJ10sXG4gICAgICBsaW5rOiBsaW5rRnVuYyxcbiAgICAgIHRyYW5zY2x1ZGU6IHRydWVcbiAgICB9OyAvLyByZXR1cm5cbiAgfTtcbiAgY3VzdG9tQ29udHJvbC4kaW5qZWN0ID0gWydBdHRyMk1hcE9wdGlvbnMnLCAnTmdNYXAnXTtcblxuICBhbmd1bGFyLm1vZHVsZSgnbmdNYXAnKS5kaXJlY3RpdmUoJ2N1c3RvbUNvbnRyb2wnLCBjdXN0b21Db250cm9sKTtcbn0pKCk7XG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG1lbWJlcm9mIG5nbWFwXG4gKiBAbmFtZSBjdXN0b20tbWFya2VyXG4gKiBAcGFyYW0gQXR0cjJPcHRpb25zIHtzZXJ2aWNlfSBjb252ZXJ0IGh0bWwgYXR0cmlidXRlIHRvIEdvb2dsZSBtYXAgYXBpIG9wdGlvbnNcbiAqIEBwYXJhbSAkdGltZW91dCB7c2VydmljZX0gQW5ndWxhckpTICR0aW1lb3V0XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgTWFya2VyIHdpdGggaHRtbFxuICogICBSZXF1aXJlczogIG1hcCBkaXJlY3RpdmVcbiAqICAgUmVzdHJpY3QgVG86ICBFbGVtZW50XG4gKlxuICogQGF0dHIge1N0cmluZ30gcG9zaXRpb24gcmVxdWlyZWQsIHBvc2l0aW9uIG9uIG1hcFxuICogQGF0dHIge051bWJlcn0gei1pbmRleCBvcHRpb25hbFxuICogQGF0dHIge0Jvb2xlYW59IHZpc2libGUgb3B0aW9uYWxcbiAqIEBleGFtcGxlXG4gKlxuICogRXhhbXBsZTpcbiAqICAgPG1hcCBjZW50ZXI9XCI0MS44NTAwMzMsLTg3LjY1MDA1MjNcIiB6b29tPVwiM1wiPlxuICogICAgIDxjdXN0b20tbWFya2VyIHBvc2l0aW9uPVwiNDEuODUwMDMzLC04Ny42NTAwNTIzXCI+XG4gKiAgICAgICA8ZGl2PlxuICogICAgICAgICA8Yj5Ib21lPC9iPlxuICogICAgICAgPC9kaXY+XG4gKiAgICAgPC9jdXN0b20tbWFya2VyPlxuICogICA8L21hcD5cbiAqXG4gKi9cbi8qIGdsb2JhbCBkb2N1bWVudCAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBwYXJzZXIsICR0aW1lb3V0LCAkY29tcGlsZSwgTmdNYXA7XG5cbiAgdmFyIEN1c3RvbU1hcmtlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmVsLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICB0aGlzLmVsLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHsgLyoganNoaW50IGlnbm9yZTpsaW5lICovXG4gICAgIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNldEN1c3RvbU1hcmtlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgQ3VzdG9tTWFya2VyLnByb3RvdHlwZSA9IG5ldyBnb29nbGUubWFwcy5PdmVybGF5VmlldygpO1xuXG4gICAgQ3VzdG9tTWFya2VyLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24oaHRtbCwgc2NvcGUpIHtcbiAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIHRoaXMuZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgICRjb21waWxlKGFuZ3VsYXIuZWxlbWVudCh0aGlzLmVsKS5jb250ZW50cygpKShzY29wZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEN1c3RvbU1hcmtlci5wcm90b3R5cGUuZ2V0RHJhZ2dhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGU7XG4gICAgfTtcblxuICAgIEN1c3RvbU1hcmtlci5wcm90b3R5cGUuc2V0RHJhZ2dhYmxlID0gZnVuY3Rpb24oZHJhZ2dhYmxlKSB7XG4gICAgICB0aGlzLmRyYWdnYWJsZSA9IGRyYWdnYWJsZTtcbiAgICB9O1xuXG4gICAgQ3VzdG9tTWFya2VyLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb247XG4gICAgfTtcblxuICAgIEN1c3RvbU1hcmtlci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgcG9zaXRpb24gJiYgKHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbik7IC8qIGpzaGludCBpZ25vcmU6bGluZSAqL1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLmdldFByb2plY3Rpb24oKSAmJiB0eXBlb2YgdGhpcy5wb3NpdGlvbi5sbmcgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2b2lkIDA7XG4gICAgICAgIHZhciBzZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghX3RoaXMuZ2V0UHJvamVjdGlvbigpKSB7IHJldHVybjsgfVxuICAgICAgICAgIHZhciBwb3NQaXhlbCA9IF90aGlzLmdldFByb2plY3Rpb24oKS5mcm9tTGF0TG5nVG9EaXZQaXhlbChfdGhpcy5wb3NpdGlvbik7XG4gICAgICAgICAgdmFyIHggPSBNYXRoLnJvdW5kKHBvc1BpeGVsLnggLSAoX3RoaXMuZWwub2Zmc2V0V2lkdGgvMikpO1xuICAgICAgICAgIHZhciB5ID0gTWF0aC5yb3VuZChwb3NQaXhlbC55IC0gX3RoaXMuZWwub2Zmc2V0SGVpZ2h0IC0gMTApOyAvLyAxMHB4IGZvciBhbmNob3JcbiAgICAgICAgICBfdGhpcy5lbC5zdHlsZS5sZWZ0ID0geCArIFwicHhcIjtcbiAgICAgICAgICBfdGhpcy5lbC5zdHlsZS50b3AgPSB5ICsgXCJweFwiO1xuICAgICAgICAgIF90aGlzLmVsLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKF90aGlzLmVsLm9mZnNldFdpZHRoICYmIF90aGlzLmVsLm9mZnNldEhlaWdodCkge1xuICAgICAgICAgIHNldFBvc2l0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9kZWxheWVkIGxlZnQvdG9wIGNhbGN1bGF0aW9uIHdoZW4gd2lkdGgvaGVpZ2h0IGFyZSBub3Qgc2V0IGluc3RhbnRseVxuICAgICAgICAgICR0aW1lb3V0KHNldFBvc2l0aW9uLCAzMDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIEN1c3RvbU1hcmtlci5wcm90b3R5cGUuc2V0WkluZGV4ID0gZnVuY3Rpb24oekluZGV4KSB7XG4gICAgICB6SW5kZXggJiYgKHRoaXMuekluZGV4ID0gekluZGV4KTsgLyoganNoaW50IGlnbm9yZTpsaW5lICovXG4gICAgICB0aGlzLmVsLnN0eWxlLnpJbmRleCA9IHRoaXMuekluZGV4O1xuICAgIH07XG5cbiAgICBDdXN0b21NYXJrZXIucHJvdG90eXBlLmdldFZpc2libGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2libGU7XG4gICAgfTtcblxuICAgIEN1c3RvbU1hcmtlci5wcm90b3R5cGUuc2V0VmlzaWJsZSA9IGZ1bmN0aW9uKHZpc2libGUpIHtcbiAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9IHZpc2libGUgPyAnaW5saW5lLWJsb2NrJyA6ICdub25lJztcbiAgICAgIHRoaXMudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfTtcblxuICAgIEN1c3RvbU1hcmtlci5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgIHZhciBjbGFzc05hbWVzID0gdGhpcy5lbC5jbGFzc05hbWUudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgICAoY2xhc3NOYW1lcy5pbmRleE9mKGNsYXNzTmFtZSkgPT0gLTEpICYmIGNsYXNzTmFtZXMucHVzaChjbGFzc05hbWUpOyAvKiBqc2hpbnQgaWdub3JlOmxpbmUgKi9cbiAgICAgIHRoaXMuZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lcy5qb2luKCcgJyk7XG4gICAgfTtcblxuICAgIEN1c3RvbU1hcmtlci5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgIHZhciBjbGFzc05hbWVzID0gdGhpcy5lbC5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgICAgIHZhciBpbmRleCA9IGNsYXNzTmFtZXMuaW5kZXhPZihjbGFzc05hbWUpO1xuICAgICAgKGluZGV4ID4gLTEpICYmIGNsYXNzTmFtZXMuc3BsaWNlKGluZGV4LCAxKTsgLyoganNoaW50IGlnbm9yZTpsaW5lICovXG4gICAgICB0aGlzLmVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZXMuam9pbignICcpO1xuICAgIH07XG5cbiAgICBDdXN0b21NYXJrZXIucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmdldFBhbmVzKCkub3ZlcmxheU1vdXNlVGFyZ2V0LmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuICAgIH07XG5cbiAgICBDdXN0b21NYXJrZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0UG9zaXRpb24oKTtcbiAgICAgIHRoaXMuc2V0WkluZGV4KHRoaXMuekluZGV4KTtcbiAgICAgIHRoaXMuc2V0VmlzaWJsZSh0aGlzLnZpc2libGUpO1xuICAgIH07XG5cbiAgICBDdXN0b21NYXJrZXIucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbCk7XG4gICAgICAvL3RoaXMuZWwgPSBudWxsO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpbmtGdW5jID0gZnVuY3Rpb24ob3JnSHRtbCwgdmFyc1RvV2F0Y2gpIHtcbiAgICAvL2NvbnNvbGUubG9nKCdvcmdIdG1sJywgb3JnSHRtbCwgJ3ZhcnNUb1dhdGNoJywgdmFyc1RvV2F0Y2gpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgbWFwQ29udHJvbGxlcikge1xuICAgICAgbWFwQ29udHJvbGxlciA9IG1hcENvbnRyb2xsZXJbMF18fG1hcENvbnRyb2xsZXJbMV07XG4gICAgICB2YXIgb3JnQXR0cnMgPSBwYXJzZXIub3JnQXR0cmlidXRlcyhlbGVtZW50KTtcblxuICAgICAgdmFyIGZpbHRlcmVkID0gcGFyc2VyLmZpbHRlcihhdHRycyk7XG4gICAgICB2YXIgb3B0aW9ucyA9IHBhcnNlci5nZXRPcHRpb25zKGZpbHRlcmVkLCB7c2NvcGU6IHNjb3BlfSk7XG4gICAgICB2YXIgZXZlbnRzID0gcGFyc2VyLmdldEV2ZW50cyhzY29wZSwgZmlsdGVyZWQpO1xuXG4gICAgICAvKipcbiAgICAgICAqIGJ1aWxkIGEgY3VzdG9tIG1hcmtlciBlbGVtZW50XG4gICAgICAgKi9cbiAgICAgIGVsZW1lbnRbMF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHZvaWQgMDtcbiAgICAgIHZhciBjdXN0b21NYXJrZXIgPSBuZXcgQ3VzdG9tTWFya2VyKG9wdGlvbnMpO1xuXG4gICAgICAkdGltZW91dChmdW5jdGlvbigpIHsgLy9hcHBseSBjb250ZW50cywgY2xhc3MsIGFuZCBsb2NhdGlvbiBhZnRlciBpdCBpcyBjb21waWxlZFxuXG4gICAgICAgIHNjb3BlLiR3YXRjaCgnWycgKyB2YXJzVG9XYXRjaC5qb2luKCcsJykgKyAnXScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGN1c3RvbU1hcmtlci5zZXRDb250ZW50KG9yZ0h0bWwsIHNjb3BlKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgY3VzdG9tTWFya2VyLnNldENvbnRlbnQoZWxlbWVudFswXS5pbm5lckhUTUwsIHNjb3BlKTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBlbGVtZW50WzBdLmZpcnN0RWxlbWVudENoaWxkLmNsYXNzTmFtZTtcbiAgICAgICAgY3VzdG9tTWFya2VyLmFkZENsYXNzKCdjdXN0b20tbWFya2VyJyk7XG4gICAgICAgIGN1c3RvbU1hcmtlci5hZGRDbGFzcyhjbGFzc05hbWVzKTtcbiAgICAgICAgdm9pZCAwO1xuXG4gICAgICAgIGlmICghKG9wdGlvbnMucG9zaXRpb24gaW5zdGFuY2VvZiBnb29nbGUubWFwcy5MYXRMbmcpKSB7XG4gICAgICAgICAgTmdNYXAuZ2V0R2VvTG9jYXRpb24ob3B0aW9ucy5wb3NpdGlvbikudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihsYXRsbmcpIHtcbiAgICAgICAgICAgICAgICAgIGN1c3RvbU1hcmtlci5zZXRQb3NpdGlvbihsYXRsbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgICB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnRzKSB7IC8qIGpzaGludCBpZ25vcmU6bGluZSAqL1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGREb21MaXN0ZW5lcihcbiAgICAgICAgICBjdXN0b21NYXJrZXIuZWwsIGV2ZW50TmFtZSwgZXZlbnRzW2V2ZW50TmFtZV0pO1xuICAgICAgfVxuICAgICAgbWFwQ29udHJvbGxlci5hZGRPYmplY3QoJ2N1c3RvbU1hcmtlcnMnLCBjdXN0b21NYXJrZXIpO1xuXG4gICAgICAvL3NldCBvYnNlcnZlcnNcbiAgICAgIG1hcENvbnRyb2xsZXIub2JzZXJ2ZUF0dHJTZXRPYmoob3JnQXR0cnMsIGF0dHJzLCBjdXN0b21NYXJrZXIpO1xuXG4gICAgICBlbGVtZW50LmJpbmQoJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vSXMgaXQgcmVxdWlyZWQgdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB3aGVuIERPTSBpcyByZW1vdmVkP1xuICAgICAgICBtYXBDb250cm9sbGVyLmRlbGV0ZU9iamVjdCgnY3VzdG9tTWFya2VycycsIGN1c3RvbU1hcmtlcik7XG4gICAgICB9KTtcblxuICAgIH07IC8vIGxpbmtGdW5jXG4gIH07XG5cblxuICB2YXIgY3VzdG9tTWFya2VyRGlyZWN0aXZlID0gZnVuY3Rpb24oXG4gICAgICBfJHRpbWVvdXRfLCBfJGNvbXBpbGVfLCAkaW50ZXJwb2xhdGUsIEF0dHIyTWFwT3B0aW9ucywgX05nTWFwXywgZXNjYXBlUmVnRXhwXG4gICAgKSAge1xuICAgIHBhcnNlciA9IEF0dHIyTWFwT3B0aW9ucztcbiAgICAkdGltZW91dCA9IF8kdGltZW91dF87XG4gICAgJGNvbXBpbGUgPSBfJGNvbXBpbGVfO1xuICAgIE5nTWFwID0gX05nTWFwXztcblxuICAgIHZhciBleHByU3RhcnRTeW1ib2wgPSAkaW50ZXJwb2xhdGUuc3RhcnRTeW1ib2woKTtcbiAgICB2YXIgZXhwckVuZFN5bWJvbCA9ICRpbnRlcnBvbGF0ZS5lbmRTeW1ib2woKTtcbiAgICB2YXIgZXhwclJlZ0V4cCA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKGV4cHJTdGFydFN5bWJvbCkgKyAnKFteJyArIGV4cHJFbmRTeW1ib2wuc3Vic3RyaW5nKDAsIDEpICsgJ10rKScgKyBlc2NhcGVSZWdFeHAoZXhwckVuZFN5bWJvbCksICdnJyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgIHJlcXVpcmU6IFsnP15tYXAnLCc/Xm5nTWFwJ10sXG4gICAgICBjb21waWxlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHNldEN1c3RvbU1hcmtlcigpO1xuICAgICAgICBlbGVtZW50WzBdLnN0eWxlLmRpc3BsYXkgPSdub25lJztcbiAgICAgICAgdmFyIG9yZ0h0bWwgPSBlbGVtZW50Lmh0bWwoKTtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBvcmdIdG1sLm1hdGNoKGV4cHJSZWdFeHApO1xuICAgICAgICB2YXIgdmFyc1RvV2F0Y2ggPSBbXTtcbiAgICAgICAgLy9maWx0ZXIgb3V0IHRoYXQgY29udGFpbnMgJzo6JywgJ3RoaXMuJ1xuICAgICAgICAobWF0Y2hlcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgIHZhciB0b1dhdGNoID0gbWF0Y2gucmVwbGFjZShleHByU3RhcnRTeW1ib2wsJycpLnJlcGxhY2UoZXhwckVuZFN5bWJvbCwnJyk7XG4gICAgICAgICAgaWYgKG1hdGNoLmluZGV4T2YoJzo6JykgPT0gLTEgJiZcbiAgICAgICAgICAgIG1hdGNoLmluZGV4T2YoJ3RoaXMuJykgPT0gLTEgJiZcbiAgICAgICAgICAgIHZhcnNUb1dhdGNoLmluZGV4T2YodG9XYXRjaCkgPT0gLTEpIHtcbiAgICAgICAgICAgIHZhcnNUb1dhdGNoLnB1c2gobWF0Y2gucmVwbGFjZShleHByU3RhcnRTeW1ib2wsJycpLnJlcGxhY2UoZXhwckVuZFN5bWJvbCwnJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGxpbmtGdW5jKG9yZ0h0bWwsIHZhcnNUb1dhdGNoKTtcbiAgICAgIH1cbiAgICB9OyAvLyByZXR1cm5cbiAgfTsvLyBmdW5jdGlvblxuICBjdXN0b21NYXJrZXJEaXJlY3RpdmUuJGluamVjdCA9XG4gICAgWyckdGltZW91dCcsICckY29tcGlsZScsICckaW50ZXJwb2xhdGUnLCAnQXR0cjJNYXBPcHRpb25zJywgJ05nTWFwJywgJ2VzY2FwZVJlZ2V4cEZpbHRlciddO1xuXG4gIGFuZ3VsYXIubW9kdWxlKCduZ01hcCcpLmRpcmVjdGl2ZSgnY3VzdG9tTWFya2VyJywgY3VzdG9tTWFya2VyRGlyZWN0aXZlKTtcbn0pKCk7XG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgZGlyZWN0aW9uc1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIEVuYWJsZSBkaXJlY3Rpb25zIG9uIG1hcC5cbiAqICAgZS5nLiwgb3JpZ2luLCBkZXN0aW5hdGlvbiwgZHJhZ2dhYmxlLCB3YXlwb2ludHMsIGV0Y1xuICpcbiAqICAgUmVxdWlyZXM6ICBtYXAgZGlyZWN0aXZlXG4gKlxuICogICBSZXN0cmljdCBUbzogIEVsZW1lbnRcbiAqXG4gKiBAYXR0ciB7U3RyaW5nfSBEaXJlY3Rpb25zUmVuZGVyZXJPcHRpb25zXG4gKiAgIFtBbnkgRGlyZWN0aW9uc1JlbmRlcmVyT3B0aW9uc10oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvcmVmZXJlbmNlI0RpcmVjdGlvbnNSZW5kZXJlck9wdGlvbnMpXG4gKiBAYXR0ciB7U3RyaW5nfSBEaXJlY3Rpb25zUmVxdWVzdE9wdGlvbnNcbiAqICAgW0FueSBEaXJlY3Rpb25zUmVxdWVzdCBvcHRpb25zXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2UjRGlyZWN0aW9uc1JlcXVlc3QpXG4gKiBAZXhhbXBsZVxuICogIDxtYXAgem9vbT1cIjE0XCIgY2VudGVyPVwiMzcuNzY5OTI5OCwgLTEyMi40NDY5MTU3XCI+XG4gKiAgICA8ZGlyZWN0aW9uc1xuICogICAgICBkcmFnZ2FibGU9XCJ0cnVlXCJcbiAqICAgICAgcGFuZWw9XCJkaXJlY3Rpb25zLXBhbmVsXCJcbiAqICAgICAgdHJhdmVsLW1vZGU9XCJ7e3RyYXZlbE1vZGV9fVwiXG4gKiAgICAgIHdheXBvaW50cz1cIlt7bG9jYXRpb246J2tpbmdzdG9uJywgc3RvcG92ZXI6dHJ1ZX1dXCJcbiAqICAgICAgb3JpZ2luPVwie3tvcmlnaW59fVwiXG4gKiAgICAgIGRlc3RpbmF0aW9uPVwie3tkZXN0aW5hdGlvbn19XCI+XG4gKiAgICA8L2RpcmVjdGlvbnM+XG4gKiAgPC9tYXA+XG4gKi9cbi8qIGdsb2JhbCBkb2N1bWVudCAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBOZ01hcCwgJHRpbWVvdXQsIE5hdmlnYXRvckdlb2xvY2F0aW9uO1xuXG4gIHZhciBnZXREaXJlY3Rpb25zUmVuZGVyZXIgPSBmdW5jdGlvbihvcHRpb25zLCBldmVudHMpIHtcbiAgICBpZiAob3B0aW9ucy5wYW5lbCkge1xuICAgICAgb3B0aW9ucy5wYW5lbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMucGFuZWwpIHx8XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob3B0aW9ucy5wYW5lbCk7XG4gICAgfVxuICAgIHZhciByZW5kZXJlciA9IG5ldyBnb29nbGUubWFwcy5EaXJlY3Rpb25zUmVuZGVyZXIob3B0aW9ucyk7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50cykge1xuICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocmVuZGVyZXIsIGV2ZW50TmFtZSwgZXZlbnRzW2V2ZW50TmFtZV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVuZGVyZXI7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZVJvdXRlID0gZnVuY3Rpb24ocmVuZGVyZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGlyZWN0aW9uc1NlcnZpY2UgPSBuZXcgZ29vZ2xlLm1hcHMuRGlyZWN0aW9uc1NlcnZpY2UoKTtcblxuICAgIC8qIGZpbHRlciBvdXQgdmFsaWQga2V5cyBvbmx5IGZvciBEaXJlY3Rpb25zUmVxdWVzdCBvYmplY3QqL1xuICAgIHZhciByZXF1ZXN0ID0gb3B0aW9ucztcbiAgICByZXF1ZXN0LnRyYXZlbE1vZGUgPSByZXF1ZXN0LnRyYXZlbE1vZGUgfHwgJ0RSSVZJTkcnO1xuICAgIHZhciB2YWxpZEtleXMgPSBbXG4gICAgICAnb3JpZ2luJywgJ2Rlc3RpbmF0aW9uJywgJ3RyYXZlbE1vZGUnLCAndHJhbnNpdE9wdGlvbnMnLCAndW5pdFN5c3RlbScsXG4gICAgICAnZHVyYXRpb25JblRyYWZmaWMnLCAnd2F5cG9pbnRzJywgJ29wdGltaXplV2F5cG9pbnRzJywgXG4gICAgICAncHJvdmlkZVJvdXRlQWx0ZXJuYXRpdmVzJywgJ2F2b2lkSGlnaHdheXMnLCAnYXZvaWRUb2xscycsICdyZWdpb24nXG4gICAgXTtcbiAgICBmb3IodmFyIGtleSBpbiByZXF1ZXN0KXtcbiAgICAgICh2YWxpZEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkgJiYgKGRlbGV0ZSByZXF1ZXN0W2tleV0pO1xuICAgIH1cblxuICAgIGlmKHJlcXVlc3Qud2F5cG9pbnRzKSB7XG4gICAgICAvLyBDaGVjayBmbyB2YWxpZCB2YWx1ZXNcbiAgICAgIGlmKHJlcXVlc3Qud2F5cG9pbnRzID09IFwiW11cIiB8fCByZXF1ZXN0LndheXBvaW50cyA9PT0gXCJcIikge1xuICAgICAgICBkZWxldGUgcmVxdWVzdC53YXlwb2ludHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNob3dEaXJlY3Rpb25zID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgZGlyZWN0aW9uc1NlcnZpY2Uucm91dGUocmVxdWVzdCwgZnVuY3Rpb24ocmVzcG9uc2UsIHN0YXR1cykge1xuICAgICAgICBpZiAoc3RhdHVzID09IGdvb2dsZS5tYXBzLkRpcmVjdGlvbnNTdGF0dXMuT0spIHtcbiAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldERpcmVjdGlvbnMocmVzcG9uc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKHJlcXVlc3Qub3JpZ2luICYmIHJlcXVlc3QuZGVzdGluYXRpb24pIHtcbiAgICAgIGlmIChyZXF1ZXN0Lm9yaWdpbiA9PSAnY3VycmVudC1sb2NhdGlvbicpIHtcbiAgICAgICAgTmF2aWdhdG9yR2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKCkudGhlbihmdW5jdGlvbihsbCkge1xuICAgICAgICAgIHJlcXVlc3Qub3JpZ2luID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhsbC5jb29yZHMubGF0aXR1ZGUsIGxsLmNvb3Jkcy5sb25naXR1ZGUpO1xuICAgICAgICAgIHNob3dEaXJlY3Rpb25zKHJlcXVlc3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAocmVxdWVzdC5kZXN0aW5hdGlvbiA9PSAnY3VycmVudC1sb2NhdGlvbicpIHtcbiAgICAgICAgTmF2aWdhdG9yR2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKCkudGhlbihmdW5jdGlvbihsbCkge1xuICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGxsLmNvb3Jkcy5sYXRpdHVkZSwgbGwuY29vcmRzLmxvbmdpdHVkZSk7XG4gICAgICAgICAgc2hvd0RpcmVjdGlvbnMocmVxdWVzdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hvd0RpcmVjdGlvbnMocmVxdWVzdCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBkaXJlY3Rpb25zID0gZnVuY3Rpb24oXG4gICAgICBBdHRyMk1hcE9wdGlvbnMsIF8kdGltZW91dF8sIF9OYXZpZ2F0b3JHZW9sb2NhdGlvbl8sIF9OZ01hcF8pIHtcbiAgICB2YXIgcGFyc2VyID0gQXR0cjJNYXBPcHRpb25zO1xuICAgIE5nTWFwID0gX05nTWFwXztcbiAgICAkdGltZW91dCA9IF8kdGltZW91dF87XG4gICAgTmF2aWdhdG9yR2VvbG9jYXRpb24gPSBfTmF2aWdhdG9yR2VvbG9jYXRpb25fO1xuXG4gICAgdmFyIGxpbmtGdW5jID0gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBtYXBDb250cm9sbGVyKSB7XG4gICAgICBtYXBDb250cm9sbGVyID0gbWFwQ29udHJvbGxlclswXXx8bWFwQ29udHJvbGxlclsxXTtcblxuICAgICAgdmFyIG9yZ0F0dHJzID0gcGFyc2VyLm9yZ0F0dHJpYnV0ZXMoZWxlbWVudCk7XG4gICAgICB2YXIgZmlsdGVyZWQgPSBwYXJzZXIuZmlsdGVyKGF0dHJzKTtcbiAgICAgIHZhciBvcHRpb25zID0gcGFyc2VyLmdldE9wdGlvbnMoZmlsdGVyZWQsIHtzY29wZTogc2NvcGV9KTtcbiAgICAgIHZhciBldmVudHMgPSBwYXJzZXIuZ2V0RXZlbnRzKHNjb3BlLCBmaWx0ZXJlZCk7XG4gICAgICB2YXIgYXR0cnNUb09ic2VydmUgPSBwYXJzZXIuZ2V0QXR0cnNUb09ic2VydmUob3JnQXR0cnMpO1xuXG4gICAgICB2YXIgcmVuZGVyZXIgPSBnZXREaXJlY3Rpb25zUmVuZGVyZXIob3B0aW9ucywgZXZlbnRzKTtcbiAgICAgIG1hcENvbnRyb2xsZXIuYWRkT2JqZWN0KCdkaXJlY3Rpb25zUmVuZGVyZXJzJywgcmVuZGVyZXIpO1xuXG4gICAgICBhdHRyc1RvT2JzZXJ2ZS5mb3JFYWNoKGZ1bmN0aW9uKGF0dHJOYW1lKSB7XG4gICAgICAgIChmdW5jdGlvbihhdHRyTmFtZSkge1xuICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKGF0dHJOYW1lLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIGlmIChhdHRyTmFtZSA9PSAncGFuZWwnKSB7XG4gICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdmFyIHBhbmVsID1cbiAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHZhbCkgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih2YWwpO1xuICAgICAgICAgICAgICAgIHZvaWQgMDtcbiAgICAgICAgICAgICAgICBwYW5lbCAmJiByZW5kZXJlci5zZXRQYW5lbChwYW5lbCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zW2F0dHJOYW1lXSAhPT0gdmFsKSB7IC8vYXBwbHkgb25seSBpZiBjaGFuZ2VkXG4gICAgICAgICAgICAgIHZhciBvcHRpb25WYWx1ZSA9IHBhcnNlci50b09wdGlvblZhbHVlKHZhbCwge2tleTogYXR0ck5hbWV9KTtcbiAgICAgICAgICAgICAgdm9pZCAwO1xuICAgICAgICAgICAgICBvcHRpb25zW2F0dHJOYW1lXSA9IG9wdGlvblZhbHVlO1xuICAgICAgICAgICAgICB1cGRhdGVSb3V0ZShyZW5kZXJlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKGF0dHJOYW1lKTtcbiAgICAgIH0pO1xuXG4gICAgICBOZ01hcC5nZXRNYXAoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICB1cGRhdGVSb3V0ZShyZW5kZXJlciwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQuYmluZCgnJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgbWFwQ29udHJvbGxlci5kZWxldGVPYmplY3QoJ2RpcmVjdGlvbnNSZW5kZXJlcnMnLCByZW5kZXJlcik7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICByZXF1aXJlOiBbJz9ebWFwJywnP15uZ01hcCddLFxuICAgICAgbGluazogbGlua0Z1bmNcbiAgICB9O1xuICB9OyAvLyB2YXIgZGlyZWN0aW9uc1xuICBkaXJlY3Rpb25zLiRpbmplY3QgPVxuICAgIFsnQXR0cjJNYXBPcHRpb25zJywgJyR0aW1lb3V0JywgJ05hdmlnYXRvckdlb2xvY2F0aW9uJywgJ05nTWFwJ107XG5cbiAgYW5ndWxhci5tb2R1bGUoJ25nTWFwJykuZGlyZWN0aXZlKCdkaXJlY3Rpb25zJywgZGlyZWN0aW9ucyk7XG59KSgpO1xuXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgZHJhd2luZy1tYW5hZ2VyXG4gKiBAcGFyYW0gQXR0cjJPcHRpb25zIHtzZXJ2aWNlfSBjb252ZXJ0IGh0bWwgYXR0cmlidXRlIHRvIEdvb2dsZSBtYXAgYXBpIG9wdGlvbnNcbiAqIEBkZXNjcmlwdGlvblxuICogICBSZXF1aXJlczogIG1hcCBkaXJlY3RpdmVcbiAqICAgUmVzdHJpY3QgVG86ICBFbGVtZW50XG4gKlxuICogQGV4YW1wbGVcbiAqIEV4YW1wbGU6XG4gKlxuICogIDxtYXAgem9vbT1cIjEzXCIgY2VudGVyPVwiMzcuNzc0NTQ2LCAtMTIyLjQzMzUyM1wiIG1hcC10eXBlLWlkPVwiU0FURUxMSVRFXCI+XG4gKiAgICA8ZHJhd2luZy1tYW5hZ2VyXG4gKiAgICAgIG9uLW92ZXJsYXljb21wbGV0ZT1cIm9uTWFwT3ZlcmxheUNvbXBsZXRlZCgpXCJcbiAqICAgICAgcG9zaXRpb249XCJDb250cm9sUG9zaXRpb24uVE9QX0NFTlRFUlwiXG4gKiAgICAgIGRyYXdpbmdNb2Rlcz1cIlBPTFlHT04sQ0lSQ0xFXCJcbiAqICAgICAgZHJhd2luZ0NvbnRyb2w9XCJ0cnVlXCJcbiAqICAgICAgY2lyY2xlT3B0aW9ucz1cImZpbGxDb2xvcjogJyNGRkZGMDAnO2ZpbGxPcGFjaXR5OiAxO3N0cm9rZVdlaWdodDogNTtjbGlja2FibGU6IGZhbHNlO3pJbmRleDogMTtlZGl0YWJsZTogdHJ1ZTtcIiA+XG4gKiAgICA8L2RyYXdpbmctbWFuYWdlcj5cbiAqICA8L21hcD5cbiAqXG4gKiAgVE9ETzogQWRkIHJlbW92ZSBidXR0b24uXG4gKiAgY3VycmVudGx5LCBmb3Igb3VyIHNvbHV0aW9uLCB3ZSBoYXZlIHRoZSBzaGFwZXMvbWFya2VycyBpbiBvdXIgb3duXG4gKiAgY29udHJvbGxlciwgYW5kIHdlIHVzZSBzb21lIGNzcyBjbGFzc2VzIHRvIGNoYW5nZSB0aGUgc2hhcGUgYnV0dG9uXG4gKiAgdG8gYSByZW1vdmUgYnV0dG9uICg8ZGl2Plg8L2Rpdj4pIGFuZCBoYXZlIHRoZSByZW1vdmUgb3BlcmF0aW9uIGluIG91ciBvd24gY29udHJvbGxlci5cbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIGFuZ3VsYXIubW9kdWxlKCduZ01hcCcpLmRpcmVjdGl2ZSgnZHJhd2luZ01hbmFnZXInLCBbXG4gICAgJ0F0dHIyTWFwT3B0aW9ucycsIGZ1bmN0aW9uKEF0dHIyTWFwT3B0aW9ucykge1xuICAgIHZhciBwYXJzZXIgPSBBdHRyMk1hcE9wdGlvbnM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgIHJlcXVpcmU6IFsnP15tYXAnLCc/Xm5nTWFwJ10sXG5cbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgbWFwQ29udHJvbGxlcikge1xuICAgICAgICBtYXBDb250cm9sbGVyID0gbWFwQ29udHJvbGxlclswXXx8bWFwQ29udHJvbGxlclsxXTtcblxuICAgICAgICB2YXIgZmlsdGVyZWQgPSBwYXJzZXIuZmlsdGVyKGF0dHJzKTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBwYXJzZXIuZ2V0T3B0aW9ucyhmaWx0ZXJlZCwge3Njb3BlOiBzY29wZX0pO1xuICAgICAgICB2YXIgY29udHJvbE9wdGlvbnMgPSBwYXJzZXIuZ2V0Q29udHJvbE9wdGlvbnMoZmlsdGVyZWQpO1xuICAgICAgICB2YXIgZXZlbnRzID0gcGFyc2VyLmdldEV2ZW50cyhzY29wZSwgZmlsdGVyZWQpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGRyYXdpbmdNYW5hZ2VyID0gbmV3IGdvb2dsZS5tYXBzLmRyYXdpbmcuRHJhd2luZ01hbmFnZXIoe1xuICAgICAgICAgIGRyYXdpbmdNb2RlOiBvcHRpb25zLmRyYXdpbmdtb2RlLFxuICAgICAgICAgIGRyYXdpbmdDb250cm9sOiBvcHRpb25zLmRyYXdpbmdjb250cm9sLFxuICAgICAgICAgIGRyYXdpbmdDb250cm9sT3B0aW9uczogY29udHJvbE9wdGlvbnMuZHJhd2luZ0NvbnRyb2xPcHRpb25zLFxuICAgICAgICAgIGNpcmNsZU9wdGlvbnM6b3B0aW9ucy5jaXJjbGVvcHRpb25zLFxuICAgICAgICAgIG1hcmtlck9wdGlvbnM6b3B0aW9ucy5tYXJrZXJvcHRpb25zLFxuICAgICAgICAgIHBvbHlnb25PcHRpb25zOm9wdGlvbnMucG9seWdvbm9wdGlvbnMsXG4gICAgICAgICAgcG9seWxpbmVPcHRpb25zOm9wdGlvbnMucG9seWxpbmVvcHRpb25zLFxuICAgICAgICAgIHJlY3RhbmdsZU9wdGlvbnM6b3B0aW9ucy5yZWN0YW5nbGVvcHRpb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vT2JzZXJ2ZXJzXG4gICAgICAgIGF0dHJzLiRvYnNlcnZlKCdkcmF3aW5nQ29udHJvbE9wdGlvbnMnLCBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICBkcmF3aW5nTWFuYWdlci5kcmF3aW5nQ29udHJvbE9wdGlvbnMgPSBwYXJzZXIuZ2V0Q29udHJvbE9wdGlvbnMoe2RyYXdpbmdDb250cm9sT3B0aW9uczogbmV3VmFsdWV9KS5kcmF3aW5nQ29udHJvbE9wdGlvbnM7XG4gICAgICAgICAgZHJhd2luZ01hbmFnZXIuc2V0RHJhd2luZ01vZGUobnVsbCk7XG4gICAgICAgICAgZHJhd2luZ01hbmFnZXIuc2V0TWFwKG1hcENvbnRyb2xsZXIubWFwKTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IGV2ZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50cykge1xuICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRyYXdpbmdNYW5hZ2VyLCBldmVudE5hbWUsIGV2ZW50c1tldmVudE5hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcENvbnRyb2xsZXIuYWRkT2JqZWN0KCdtYXBEcmF3aW5nTWFuYWdlcicsIGRyYXdpbmdNYW5hZ2VyKTtcblxuICAgICAgICBlbGVtZW50LmJpbmQoJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbWFwQ29udHJvbGxlci5kZWxldGVPYmplY3QoJ21hcERyYXdpbmdNYW5hZ2VyJywgZHJhd2luZ01hbmFnZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9OyAvLyByZXR1cm5cbiAgfV0pO1xufSkoKTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBkeW5hbWljLW1hcHMtZW5naW5lLWxheWVyXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgUmVxdWlyZXM6ICBtYXAgZGlyZWN0aXZlXG4gKiAgIFJlc3RyaWN0IFRvOiAgRWxlbWVudFxuICpcbiAqIEBleGFtcGxlXG4gKiBFeGFtcGxlOlxuICogICA8bWFwIHpvb209XCIxNFwiIGNlbnRlcj1cIls1OS4zMjI1MDYsIDE4LjAxMDAyNV1cIj5cbiAqICAgICA8ZHluYW1pYy1tYXBzLWVuZ2luZS1sYXllclxuICogICAgICAgbGF5ZXItaWQ9XCIwNjY3MzA1NjQ1NDA0NjEzNTUzNy0wODg5NjUwMTk5Nzc2NjU1MzgxMVwiPlxuICogICAgIDwvZHluYW1pYy1tYXBzLWVuZ2luZS1sYXllcj5cbiAqICAgIDwvbWFwPlxuICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBhbmd1bGFyLm1vZHVsZSgnbmdNYXAnKS5kaXJlY3RpdmUoJ2R5bmFtaWNNYXBzRW5naW5lTGF5ZXInLCBbXG4gICAgJ0F0dHIyTWFwT3B0aW9ucycsIGZ1bmN0aW9uKEF0dHIyTWFwT3B0aW9ucykge1xuICAgIHZhciBwYXJzZXIgPSBBdHRyMk1hcE9wdGlvbnM7XG5cbiAgICB2YXIgZ2V0RHluYW1pY01hcHNFbmdpbmVMYXllciA9IGZ1bmN0aW9uKG9wdGlvbnMsIGV2ZW50cykge1xuICAgICAgdmFyIGxheWVyID0gbmV3IGdvb2dsZS5tYXBzLnZpc3VhbGl6YXRpb24uRHluYW1pY01hcHNFbmdpbmVMYXllcihvcHRpb25zKTtcblxuICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50cykge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihsYXllciwgZXZlbnROYW1lLCBldmVudHNbZXZlbnROYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICByZXF1aXJlOiBbJz9ebWFwJywnP15uZ01hcCddLFxuXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG1hcENvbnRyb2xsZXIpIHtcbiAgICAgICAgbWFwQ29udHJvbGxlciA9IG1hcENvbnRyb2xsZXJbMF18fG1hcENvbnRyb2xsZXJbMV07XG5cbiAgICAgICAgdmFyIGZpbHRlcmVkID0gcGFyc2VyLmZpbHRlcihhdHRycyk7XG4gICAgICAgIHZhciBvcHRpb25zID0gcGFyc2VyLmdldE9wdGlvbnMoZmlsdGVyZWQsIHtzY29wZTogc2NvcGV9KTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHBhcnNlci5nZXRFdmVudHMoc2NvcGUsIGZpbHRlcmVkLCBldmVudHMpO1xuXG4gICAgICAgIHZhciBsYXllciA9IGdldER5bmFtaWNNYXBzRW5naW5lTGF5ZXIob3B0aW9ucywgZXZlbnRzKTtcbiAgICAgICAgbWFwQ29udHJvbGxlci5hZGRPYmplY3QoJ21hcHNFbmdpbmVMYXllcnMnLCBsYXllcik7XG4gICAgICB9XG4gICAgIH07IC8vIHJldHVyblxuICB9XSk7XG59KSgpO1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIGZ1c2lvbi10YWJsZXMtbGF5ZXJcbiAqIEBkZXNjcmlwdGlvblxuICogICBSZXF1aXJlczogIG1hcCBkaXJlY3RpdmVcbiAqICAgUmVzdHJpY3QgVG86ICBFbGVtZW50XG4gKlxuICogQGV4YW1wbGVcbiAqIEV4YW1wbGU6XG4gKiAgIDxtYXAgem9vbT1cIjExXCIgY2VudGVyPVwiNDEuODUwMDMzLCAtODcuNjUwMDUyM1wiPlxuICogICAgIDxmdXNpb24tdGFibGVzLWxheWVyIHF1ZXJ5PVwie1xuICogICAgICAgc2VsZWN0OiAnR2VvY29kYWJsZSBhZGRyZXNzJyxcbiAqICAgICAgIGZyb206ICcxbVo1M1o3ME5zQ2huQk1tLXFFWW1TRE92TFhncnJlTFRrUVV2dmcnfVwiPlxuICogICAgIDwvZnVzaW9uLXRhYmxlcy1sYXllcj5cbiAqICAgPC9tYXA+XG4gKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGFuZ3VsYXIubW9kdWxlKCduZ01hcCcpLmRpcmVjdGl2ZSgnZnVzaW9uVGFibGVzTGF5ZXInLCBbXG4gICAgJ0F0dHIyTWFwT3B0aW9ucycsIGZ1bmN0aW9uKEF0dHIyTWFwT3B0aW9ucykge1xuICAgIHZhciBwYXJzZXIgPSBBdHRyMk1hcE9wdGlvbnM7XG5cbiAgICB2YXIgZ2V0TGF5ZXIgPSBmdW5jdGlvbihvcHRpb25zLCBldmVudHMpIHtcbiAgICAgIHZhciBsYXllciA9IG5ldyBnb29nbGUubWFwcy5GdXNpb25UYWJsZXNMYXllcihvcHRpb25zKTtcblxuICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50cykge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihsYXllciwgZXZlbnROYW1lLCBldmVudHNbZXZlbnROYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICByZXF1aXJlOiBbJz9ebWFwJywnP15uZ01hcCddLFxuXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG1hcENvbnRyb2xsZXIpIHtcbiAgICAgICAgbWFwQ29udHJvbGxlciA9IG1hcENvbnRyb2xsZXJbMF18fG1hcENvbnRyb2xsZXJbMV07XG5cbiAgICAgICAgdmFyIGZpbHRlcmVkID0gcGFyc2VyLmZpbHRlcihhdHRycyk7XG4gICAgICAgIHZhciBvcHRpb25zID0gcGFyc2VyLmdldE9wdGlvbnMoZmlsdGVyZWQsIHtzY29wZTogc2NvcGV9KTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHBhcnNlci5nZXRFdmVudHMoc2NvcGUsIGZpbHRlcmVkLCBldmVudHMpO1xuICAgICAgICB2b2lkIDA7XG5cbiAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIob3B0aW9ucywgZXZlbnRzKTtcbiAgICAgICAgbWFwQ29udHJvbGxlci5hZGRPYmplY3QoJ2Z1c2lvblRhYmxlc0xheWVycycsIGxheWVyKTtcbiAgICAgICAgZWxlbWVudC5iaW5kKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG1hcENvbnRyb2xsZXIuZGVsZXRlT2JqZWN0KCdmdXNpb25UYWJsZXNMYXllcnMnLCBsYXllcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICB9OyAvLyByZXR1cm5cbiAgfV0pO1xufSkoKTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBoZWF0bWFwLWxheWVyXG4gKiBAcGFyYW0gQXR0cjJPcHRpb25zIHtzZXJ2aWNlfSBjb252ZXJ0IGh0bWwgYXR0cmlidXRlIHRvIEdvb2dsZSBtYXAgYXBpIG9wdGlvbnNcbiAqIEBkZXNjcmlwdGlvblxuICogICBSZXF1aXJlczogIG1hcCBkaXJlY3RpdmVcbiAqICAgUmVzdHJpY3QgVG86ICBFbGVtZW50XG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiA8bWFwIHpvb209XCIxMVwiIGNlbnRlcj1cIls0MS44NzU2OTYsLTg3LjYyNDIwN11cIj5cbiAqICAgPGhlYXRtYXAtbGF5ZXIgZGF0YT1cInRheGlEYXRhXCI+PC9oZWF0bWFwLWxheWVyPlxuICogPC9tYXA+XG4gKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGFuZ3VsYXIubW9kdWxlKCduZ01hcCcpLmRpcmVjdGl2ZSgnaGVhdG1hcExheWVyJywgW1xuICAgICdBdHRyMk1hcE9wdGlvbnMnLCAnJHdpbmRvdycsIGZ1bmN0aW9uKEF0dHIyTWFwT3B0aW9ucywgJHdpbmRvdykge1xuICAgIHZhciBwYXJzZXIgPSBBdHRyMk1hcE9wdGlvbnM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICByZXF1aXJlOiBbJz9ebWFwJywnP15uZ01hcCddLFxuXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG1hcENvbnRyb2xsZXIpIHtcbiAgICAgICAgbWFwQ29udHJvbGxlciA9IG1hcENvbnRyb2xsZXJbMF18fG1hcENvbnRyb2xsZXJbMV07XG5cbiAgICAgICAgdmFyIGZpbHRlcmVkID0gcGFyc2VyLmZpbHRlcihhdHRycyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHBhcnNlci5nZXRPcHRpb25zKGZpbHRlcmVkLCB7c2NvcGU6IHNjb3BlfSk7XG4gICAgICAgIG9wdGlvbnMuZGF0YSA9ICR3aW5kb3dbYXR0cnMuZGF0YV0gfHwgc2NvcGVbYXR0cnMuZGF0YV07XG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG5ldyBnb29nbGUubWFwcy5NVkNBcnJheShvcHRpb25zLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IFwiaW52YWxpZCBoZWF0bWFwIGRhdGFcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGF5ZXIgPSBuZXcgZ29vZ2xlLm1hcHMudmlzdWFsaXphdGlvbi5IZWF0bWFwTGF5ZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBldmVudHNcbiAgICAgICAgICovXG4gICAgICAgIHZhciBldmVudHMgPSBwYXJzZXIuZ2V0RXZlbnRzKHNjb3BlLCBmaWx0ZXJlZCk7XG4gICAgICAgIHZvaWQgMDtcblxuICAgICAgICBtYXBDb250cm9sbGVyLmFkZE9iamVjdCgnaGVhdG1hcExheWVycycsIGxheWVyKTtcbiAgICAgIH1cbiAgICAgfTsgLy8gcmV0dXJuXG4gIH1dKTtcbn0pKCk7XG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgaW5mby13aW5kb3dcbiAqIEBwYXJhbSBBdHRyMk1hcE9wdGlvbnMge3NlcnZpY2V9XG4gKiAgIGNvbnZlcnQgaHRtbCBhdHRyaWJ1dGUgdG8gR29vZ2xlIG1hcCBhcGkgb3B0aW9uc1xuICogQHBhcmFtICRjb21waWxlIHtzZXJ2aWNlfSAkY29tcGlsZSBzZXJ2aWNlXG4gKiBAZGVzY3JpcHRpb25cbiAqICBEZWZpbmVzIGluZm9XaW5kb3cgYW5kIHByb3ZpZGVzIGNvbXBpbGUgbWV0aG9kXG4gKlxuICogIFJlcXVpcmVzOiAgbWFwIGRpcmVjdGl2ZVxuICpcbiAqICBSZXN0cmljdCBUbzogIEVsZW1lbnRcbiAqXG4gKiAgTk9URTogdGhpcyBkaXJlY3RpdmUgc2hvdWxkICoqTk9UKiogYmUgdXNlZCB3aXRoIGBuZy1yZXBlYXRgXG4gKiAgYmVjYXVzZSBJbmZvV2luZG93IGl0c2VsZiBpcyBhIHRlbXBsYXRlLCBhbmQgYSB0ZW1wbGF0ZSBtdXN0IGJlXG4gKiAgcmV1c2VkIGJ5IGVhY2ggbWFya2VyLCB0aHVzLCBzaG91bGQgbm90IGJlIHJlZGVmaW5lZCByZXBlYXRlZGx5XG4gKiAgYnkgYG5nLXJlcGVhdGAuXG4gKlxuICogQGF0dHIge0Jvb2xlYW59IHZpc2libGVcbiAqICAgSW5kaWNhdGVzIHRvIHNob3cgaXQgd2hlbiBtYXAgaXMgaW5pdGlhbGl6ZWRcbiAqIEBhdHRyIHtCb29sZWFufSB2aXNpYmxlLW9uLW1hcmtlclxuICogICBJbmRpY2F0ZXMgdG8gc2hvdyBpdCBvbiBhIG1hcmtlciB3aGVuIG1hcCBpcyBpbml0aWFsaXplZFxuICogQGF0dHIge0V4cHJlc3Npb259IGdlby1jYWxsYmFja1xuICogICBpZiBwb3NpdGlvbiBpcyBhbiBhZGRyZXNzLCB0aGUgZXhwcmVzc2lvbiBpcyB3aWxsIGJlIHBlcmZvcm1lZFxuICogICB3aGVuIGdlby1sb29rdXAgaXMgc3VjY2Vzc2Z1bC4gZS5nLiwgZ2VvLWNhbGxiYWNrPVwic2hvd0RldGFpbCgpXCJcbiAqIEBhdHRyIHtTdHJpbmd9ICZsdDtJbmZvV2luZG93T3B0aW9uPiBBbnkgSW5mb1dpbmRvdyBvcHRpb25zLFxuICogICBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2U/Y3N3PTEjSW5mb1dpbmRvd09wdGlvbnNcbiAqIEBhdHRyIHtTdHJpbmd9ICZsdDtJbmZvV2luZG93RXZlbnQ+IEFueSBJbmZvV2luZG93IGV2ZW50cyxcbiAqICAgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvcmVmZXJlbmNlXG4gKiBAZXhhbXBsZVxuICogVXNhZ2U6XG4gKiAgIDxtYXAgTUFQX0FUVFJJQlVURVM+XG4gKiAgICA8aW5mby13aW5kb3cgaWQ9XCJmb29cIiBBTllfT1BUSU9OUyBBTllfRVZFTlRTXCI+PC9pbmZvLXdpbmRvdz5cbiAqICAgPC9tYXA+XG4gKlxuICogRXhhbXBsZTpcbiAqICA8bWFwIGNlbnRlcj1cIjQxLjg1MDAzMywtODcuNjUwMDUyM1wiIHpvb209XCIzXCI+XG4gKiAgICA8aW5mby13aW5kb3cgaWQ9XCIxXCIgcG9zaXRpb249XCI0MS44NTAwMzMsLTg3LjY1MDA1MjNcIiA+XG4gKiAgICAgIDxkaXYgbmctbm9uLWJpbmRhYmxlPlxuICogICAgICAgIENoaWNhZ28sIElMPGJyLz5cbiAqICAgICAgICBMYXRMbmc6IHt7Y2hpY2Fnby5sYXQoKX19LCB7e2NoaWNhZ28ubG5nKCl9fSwgPGJyLz5cbiAqICAgICAgICBXb3JsZCBDb29yZGluYXRlOiB7e3dvcmxkQ29vcmRpbmF0ZS54fX0sIHt7d29ybGRDb29yZGluYXRlLnl9fSwgPGJyLz5cbiAqICAgICAgICBQaXhlbCBDb29yZGluYXRlOiB7e3BpeGVsQ29vcmRpbmF0ZS54fX0sIHt7cGl4ZWxDb29yZGluYXRlLnl9fSwgPGJyLz5cbiAqICAgICAgICBUaWxlIENvb3JkaW5hdGU6IHt7dGlsZUNvb3JkaW5hdGUueH19LCB7e3RpbGVDb29yZGluYXRlLnl9fSBhdCBab29tIExldmVsIHt7bWFwLmdldFpvb20oKX19XG4gKiAgICAgIDwvZGl2PlxuICogICAgPC9pbmZvLXdpbmRvdz5cbiAqICA8L21hcD5cbiAqL1xuLyogZ2xvYmFsIGdvb2dsZSAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGluZm9XaW5kb3cgPSBmdW5jdGlvbihBdHRyMk1hcE9wdGlvbnMsICRjb21waWxlLCAkcSwgJHRlbXBsYXRlUmVxdWVzdCwgJHRpbWVvdXQsICRwYXJzZSwgTmdNYXApICB7XG4gICAgdmFyIHBhcnNlciA9IEF0dHIyTWFwT3B0aW9ucztcblxuICAgIHZhciBnZXRJbmZvV2luZG93ID0gZnVuY3Rpb24ob3B0aW9ucywgZXZlbnRzLCBlbGVtZW50KSB7XG4gICAgICB2YXIgaW5mb1dpbmRvdztcblxuICAgICAgLyoqXG4gICAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAgICovXG4gICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiAmJiAhKG9wdGlvbnMucG9zaXRpb24gaW5zdGFuY2VvZiBnb29nbGUubWFwcy5MYXRMbmcpKSB7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLnBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgaW5mb1dpbmRvdyA9IG5ldyBnb29nbGUubWFwcy5JbmZvV2luZG93KG9wdGlvbnMpO1xuXG4gICAgICAvKipcbiAgICAgICAqIHNldCBldmVudHNcbiAgICAgICAqL1xuICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50cykge1xuICAgICAgICBpZiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5mb1dpbmRvdywgZXZlbnROYW1lLCBldmVudHNbZXZlbnROYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBzZXQgdGVtcGxhdGUgYW5kIHRlbXBsYXRlLXJlbGF0ZWQgZnVuY3Rpb25zXG4gICAgICAgKiBpdCBtdXN0IGhhdmUgYSBjb250YWluZXIgZWxlbWVudCB3aXRoIG5nLW5vbi1iaW5kYWJsZVxuICAgICAgICovXG4gICAgICB2YXIgdGVtcGxhdGVQcm9taXNlID0gJHEoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBpZiAoYW5ndWxhci5pc1N0cmluZyhlbGVtZW50KSkge1xuICAgICAgICAgICR0ZW1wbGF0ZVJlcXVlc3QoZWxlbWVudCkudGhlbihmdW5jdGlvbiAocmVxdWVzdGVkVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJlc29sdmUoYW5ndWxhci5lbGVtZW50KHJlcXVlc3RlZFRlbXBsYXRlKS53cmFwKCc8ZGl2PicpLnBhcmVudCgpKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBcImluZm8td2luZG93IHRlbXBsYXRlIHJlcXVlc3QgZmFpbGVkOiBcIiArIG1lc3NhZ2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSkudGhlbihmdW5jdGlvbihyZXNvbHZlZFRlbXBsYXRlKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IHJlc29sdmVkVGVtcGxhdGUuaHRtbCgpLnRyaW0oKTtcbiAgICAgICAgaWYgKGFuZ3VsYXIuZWxlbWVudCh0ZW1wbGF0ZSkubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICB0aHJvdyBcImluZm8td2luZG93IHdvcmtpbmcgYXMgYSB0ZW1wbGF0ZSBtdXN0IGhhdmUgYSBjb250YWluZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmZvV2luZG93Ll9fdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9cXHM/bmctbm9uLWJpbmRhYmxlWz0nXCJdKy8sXCJcIik7XG4gICAgICB9KTtcblxuICAgICAgaW5mb1dpbmRvdy5fX29wZW4gPSBmdW5jdGlvbihtYXAsIHNjb3BlLCBhbmNob3IpIHtcbiAgICAgICAgdGVtcGxhdGVQcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhbmNob3IgJiYgKHNjb3BlLmFuY2hvciA9IGFuY2hvcik7XG4gICAgICAgICAgICB2YXIgZWwgPSAkY29tcGlsZShpbmZvV2luZG93Ll9fdGVtcGxhdGUpKHNjb3BlKTtcbiAgICAgICAgICAgIGluZm9XaW5kb3cuc2V0Q29udGVudChlbFswXSk7XG4gICAgICAgICAgICBzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgIGlmIChhbmNob3IgJiYgYW5jaG9yLmdldFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIGluZm9XaW5kb3cub3BlbihtYXAsIGFuY2hvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFuY2hvciAmJiBhbmNob3IgaW5zdGFuY2VvZiBnb29nbGUubWFwcy5MYXRMbmcpIHtcbiAgICAgICAgICAgICAgaW5mb1dpbmRvdy5vcGVuKG1hcCk7XG4gICAgICAgICAgICAgIGluZm9XaW5kb3cuc2V0UG9zaXRpb24oYW5jaG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGluZm9XaW5kb3cub3BlbihtYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluZm9XaW5kb3dDb250YWluZXJFbCA9IGluZm9XaW5kb3cuY29udGVudC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGluZm9XaW5kb3dDb250YWluZXJFbC5jbGFzc05hbWUgPSBcIm5nLW1hcC1pbmZvLXdpbmRvd1wiO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBpbmZvV2luZG93O1xuICAgIH07XG5cbiAgICB2YXIgbGlua0Z1bmMgPSBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG1hcENvbnRyb2xsZXIpIHtcbiAgICAgIG1hcENvbnRyb2xsZXIgPSBtYXBDb250cm9sbGVyWzBdfHxtYXBDb250cm9sbGVyWzFdO1xuXG4gICAgICBlbGVtZW50LmNzcygnZGlzcGxheScsJ25vbmUnKTtcblxuICAgICAgdmFyIG9yZ0F0dHJzID0gcGFyc2VyLm9yZ0F0dHJpYnV0ZXMoZWxlbWVudCk7XG4gICAgICB2YXIgZmlsdGVyZWQgPSBwYXJzZXIuZmlsdGVyKGF0dHJzKTtcbiAgICAgIHZhciBvcHRpb25zID0gcGFyc2VyLmdldE9wdGlvbnMoZmlsdGVyZWQsIHtzY29wZTogc2NvcGV9KTtcbiAgICAgIHZhciBldmVudHMgPSBwYXJzZXIuZ2V0RXZlbnRzKHNjb3BlLCBmaWx0ZXJlZCk7XG5cbiAgICAgIHZhciBpbmZvV2luZG93ID0gZ2V0SW5mb1dpbmRvdyhvcHRpb25zLCBldmVudHMsIG9wdGlvbnMudGVtcGxhdGUgfHwgZWxlbWVudCk7XG4gICAgICB2YXIgYWRkcmVzcztcbiAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uICYmICEob3B0aW9ucy5wb3NpdGlvbiBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLkxhdExuZykpIHtcbiAgICAgICAgYWRkcmVzcyA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgICB9XG4gICAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICBOZ01hcC5nZXRHZW9Mb2NhdGlvbihhZGRyZXNzKS50aGVuKGZ1bmN0aW9uKGxhdGxuZykge1xuICAgICAgICAgIGluZm9XaW5kb3cuc2V0UG9zaXRpb24obGF0bG5nKTtcbiAgICAgICAgICBpbmZvV2luZG93Ll9fb3BlbihtYXBDb250cm9sbGVyLm1hcCwgc2NvcGUsIGxhdGxuZyk7XG4gICAgICAgICAgdmFyIGdlb0NhbGxiYWNrID0gYXR0cnMuZ2VvQ2FsbGJhY2s7XG4gICAgICAgICAgZ2VvQ2FsbGJhY2sgJiYgJHBhcnNlKGdlb0NhbGxiYWNrKShzY29wZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBtYXBDb250cm9sbGVyLmFkZE9iamVjdCgnaW5mb1dpbmRvd3MnLCBpbmZvV2luZG93KTtcbiAgICAgIG1hcENvbnRyb2xsZXIub2JzZXJ2ZUF0dHJTZXRPYmoob3JnQXR0cnMsIGF0dHJzLCBpbmZvV2luZG93KTtcblxuICAgICAgbWFwQ29udHJvbGxlci5zaG93SW5mb1dpbmRvdyA9XG4gICAgICBtYXBDb250cm9sbGVyLm1hcC5zaG93SW5mb1dpbmRvdyA9IG1hcENvbnRyb2xsZXIuc2hvd0luZm9XaW5kb3cgfHxcbiAgICAgICAgZnVuY3Rpb24ocDEsIHAyLCBwMykgeyAvL2V2ZW50LCBpZCwgbWFya2VyXG4gICAgICAgICAgdmFyIGlkID0gdHlwZW9mIHAxID09ICdzdHJpbmcnID8gcDEgOiBwMjtcbiAgICAgICAgICB2YXIgbWFya2VyID0gdHlwZW9mIHAxID09ICdzdHJpbmcnID8gcDIgOiBwMztcbiAgICAgICAgICBpZiAodHlwZW9mIG1hcmtlciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy9DaGVjayBpZiBtYXJrZXJzIGlmIGRlZmluZWQgdG8gYXZvaWQgb2RkICd1bmRlZmluZWQnIGVycm9yc1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0eXBlb2YgbWFwQ29udHJvbGxlci5tYXAubWFya2VycyAhPSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICYmIHR5cGVvZiBtYXBDb250cm9sbGVyLm1hcC5tYXJrZXJzW21hcmtlcl0gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IG1hcENvbnRyb2xsZXIubWFwLm1hcmtlcnNbbWFya2VyXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgIC8vYWRkaXRpb25hbGx5IGNoZWNrIGlmIHRoYXQgbWFya2VyIGlzIGEgY3VzdG9tIG1hcmtlclxuICAgICAgICAgICAgICB0eXBlb2YgbWFwQ29udHJvbGxlci5tYXAuY3VzdG9tTWFya2VycyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAmJiB0eXBlb2YgbWFwQ29udHJvbGxlci5tYXAuY3VzdG9tTWFya2Vyc1ttYXJrZXJdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyID0gbWFwQ29udHJvbGxlci5tYXAuY3VzdG9tTWFya2Vyc1ttYXJrZXJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy9CZXR0ZXIgZXJyb3Igb3V0cHV0IGlmIG1hcmtlciB3aXRoIHRoYXQgaWQgaXMgbm90IGRlZmluZWRcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudCBvcGVuIGluZm8gd2luZG93IGZvciBpZCBcIiArIG1hcmtlciArIFwiLiBNYXJrZXIgb3IgQ3VzdG9tTWFya2VyIGlzIG5vdCBkZWZpbmVkXCIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZm9XaW5kb3cgPSBtYXBDb250cm9sbGVyLm1hcC5pbmZvV2luZG93c1tpZF07XG4gICAgICAgICAgdmFyIGFuY2hvciA9IG1hcmtlciA/IG1hcmtlciA6ICh0aGlzLmdldFBvc2l0aW9uID8gdGhpcyA6IG51bGwpO1xuICAgICAgICAgIGluZm9XaW5kb3cuX19vcGVuKG1hcENvbnRyb2xsZXIubWFwLCBzY29wZSwgYW5jaG9yKTtcbiAgICAgICAgICBpZihtYXBDb250cm9sbGVyLnNpbmdsZUluZm9XaW5kb3cpIHtcbiAgICAgICAgICAgIGlmKG1hcENvbnRyb2xsZXIubGFzdEluZm9XaW5kb3cpIHtcbiAgICAgICAgICAgICAgc2NvcGUuaGlkZUluZm9XaW5kb3cobWFwQ29udHJvbGxlci5sYXN0SW5mb1dpbmRvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXBDb250cm9sbGVyLmxhc3RJbmZvV2luZG93ID0gaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICBtYXBDb250cm9sbGVyLmhpZGVJbmZvV2luZG93ID1cbiAgICAgIG1hcENvbnRyb2xsZXIubWFwLmhpZGVJbmZvV2luZG93ID0gbWFwQ29udHJvbGxlci5oaWRlSW5mb1dpbmRvdyB8fFxuICAgICAgICBmdW5jdGlvbihwMSwgcDIpIHtcbiAgICAgICAgICB2YXIgaWQgPSB0eXBlb2YgcDEgPT0gJ3N0cmluZycgPyBwMSA6IHAyO1xuICAgICAgICAgIHZhciBpbmZvV2luZG93ID0gbWFwQ29udHJvbGxlci5tYXAuaW5mb1dpbmRvd3NbaWRdO1xuICAgICAgICAgIGluZm9XaW5kb3cuY2xvc2UoKTtcbiAgICAgICAgfTtcblxuICAgICAgLy9UT0RPIERFUFJFQ0FURURcbiAgICAgIHNjb3BlLnNob3dJbmZvV2luZG93ID0gbWFwQ29udHJvbGxlci5tYXAuc2hvd0luZm9XaW5kb3c7XG4gICAgICBzY29wZS5oaWRlSW5mb1dpbmRvdyA9IG1hcENvbnRyb2xsZXIubWFwLmhpZGVJbmZvV2luZG93O1xuXG4gICAgICB2YXIgbWFwID0gaW5mb1dpbmRvdy5tYXBJZCA/IHtpZDppbmZvV2luZG93Lm1hcElkfSA6IDA7XG4gICAgICBOZ01hcC5nZXRNYXAobWFwKS50aGVuKGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICBpbmZvV2luZG93LnZpc2libGUgJiYgaW5mb1dpbmRvdy5fX29wZW4obWFwLCBzY29wZSk7XG4gICAgICAgIGlmIChpbmZvV2luZG93LnZpc2libGVPbk1hcmtlcikge1xuICAgICAgICAgIHZhciBtYXJrZXJJZCA9IGluZm9XaW5kb3cudmlzaWJsZU9uTWFya2VyO1xuICAgICAgICAgIGluZm9XaW5kb3cuX19vcGVuKG1hcCwgc2NvcGUsIG1hcC5tYXJrZXJzW21hcmtlcklkXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfTsgLy9saW5rXG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgIHJlcXVpcmU6IFsnP15tYXAnLCc/Xm5nTWFwJ10sXG4gICAgICBsaW5rOiBsaW5rRnVuY1xuICAgIH07XG5cbiAgfTsgLy8gaW5mb1dpbmRvd1xuICBpbmZvV2luZG93LiRpbmplY3QgPVxuICAgIFsnQXR0cjJNYXBPcHRpb25zJywgJyRjb21waWxlJywgJyRxJywgJyR0ZW1wbGF0ZVJlcXVlc3QnLCAnJHRpbWVvdXQnLCAnJHBhcnNlJywgJ05nTWFwJ107XG5cbiAgYW5ndWxhci5tb2R1bGUoJ25nTWFwJykuZGlyZWN0aXZlKCdpbmZvV2luZG93JywgaW5mb1dpbmRvdyk7XG59KSgpO1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIGttbC1sYXllclxuICogQHBhcmFtIEF0dHIyTWFwT3B0aW9ucyB7c2VydmljZX0gY29udmVydCBodG1sIGF0dHJpYnV0ZSB0byBHb29nbGUgbWFwIGFwaSBvcHRpb25zXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgcmVuZGVycyBLbWwgbGF5ZXIgb24gYSBtYXBcbiAqICAgUmVxdWlyZXM6ICBtYXAgZGlyZWN0aXZlXG4gKiAgIFJlc3RyaWN0IFRvOiAgRWxlbWVudFxuICpcbiAqIEBhdHRyIHtVcmx9IHVybCB1cmwgb2YgdGhlIGttbCBsYXllclxuICogQGF0dHIge0ttbExheWVyT3B0aW9uc30gS21sTGF5ZXJPcHRpb25zXG4gKiAgIChodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2UjS21sTGF5ZXJPcHRpb25zKSBcbiAqIEBhdHRyIHtTdHJpbmd9ICZsdDtLbWxMYXllckV2ZW50PiBBbnkgS21sTGF5ZXIgZXZlbnRzLFxuICogICBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2VcbiAqIEBleGFtcGxlXG4gKiBVc2FnZTpcbiAqICAgPG1hcCBNQVBfQVRUUklCVVRFUz5cbiAqICAgIDxrbWwtbGF5ZXIgQU5ZX0tNTF9MQVlFUiBBTllfS01MX0xBWUVSX0VWRU5UU1wiPjwva21sLWxheWVyPlxuICogICA8L21hcD5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIDxtYXAgem9vbT1cIjExXCIgY2VudGVyPVwiWzQxLjg3NTY5NiwtODcuNjI0MjA3XVwiPlxuICogICA8a21sLWxheWVyIHVybD1cImh0dHBzOi8vZ21hcHMtc2FtcGxlcy5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvZ2dlb3htbC9jdGEua21sXCIgPlxuICogICA8L2ttbC1sYXllcj5cbiAqIDwvbWFwPlxuICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBhbmd1bGFyLm1vZHVsZSgnbmdNYXAnKS5kaXJlY3RpdmUoJ2ttbExheWVyJywgW1xuICAgICdBdHRyMk1hcE9wdGlvbnMnLCBmdW5jdGlvbihBdHRyMk1hcE9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VyID0gQXR0cjJNYXBPcHRpb25zO1xuXG4gICAgdmFyIGdldEttbExheWVyID0gZnVuY3Rpb24ob3B0aW9ucywgZXZlbnRzKSB7XG4gICAgICB2YXIga21sTGF5ZXIgPSBuZXcgZ29vZ2xlLm1hcHMuS21sTGF5ZXIob3B0aW9ucyk7XG4gICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnRzKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGttbExheWVyLCBldmVudE5hbWUsIGV2ZW50c1tldmVudE5hbWVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrbWxMYXllcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICByZXF1aXJlOiBbJz9ebWFwJywnP15uZ01hcCddLFxuXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG1hcENvbnRyb2xsZXIpIHtcbiAgICAgICAgbWFwQ29udHJvbGxlciA9IG1hcENvbnRyb2xsZXJbMF18fG1hcENvbnRyb2xsZXJbMV07XG5cbiAgICAgICAgdmFyIG9yZ0F0dHJzID0gcGFyc2VyLm9yZ0F0dHJpYnV0ZXMoZWxlbWVudCk7XG4gICAgICAgIHZhciBmaWx0ZXJlZCA9IHBhcnNlci5maWx0ZXIoYXR0cnMpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHBhcnNlci5nZXRPcHRpb25zKGZpbHRlcmVkLCB7c2NvcGU6IHNjb3BlfSk7XG4gICAgICAgIHZhciBldmVudHMgPSBwYXJzZXIuZ2V0RXZlbnRzKHNjb3BlLCBmaWx0ZXJlZCk7XG4gICAgICAgIHZvaWQgMDtcblxuICAgICAgICB2YXIga21sTGF5ZXIgPSBnZXRLbWxMYXllcihvcHRpb25zLCBldmVudHMpO1xuICAgICAgICBtYXBDb250cm9sbGVyLmFkZE9iamVjdCgna21sTGF5ZXJzJywga21sTGF5ZXIpO1xuICAgICAgICBtYXBDb250cm9sbGVyLm9ic2VydmVBdHRyU2V0T2JqKG9yZ0F0dHJzLCBhdHRycywga21sTGF5ZXIpOyAgLy9vYnNlcnZlcnNcbiAgICAgICAgZWxlbWVudC5iaW5kKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG1hcENvbnRyb2xsZXIuZGVsZXRlT2JqZWN0KCdrbWxMYXllcnMnLCBrbWxMYXllcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICB9OyAvLyByZXR1cm5cbiAgfV0pO1xufSkoKTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBtYXAtZGF0YVxuICogQHBhcmFtIEF0dHIyTWFwT3B0aW9ucyB7c2VydmljZX1cbiAqICAgY29udmVydCBodG1sIGF0dHJpYnV0ZSB0byBHb29nbGUgbWFwIGFwaSBvcHRpb25zXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgc2V0IG1hcCBkYXRhXG4gKiAgIFJlcXVpcmVzOiAgbWFwIGRpcmVjdGl2ZVxuICogICBSZXN0cmljdCBUbzogIEVsZW1lbnRcbiAqXG4gKiBAd24ge1N0cmluZ30gbWV0aG9kLW5hbWUsIHJ1biBtYXAuZGF0YVttZXRob2QtbmFtZV0gd2l0aCBhdHRyaWJ1dGUgdmFsdWVcbiAqIEBleGFtcGxlXG4gKiBFeGFtcGxlOlxuICpcbiAqICA8bWFwIHpvb209XCIxMVwiIGNlbnRlcj1cIls0MS44NzU2OTYsLTg3LjYyNDIwN11cIj5cbiAqICAgIDxtYXAtZGF0YSBsb2FkLWdlby1qc29uPVwiaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL21hcHMtZGV2cmVsL2dvb2dsZS5qc29uXCI+PC9tYXAtZGF0YT5cbiAqICAgPC9tYXA+XG4gKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGFuZ3VsYXIubW9kdWxlKCduZ01hcCcpLmRpcmVjdGl2ZSgnbWFwRGF0YScsIFtcbiAgICAnQXR0cjJNYXBPcHRpb25zJywgJ05nTWFwJywgZnVuY3Rpb24oQXR0cjJNYXBPcHRpb25zLCBOZ01hcCkge1xuICAgIHZhciBwYXJzZXIgPSBBdHRyMk1hcE9wdGlvbnM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICByZXF1aXJlOiBbJz9ebWFwJywnP15uZ01hcCddLFxuXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG1hcENvbnRyb2xsZXIpIHtcbiAgICAgICAgbWFwQ29udHJvbGxlciA9IG1hcENvbnRyb2xsZXJbMF0gfHwgbWFwQ29udHJvbGxlclsxXTtcbiAgICAgICAgdmFyIGZpbHRlcmVkID0gcGFyc2VyLmZpbHRlcihhdHRycyk7XG4gICAgICAgIHZhciBvcHRpb25zID0gcGFyc2VyLmdldE9wdGlvbnMoZmlsdGVyZWQsIHtzY29wZTogc2NvcGV9KTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHBhcnNlci5nZXRFdmVudHMoc2NvcGUsIGZpbHRlcmVkLCBldmVudHMpO1xuXG4gICAgICAgIHZvaWQgMDtcbiAgICAgICAgTmdNYXAuZ2V0TWFwKG1hcENvbnRyb2xsZXIubWFwLmlkKS50aGVuKGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgIC8vb3B0aW9uc1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY29wZVt2YWxdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgbWFwLmRhdGFba2V5XShzY29wZVt2YWxdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hcC5kYXRhW2tleV0odmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL2V2ZW50c1xuICAgICAgICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgIG1hcC5kYXRhLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRzW2V2ZW50TmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgIH07IC8vIHJldHVyblxuICB9XSk7XG59KSgpO1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG1hcC1sYXp5LWxvYWRcbiAqIEBwYXJhbSBBdHRyMk9wdGlvbnMge3NlcnZpY2V9IGNvbnZlcnQgaHRtbCBhdHRyaWJ1dGUgdG8gR29vZ2xlIG1hcCBhcGkgb3B0aW9uc1xuICogQGRlc2NyaXB0aW9uXG4gKiAgUmVxdWlyZXM6IERlbGF5IHRoZSBpbml0aWFsaXphdGlvbiBvZiBtYXAgZGlyZWN0aXZlXG4gKiAgICB1bnRpbCB0aGUgbWFwIGlzIHJlYWR5IHRvIGJlIHJlbmRlcmVkXG4gKiAgUmVzdHJpY3QgVG86IEF0dHJpYnV0ZVxuICpcbiAqIEBhdHRyIHtTdHJpbmd9IG1hcC1sYXp5LWxvYWRcbiAqICAgIE1hcHMgYXBpIHNjcmlwdCBzb3VyY2UgZmlsZSBsb2NhdGlvbi5cbiAqICAgIEV4YW1wbGU6XG4gKiAgICAgICdodHRwczovL21hcHMuZ29vZ2xlLmNvbS9tYXBzL2FwaS9qcydcbiAqIEBhdHRyIHtTdHJpbmd9IG1hcC1sYXp5LWxvYWQtcGFyYW1zXG4gKiAgIE1hcHMgYXBpIHNjcmlwdCBzb3VyY2UgZmlsZSBsb2NhdGlvbiB2aWEgYW5ndWxhciBzY29wZSB2YXJpYWJsZS5cbiAqICAgQWxzbyByZXF1aXJlcyB0aGUgbWFwLWxhenktbG9hZCBhdHRyaWJ1dGUgdG8gYmUgcHJlc2VudCBpbiB0aGUgZGlyZWN0aXZlLlxuICogICBFeGFtcGxlOiBJbiB5b3VyIGNvbnRyb2xsZXIsIHNldFxuICogICAgICRzY29wZS5nb29nbGVNYXBzVVJMID0gJ2h0dHBzOi8vbWFwcy5nb29nbGUuY29tL21hcHMvYXBpL2pzP3Y9My4yMCZjbGllbnQ9WFhYWFhlbnRlci1hcGkta2V5LWhlcmVYWFhYJ1xuICpcbiAqIEBleGFtcGxlXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgPGRpdiBtYXAtbGF6eS1sb2FkPVwiaHR0cDovL21hcHMuZ29vZ2xlLmNvbS9tYXBzL2FwaS9qc1wiPlxuICogICAgIDxtYXAgY2VudGVyPVwiQnJhbXB0b25cIiB6b29tPVwiMTBcIj5cbiAqICAgICAgIDxtYXJrZXIgcG9zaXRpb249XCJCcmFtcHRvblwiPjwvbWFya2VyPlxuICogICAgIDwvbWFwPlxuICogICA8L2Rpdj5cbiAqXG4gKiAgIDxkaXYgbWFwLWxhenktbG9hZD1cImh0dHA6Ly9tYXBzLmdvb2dsZS5jb20vbWFwcy9hcGkvanNcIlxuICogICAgICAgIG1hcC1sYXp5LWxvYWQtcGFyYW1zPVwie3tnb29nbGVNYXBzVXJsfX1cIj5cbiAqICAgICA8bWFwIGNlbnRlcj1cIkJyYW1wdG9uXCIgem9vbT1cIjEwXCI+XG4gKiAgICAgICA8bWFya2VyIHBvc2l0aW9uPVwiQnJhbXB0b25cIj48L21hcmtlcj5cbiAqICAgICA8L21hcD5cbiAqICAgPC9kaXY+XG4gKi9cbi8qIGdsb2JhbCB3aW5kb3csIGRvY3VtZW50ICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyICR0aW1lb3V0LCAkY29tcGlsZSwgc3JjLCBzYXZlZEh0bWwgPSBbXSwgZWxlbWVudHMgPSBbXTtcblxuICB2YXIgcHJlTGlua0Z1bmMgPSBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICB2YXIgbWFwc1VybCA9IGF0dHJzLm1hcExhenlMb2FkUGFyYW1zIHx8IGF0dHJzLm1hcExhenlMb2FkO1xuXG4gICAgaWYod2luZG93Lmdvb2dsZSA9PT0gdW5kZWZpbmVkIHx8IHdpbmRvdy5nb29nbGUubWFwcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbGVtZW50cy5wdXNoKHtcbiAgICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBzYXZlZEh0bWw6IHNhdmVkSHRtbFtlbGVtZW50cy5sZW5ndGhdLFxuICAgICAgfSk7XG5cbiAgICAgIHdpbmRvdy5sYXp5TG9hZENhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZvaWQgMDtcbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7IC8qIGdpdmUgc29tZSB0aW1lIHRvIGxvYWQgKi9cbiAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsbSkge1xuICAgICAgICAgICAgICBlbG0uZWxlbWVudC5odG1sKGVsbS5zYXZlZEh0bWwpO1xuICAgICAgICAgICAgICAkY29tcGlsZShlbG0uZWxlbWVudC5jb250ZW50cygpKShlbG0uc2NvcGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCAxMDApO1xuICAgICAgfTtcblxuICAgICAgdmFyIHNjcmlwdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICB2b2lkIDA7XG5cbiAgICAgIHNjcmlwdEVsLnNyYyA9IG1hcHNVcmwgK1xuICAgICAgICAobWFwc1VybC5pbmRleE9mKCc/JykgPiAtMSA/ICcmJyA6ICc/JykgK1xuICAgICAgICAnY2FsbGJhY2s9bGF6eUxvYWRDYWxsYmFjayc7XG5cbiAgICAgICAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzY3JpcHRbc3JjPVwiJyArIHNjcmlwdEVsLnNyYyArICdcIl0nKSkge1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0RWwpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuaHRtbChzYXZlZEh0bWwpO1xuICAgICAgJGNvbXBpbGUoZWxlbWVudC5jb250ZW50cygpKShzY29wZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjb21waWxlRnVuYyA9IGZ1bmN0aW9uKHRFbGVtZW50LCB0QXR0cnMpIHtcblxuICAgICghdEF0dHJzLm1hcExhenlMb2FkKSAmJiB2b2lkIDA7XG4gICAgc2F2ZWRIdG1sLnB1c2godEVsZW1lbnQuaHRtbCgpKTtcbiAgICBzcmMgPSB0QXR0cnMubWFwTGF6eUxvYWQ7XG5cbiAgICAvKipcbiAgICAgKiBpZiBhbHJlYWR5IGxvYWRlZCwgc3RvcCBwcm9jZXNzaW5nIGl0XG4gICAgICovXG4gICAgaWYod2luZG93Lmdvb2dsZSAhPT0gdW5kZWZpbmVkICYmIHdpbmRvdy5nb29nbGUubWFwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdEVsZW1lbnQuaHRtbCgnJyk7ICAvLyB3aWxsIGNvbXBpbGUgYWdhaW4gYWZ0ZXIgc2NyaXB0IGlzIGxvYWRlZFxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHByZTogcHJlTGlua0Z1bmNcbiAgICB9O1xuICB9O1xuXG4gIHZhciBtYXBMYXp5TG9hZCA9IGZ1bmN0aW9uKF8kY29tcGlsZV8sIF8kdGltZW91dF8pIHtcbiAgICAkY29tcGlsZSA9IF8kY29tcGlsZV8sICR0aW1lb3V0ID0gXyR0aW1lb3V0XztcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZTogY29tcGlsZUZ1bmNcbiAgICB9O1xuICB9O1xuICBtYXBMYXp5TG9hZC4kaW5qZWN0ID0gWyckY29tcGlsZScsJyR0aW1lb3V0J107XG5cbiAgYW5ndWxhci5tb2R1bGUoJ25nTWFwJykuZGlyZWN0aXZlKCdtYXBMYXp5TG9hZCcsIG1hcExhenlMb2FkKTtcbn0pKCk7XG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbWFwLXR5cGVcbiAqIEBwYXJhbSBBdHRyMk1hcE9wdGlvbnMge3NlcnZpY2V9IFxuICogICBjb252ZXJ0IGh0bWwgYXR0cmlidXRlIHRvIEdvb2dsZSBtYXAgYXBpIG9wdGlvbnNcbiAqIEBkZXNjcmlwdGlvblxuICogICBSZXF1aXJlczogIG1hcCBkaXJlY3RpdmVcbiAqICAgUmVzdHJpY3QgVG86ICBFbGVtZW50XG4gKlxuICogQGV4YW1wbGVcbiAqIEV4YW1wbGU6XG4gKlxuICogICA8bWFwIHpvb209XCIxM1wiIGNlbnRlcj1cIjM0LjA0OTI0NTk0MTkzMTY0LCAtMTE4LjI0MTA0MzA5MDgyMDMxXCI+XG4gKiAgICAgPG1hcC10eXBlIG5hbWU9XCJjb29yZGluYXRlXCIgb2JqZWN0PVwiY29vcmRpbmF0ZU1hcFR5cGVcIj48L21hcC10eXBlPlxuICogICA8L21hcD5cbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgYW5ndWxhci5tb2R1bGUoJ25nTWFwJykuZGlyZWN0aXZlKCdtYXBUeXBlJywgWyckcGFyc2UnLCAnTmdNYXAnLFxuICAgIGZ1bmN0aW9uKCRwYXJzZSwgTmdNYXApIHtcblxuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgcmVxdWlyZTogWyc/Xm1hcCcsJz9ebmdNYXAnXSxcblxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBtYXBDb250cm9sbGVyKSB7XG4gICAgICAgIG1hcENvbnRyb2xsZXIgPSBtYXBDb250cm9sbGVyWzBdfHxtYXBDb250cm9sbGVyWzFdO1xuXG4gICAgICAgIHZhciBtYXBUeXBlTmFtZSA9IGF0dHJzLm5hbWUsIG1hcFR5cGVPYmplY3Q7XG4gICAgICAgIGlmICghbWFwVHlwZU5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBcImludmFsaWQgbWFwLXR5cGUgbmFtZVwiO1xuICAgICAgICB9XG4gICAgICAgIG1hcFR5cGVPYmplY3QgPSAkcGFyc2UoYXR0cnMub2JqZWN0KShzY29wZSk7XG4gICAgICAgIGlmICghbWFwVHlwZU9iamVjdCkge1xuICAgICAgICAgIHRocm93IFwiaW52YWxpZCBtYXAtdHlwZSBvYmplY3RcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIE5nTWFwLmdldE1hcCgpLnRoZW4oZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgbWFwLm1hcFR5cGVzLnNldChtYXBUeXBlTmFtZSwgbWFwVHlwZU9iamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBtYXBDb250cm9sbGVyLmFkZE9iamVjdCgnbWFwVHlwZXMnLCBtYXBUeXBlT2JqZWN0KTtcbiAgICAgIH1cbiAgICAgfTsgLy8gcmV0dXJuXG4gIH1dKTtcbn0pKCk7XG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG1lbWJlcm9mIG5nTWFwXG4gKiBAbmFtZSBuZy1tYXBcbiAqIEBwYXJhbSBBdHRyMk9wdGlvbnMge3NlcnZpY2V9XG4gKiAgY29udmVydCBodG1sIGF0dHJpYnV0ZSB0byBHb29nbGUgbWFwIGFwaSBvcHRpb25zXG4gKiBAZGVzY3JpcHRpb25cbiAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBfX01hcENvbnRyb2xsZXJ9XG4gKiBJbml0aWFsaXplIGEgR29vZ2xlIG1hcCB3aXRoaW4gYSBgPGRpdj5gIHRhZ1xuICogICB3aXRoIGdpdmVuIG9wdGlvbnMgYW5kIHJlZ2lzdGVyIGV2ZW50c1xuICpcbiAqIEBhdHRyIHtFeHByZXNzaW9ufSBtYXAtaW5pdGlhbGl6ZWRcbiAqICAgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBtYXAgaXMgaW5pdGlhbGl6ZWRcbiAqICAgZS5nLiwgbWFwLWluaXRpYWxpemVkPVwibXljYWxsYmFjayhtYXApXCJcbiAqIEBhdHRyIHtFeHByZXNzaW9ufSBnZW8tY2FsbGJhY2sgaWYgY2VudGVyIGlzIGFuIGFkZHJlc3Mgb3IgY3VycmVudCBsb2NhdGlvbixcbiAqICAgdGhlIGV4cHJlc3Npb24gaXMgd2lsbCBiZSBleGVjdXRlZCB3aGVuIGdlby1sb29rdXAgaXMgc3VjY2Vzc2Z1bC5cbiAqICAgZS5nLiwgZ2VvLWNhbGxiYWNrPVwic2hvd015U3RvcmVJbmZvKClcIlxuICogQGF0dHIge0FycmF5fSBnZW8tZmFsbGJhY2stY2VudGVyXG4gKiAgIFRoZSBjZW50ZXIgb2YgbWFwIGluY2FzZSBnZW9sb2NhdGlvbiBmYWlsZWQuIGkuZS4gWzAsMF1cbiAqIEBhdHRyIHtPYmplY3R9IGdlby1sb2NhdGlvbi1vcHRpb25zXG4gKiAgVGhlIG5hdmlnYXRvciBnZW9sb2NhdGlvbiBvcHRpb25zLlxuICogIGUuZy4sIHsgbWF4aW11bUFnZTogMzAwMCwgdGltZW91dDogNTAwMCwgZW5hYmxlSGlnaEFjY3VyYWN5OiB0cnVlIH0uXG4gKiAgSWYgbm9uZSBzcGVjaWZpZWQsIHsgdGltZW91dDogNTAwMCB9LlxuICogIElmIHRpbWVvdXQgbm90IHNwZWNpZmllZCwgdGltZW91dDogNTAwMCBhZGRlZFxuICogQGF0dHIge0Jvb2xlYW59IHpvb20tdG8taW5jbHVkZS1tYXJrZXJzXG4gKiAgV2hlbiB0cnVlLCBtYXAgYm91bmRhcnkgd2lsbCBiZSBjaGFuZ2VkIGF1dG9tYXRpYWxseVxuICogIHRvIGluY2x1ZGUgYWxsIG1hcmtlcnMgd2hlbiBpbml0aWFsaXplZFxuICogQGF0dHIge0Jvb2xlYW59IGRlZmF1bHQtc3R5bGVcbiAqICBXaGVuIGZhbHNlLCB0aGUgZGVmYXVsdCBzdHlsaW5nLFxuICogIGBkaXNwbGF5OmJsb2NrO2hlaWdodDozMDBweGAsIHdpbGwgYmUgaWdub3JlZC5cbiAqIEBhdHRyIHtTdHJpbmd9ICZsdDtNYXBPcHRpb24+IEFueSBHb29nbGUgbWFwIG9wdGlvbnMsXG4gKiAgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvcmVmZXJlbmNlP2Nzdz0xI01hcE9wdGlvbnNcbiAqIEBhdHRyIHtTdHJpbmd9ICZsdDtNYXBFdmVudD4gQW55IEdvb2dsZSBtYXAgZXZlbnRzLFxuICogIGh0dHBzOi8vcmF3Z2l0LmNvbS9hbGxlbmh3a2ltL2FuZ3VsYXJqcy1nb29nbGUtbWFwcy9tYXN0ZXIvYnVpbGQvbWFwX2V2ZW50cy5odG1sXG4gKiBAYXR0ciB7Qm9vbGVhbn0gc2luZ2xlLWluZm8td2luZG93XG4gKiAgV2hlbiB0cnVlIHRoZSBtYXAgd2lsbCBvbmx5IGRpc3BsYXkgb25lIGluZm8gd2luZG93IGF0IHRoZSB0aW1lLFxuICogIGlmIG5vdCBzZXQgb3IgZmFsc2UsXG4gKiAgZXZlcnl0aW1lIGFuIGluZm8gd2luZG93IGlzIG9wZW4gaXQgd2lsbCBiZSBkaXNwbGF5ZWQgd2l0aCB0aGUgb3RoZSBvbmUuXG4gKiBAYXR0ciB7Qm9vbGVhbn0gdHJpZ2dlci1yZXNpemVcbiAqICBEZWZhdWx0IHRvIGZhbHNlLiAgU2V0IHRvIHRydWUgdG8gdHJpZ2dlciByZXNpemUgb2YgdGhlIG1hcC4gIE5lZWRzIHRvIGJlIGRvbmUgYW55dGltZSB5b3UgcmVzaXplIHRoZSBtYXBcbiAqIEBleGFtcGxlXG4gKiBVc2FnZTpcbiAqICAgPG1hcCBNQVBfT1BUSU9OU19PUl9NQVBfRVZFTlRTIC4uPlxuICogICAgIC4uLiBBbnkgY2hpbGRyZW4gZGlyZWN0aXZlc1xuICogICA8L21hcD5cbiAqXG4gKiBFeGFtcGxlOlxuICogICA8bWFwIGNlbnRlcj1cIls0MC43NCwgLTc0LjE4XVwiIG9uLWNsaWNrPVwiZG9UaGF0KClcIj5cbiAqICAgPC9tYXA+XG4gKlxuICogICA8bWFwIGdlby1mYWxsYmFjay1jZW50ZXI9XCJbNDAuNzQsIC03NC4xOF1cIiB6b29tLXRvLWlubHVkZS1tYXJrZXJzPVwidHJ1ZVwiPlxuICogICA8L21hcD5cbiAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBtYXBEaXJlY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnQUUnLFxuICAgICAgY29udHJvbGxlcjogJ19fTWFwQ29udHJvbGxlcicsXG4gICAgICBjb250cm9sbGVyQXM6ICduZ21hcCdcbiAgICB9O1xuICB9O1xuXG4gIGFuZ3VsYXIubW9kdWxlKCduZ01hcCcpLmRpcmVjdGl2ZSgnbWFwJywgW21hcERpcmVjdGl2ZV0pO1xuICBhbmd1bGFyLm1vZHVsZSgnbmdNYXAnKS5kaXJlY3RpdmUoJ25nTWFwJywgW21hcERpcmVjdGl2ZV0pO1xufSkoKTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBtYXBzLWVuZ2luZS1sYXllclxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFJlcXVpcmVzOiAgbWFwIGRpcmVjdGl2ZVxuICogICBSZXN0cmljdCBUbzogIEVsZW1lbnRcbiAqXG4gKiBAZXhhbXBsZVxuICogRXhhbXBsZTpcbiAqICA8bWFwIHpvb209XCIxNFwiIGNlbnRlcj1cIls1OS4zMjI1MDYsIDE4LjAxMDAyNV1cIj5cbiAqICAgIDxtYXBzLWVuZ2luZS1sYXllciBsYXllci1pZD1cIjA2NjczMDU2NDU0MDQ2MTM1NTM3LTA4ODk2NTAxOTk3NzY2NTUzODExXCI+XG4gKiAgICA8L21hcHMtZW5naW5lLWxheWVyPlxuICogIDwvbWFwPlxuICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBhbmd1bGFyLm1vZHVsZSgnbmdNYXAnKS5kaXJlY3RpdmUoJ21hcHNFbmdpbmVMYXllcicsIFsnQXR0cjJNYXBPcHRpb25zJywgZnVuY3Rpb24oQXR0cjJNYXBPcHRpb25zKSB7XG4gICAgdmFyIHBhcnNlciA9IEF0dHIyTWFwT3B0aW9ucztcblxuICAgIHZhciBnZXRNYXBzRW5naW5lTGF5ZXIgPSBmdW5jdGlvbihvcHRpb25zLCBldmVudHMpIHtcbiAgICAgIHZhciBsYXllciA9IG5ldyBnb29nbGUubWFwcy52aXN1YWxpemF0aW9uLk1hcHNFbmdpbmVMYXllcihvcHRpb25zKTtcblxuICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50cykge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihsYXllciwgZXZlbnROYW1lLCBldmVudHNbZXZlbnROYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICByZXF1aXJlOiBbJz9ebWFwJywnP15uZ01hcCddLFxuXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG1hcENvbnRyb2xsZXIpIHtcbiAgICAgICAgbWFwQ29udHJvbGxlciA9IG1hcENvbnRyb2xsZXJbMF18fG1hcENvbnRyb2xsZXJbMV07XG5cbiAgICAgICAgdmFyIGZpbHRlcmVkID0gcGFyc2VyLmZpbHRlcihhdHRycyk7XG4gICAgICAgIHZhciBvcHRpb25zID0gcGFyc2VyLmdldE9wdGlvbnMoZmlsdGVyZWQsIHtzY29wZTogc2NvcGV9KTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHBhcnNlci5nZXRFdmVudHMoc2NvcGUsIGZpbHRlcmVkLCBldmVudHMpO1xuICAgICAgICB2b2lkIDA7XG5cbiAgICAgICAgdmFyIGxheWVyID0gZ2V0TWFwc0VuZ2luZUxheWVyKG9wdGlvbnMsIGV2ZW50cyk7XG4gICAgICAgIG1hcENvbnRyb2xsZXIuYWRkT2JqZWN0KCdtYXBzRW5naW5lTGF5ZXJzJywgbGF5ZXIpO1xuICAgICAgfVxuICAgICB9OyAvLyByZXR1cm5cbiAgfV0pO1xufSkoKTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBtYXJrZXJcbiAqIEBwYXJhbSBBdHRyMk9wdGlvbnMge3NlcnZpY2V9IGNvbnZlcnQgaHRtbCBhdHRyaWJ1dGUgdG8gR29vZ2xlIG1hcCBhcGkgb3B0aW9uc1xuICogQHBhcmFtIE5hdmlnYXRvckdlb2xvY2F0aW9uIEl0IGlzIHVzZWQgdG8gZmluZCB0aGUgY3VycmVudCBsb2NhdGlvblxuICogQGRlc2NyaXB0aW9uXG4gKiAgRHJhdyBhIEdvb2dsZSBtYXAgbWFya2VyIG9uIGEgbWFwIHdpdGggZ2l2ZW4gb3B0aW9ucyBhbmQgcmVnaXN0ZXIgZXZlbnRzXG4gKlxuICogIFJlcXVpcmVzOiAgbWFwIGRpcmVjdGl2ZVxuICpcbiAqICBSZXN0cmljdCBUbzogIEVsZW1lbnRcbiAqXG4gKiBAYXR0ciB7U3RyaW5nfSBwb3NpdGlvbiBhZGRyZXNzLCAnY3VycmVudCcsIG9yIFtsYXRpdHVkZSwgbG9uZ2l0dWRlXVxuICogIGV4YW1wbGU6XG4gKiAgICAnMTYwMCBQZW5uc3lsdmFuaWEgQXZlLCAyMDUwMCAgV2FzaGluZ3Rpb24gREMnLFxuICogICAgJ2N1cnJlbnQgcG9zaXRpb24nLFxuICogICAgJ1s0MC43NCwgLTc0LjE4XSdcbiAqIEBhdHRyIHtCb29sZWFufSBjZW50ZXJlZCBpZiBzZXQsIG1hcCB3aWxsIGJlIGNlbnRlcmVkIHdpdGggdGhpcyBtYXJrZXJcbiAqIEBhdHRyIHtFeHByZXNzaW9ufSBnZW8tY2FsbGJhY2sgaWYgcG9zaXRpb24gaXMgYW4gYWRkcmVzcyxcbiAqICAgdGhlIGV4cHJlc3Npb24gaXMgd2lsbCBiZSBwZXJmb3JtZWQgd2hlbiBnZW8tbG9va3VwIGlzIHN1Y2Nlc3NmdWwuXG4gKiAgIGUuZy4sIGdlby1jYWxsYmFjaz1cInNob3dTdG9yZUluZm8oKVwiXG4gKiBAYXR0ciB7Qm9vbGVhbn0gbm8td2F0Y2hlciBpZiB0cnVlLCBubyBhdHRyaWJ1dGUgb2JzZXJ2ZXIgaXMgYWRkZWQuXG4gKiAgIFVzZWZ1bCBmb3IgbWFueSBuZy1yZXBlYXRcbiAqIEBhdHRyIHtTdHJpbmd9ICZsdDtNYXJrZXJPcHRpb24+XG4gKiAgIFtBbnkgTWFya2VyIG9wdGlvbnNdKGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L3JlZmVyZW5jZT9jc3c9MSNNYXJrZXJPcHRpb25zKVxuICogQGF0dHIge1N0cmluZ30gJmx0O01hcEV2ZW50PlxuICogICBbQW55IE1hcmtlciBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L3JlZmVyZW5jZSlcbiAqIEBleGFtcGxlXG4gKiBVc2FnZTpcbiAqICAgPG1hcCBNQVBfQVRUUklCVVRFUz5cbiAqICAgIDxtYXJrZXIgQU5ZX01BUktFUl9PUFRJT05TIEFOWV9NQVJLRVJfRVZFTlRTXCI+PC9NQVJLRVI+XG4gKiAgIDwvbWFwPlxuICpcbiAqIEV4YW1wbGU6XG4gKiAgIDxtYXAgY2VudGVyPVwiWzQwLjc0LCAtNzQuMThdXCI+XG4gKiAgICA8bWFya2VyIHBvc2l0aW9uPVwiWzQwLjc0LCAtNzQuMThdXCIgb24tY2xpY2s9XCJteWZ1bmMoKVwiPjwvZGl2PlxuICogICA8L21hcD5cbiAqXG4gKiAgIDxtYXAgY2VudGVyPVwidGhlIGNuIHRvd2VyXCI+XG4gKiAgICA8bWFya2VyIHBvc2l0aW9uPVwidGhlIGNuIHRvd2VyXCIgb24tY2xpY2s9XCJteWZ1bmMoKVwiPjwvZGl2PlxuICogICA8L21hcD5cbiAqL1xuLyogZ2xvYmFsIGdvb2dsZSAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBwYXJzZXIsICRwYXJzZSwgTmdNYXA7XG5cbiAgdmFyIGdldE1hcmtlciA9IGZ1bmN0aW9uKG9wdGlvbnMsIGV2ZW50cykge1xuICAgIHZhciBtYXJrZXI7XG5cbiAgICBpZiAoTmdNYXAuZGVmYXVsdE9wdGlvbnMubWFya2VyKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gTmdNYXAuZGVmYXVsdE9wdGlvbnMubWFya2VyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1trZXldID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdm9pZCAwO1xuICAgICAgICAgIG9wdGlvbnNba2V5XSA9IE5nTWFwLmRlZmF1bHRPcHRpb25zLm1hcmtlcltrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEob3B0aW9ucy5wb3NpdGlvbiBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLkxhdExuZykpIHtcbiAgICAgIG9wdGlvbnMucG9zaXRpb24gPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKDAsMCk7XG4gICAgfVxuICAgIG1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIob3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgZXZlbnRzXG4gICAgICovXG4gICAgaWYgKE9iamVjdC5rZXlzKGV2ZW50cykubGVuZ3RoID4gMCkge1xuICAgICAgdm9pZCAwO1xuICAgIH1cbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnRzKSB7XG4gICAgICBpZiAoZXZlbnROYW1lKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgZXZlbnROYW1lLCBldmVudHNbZXZlbnROYW1lXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmtlcjtcbiAgfTtcblxuICB2YXIgbGlua0Z1bmMgPSBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG1hcENvbnRyb2xsZXIpIHtcbiAgICBtYXBDb250cm9sbGVyID0gbWFwQ29udHJvbGxlclswXXx8bWFwQ29udHJvbGxlclsxXTtcblxuICAgIHZhciBvcmdBdHRycyA9IHBhcnNlci5vcmdBdHRyaWJ1dGVzKGVsZW1lbnQpO1xuICAgIHZhciBmaWx0ZXJlZCA9IHBhcnNlci5maWx0ZXIoYXR0cnMpO1xuICAgIHZhciBtYXJrZXJPcHRpb25zID0gcGFyc2VyLmdldE9wdGlvbnMoZmlsdGVyZWQsIHNjb3BlLCB7c2NvcGU6IHNjb3BlfSk7XG4gICAgdmFyIG1hcmtlckV2ZW50cyA9IHBhcnNlci5nZXRFdmVudHMoc2NvcGUsIGZpbHRlcmVkKTtcbiAgICB2b2lkIDA7XG5cbiAgICB2YXIgYWRkcmVzcztcbiAgICBpZiAoIShtYXJrZXJPcHRpb25zLnBvc2l0aW9uIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTGF0TG5nKSkge1xuICAgICAgYWRkcmVzcyA9IG1hcmtlck9wdGlvbnMucG9zaXRpb247XG4gICAgfVxuICAgIHZhciBtYXJrZXIgPSBnZXRNYXJrZXIobWFya2VyT3B0aW9ucywgbWFya2VyRXZlbnRzKTtcbiAgICBtYXBDb250cm9sbGVyLmFkZE9iamVjdCgnbWFya2VycycsIG1hcmtlcik7XG4gICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgIE5nTWFwLmdldEdlb0xvY2F0aW9uKGFkZHJlc3MpLnRoZW4oZnVuY3Rpb24obGF0bG5nKSB7XG4gICAgICAgIG1hcmtlci5zZXRQb3NpdGlvbihsYXRsbmcpO1xuICAgICAgICBtYXJrZXJPcHRpb25zLmNlbnRlcmVkICYmIG1hcmtlci5tYXAuc2V0Q2VudGVyKGxhdGxuZyk7XG4gICAgICAgIHZhciBnZW9DYWxsYmFjayA9IGF0dHJzLmdlb0NhbGxiYWNrO1xuICAgICAgICBnZW9DYWxsYmFjayAmJiAkcGFyc2UoZ2VvQ2FsbGJhY2spKHNjb3BlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vc2V0IG9ic2VydmVyc1xuICAgIG1hcENvbnRyb2xsZXIub2JzZXJ2ZUF0dHJTZXRPYmoob3JnQXR0cnMsIGF0dHJzLCBtYXJrZXIpOyAvKiBvYnNlcnZlcnMgKi9cblxuICAgIGVsZW1lbnQuYmluZCgnJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgIG1hcENvbnRyb2xsZXIuZGVsZXRlT2JqZWN0KCdtYXJrZXJzJywgbWFya2VyKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgbWFya2VyID0gZnVuY3Rpb24oQXR0cjJNYXBPcHRpb25zLCBfJHBhcnNlXywgX05nTWFwXykge1xuICAgIHBhcnNlciA9IEF0dHIyTWFwT3B0aW9ucztcbiAgICAkcGFyc2UgPSBfJHBhcnNlXztcbiAgICBOZ01hcCA9IF9OZ01hcF87XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgIHJlcXVpcmU6IFsnXj9tYXAnLCc/Xm5nTWFwJ10sXG4gICAgICBsaW5rOiBsaW5rRnVuY1xuICAgIH07XG4gIH07XG5cbiAgbWFya2VyLiRpbmplY3QgPSBbJ0F0dHIyTWFwT3B0aW9ucycsICckcGFyc2UnLCAnTmdNYXAnXTtcbiAgYW5ndWxhci5tb2R1bGUoJ25nTWFwJykuZGlyZWN0aXZlKCdtYXJrZXInLCBtYXJrZXIpO1xuXG59KSgpO1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG92ZXJsYXktbWFwLXR5cGVcbiAqIEBwYXJhbSBBdHRyMk1hcE9wdGlvbnMge3NlcnZpY2V9IGNvbnZlcnQgaHRtbCBhdHRyaWJ1dGUgdG8gR29vZ2xlIG1hcCBhcGkgb3B0aW9uc1xuICogQHBhcmFtICR3aW5kb3cge3NlcnZpY2V9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgUmVxdWlyZXM6ICBtYXAgZGlyZWN0aXZlXG4gKiAgIFJlc3RyaWN0IFRvOiAgRWxlbWVudFxuICpcbiAqIEBleGFtcGxlXG4gKiBFeGFtcGxlOlxuICpcbiAqIDxtYXAgem9vbT1cIjEzXCIgY2VudGVyPVwiMzQuMDQ5MjQ1OTQxOTMxNjQsIC0xMTguMjQxMDQzMDkwODIwMzFcIj5cbiAqICAgPG92ZXJsYXktbWFwLXR5cGUgaW5kZXg9XCIwXCIgb2JqZWN0PVwiY29vcmRpbmF0ZU1hcFR5cGVcIj48L21hcC10eXBlPlxuICogPC9tYXA+XG4gKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGFuZ3VsYXIubW9kdWxlKCduZ01hcCcpLmRpcmVjdGl2ZSgnb3ZlcmxheU1hcFR5cGUnLCBbXG4gICAgJ05nTWFwJywgZnVuY3Rpb24oTmdNYXApIHtcblxuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgcmVxdWlyZTogWyc/Xm1hcCcsJz9ebmdNYXAnXSxcblxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBtYXBDb250cm9sbGVyKSB7XG4gICAgICAgIG1hcENvbnRyb2xsZXIgPSBtYXBDb250cm9sbGVyWzBdfHxtYXBDb250cm9sbGVyWzFdO1xuXG4gICAgICAgIHZhciBpbml0TWV0aG9kID0gYXR0cnMuaW5pdE1ldGhvZCB8fCBcImluc2VydEF0XCI7XG4gICAgICAgIHZhciBvdmVybGF5TWFwVHlwZU9iamVjdCA9IHNjb3BlW2F0dHJzLm9iamVjdF07XG5cbiAgICAgICAgTmdNYXAuZ2V0TWFwKCkudGhlbihmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICBpZiAoaW5pdE1ldGhvZCA9PSBcImluc2VydEF0XCIpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGF0dHJzLmluZGV4LCAxMCk7XG4gICAgICAgICAgICBtYXAub3ZlcmxheU1hcFR5cGVzLmluc2VydEF0KGluZGV4LCBvdmVybGF5TWFwVHlwZU9iamVjdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbml0TWV0aG9kID09IFwicHVzaFwiKSB7XG4gICAgICAgICAgICBtYXAub3ZlcmxheU1hcFR5cGVzLnB1c2gob3ZlcmxheU1hcFR5cGVPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1hcENvbnRyb2xsZXIuYWRkT2JqZWN0KCdvdmVybGF5TWFwVHlwZXMnLCBvdmVybGF5TWFwVHlwZU9iamVjdCk7XG4gICAgICB9XG4gICAgIH07IC8vIHJldHVyblxuICB9XSk7XG59KSgpO1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIHBsYWNlcy1hdXRvLWNvbXBsZXRlXG4gKiBAcGFyYW0gQXR0cjJNYXBPcHRpb25zIHtzZXJ2aWNlfSBjb252ZXJ0IGh0bWwgYXR0cmlidXRlIHRvIEdvb2dsZSBtYXAgYXBpIG9wdGlvbnNcbiAqIEBkZXNjcmlwdGlvblxuICogICBQcm92aWRlcyBhZGRyZXNzIGF1dG8gY29tcGxldGUgZmVhdHVyZSB0byBhbiBpbnB1dCBlbGVtZW50XG4gKiAgIFJlcXVpcmVzOiBpbnB1dCB0YWdcbiAqICAgUmVzdHJpY3QgVG86IEF0dHJpYnV0ZVxuICpcbiAqIEBhdHRyIHtBdXRvQ29tcGxldGVPcHRpb25zfVxuICogICBbQW55IEF1dG9jb21wbGV0ZU9wdGlvbnNdKGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0LzMuZXhwL3JlZmVyZW5jZSNBdXRvY29tcGxldGVPcHRpb25zKVxuICpcbiAqIEBleGFtcGxlXG4gKiBFeGFtcGxlOlxuICogICA8c2NyaXB0IHNyYz1cImh0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qcz9saWJyYXJpZXM9cGxhY2VzXCI+PC9zY3JpcHQ+XG4gKiAgIDxpbnB1dCBwbGFjZXMtYXV0by1jb21wbGV0ZSB0eXBlcz1cIlsnZ2VvY29kZSddXCIgb24tcGxhY2UtY2hhbmdlZD1cIm15Q2FsbGJhY2socGxhY2UpXCIgY29tcG9uZW50LXJlc3RyaWN0aW9ucz1cIntjb3VudHJ5OidhdSd9XCIvPlxuICovXG4vKiBnbG9iYWwgZ29vZ2xlICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgcGxhY2VzQXV0b0NvbXBsZXRlID0gZnVuY3Rpb24oQXR0cjJNYXBPcHRpb25zLCAkdGltZW91dCkge1xuICAgIHZhciBwYXJzZXIgPSBBdHRyMk1hcE9wdGlvbnM7XG5cbiAgICB2YXIgbGlua0Z1bmMgPSBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWxDdHJsKSB7XG4gICAgICBpZiAoYXR0cnMucGxhY2VzQXV0b0NvbXBsZXRlID09PSdmYWxzZScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGZpbHRlcmVkID0gcGFyc2VyLmZpbHRlcihhdHRycyk7XG4gICAgICB2YXIgb3B0aW9ucyA9IHBhcnNlci5nZXRPcHRpb25zKGZpbHRlcmVkLCB7c2NvcGU6IHNjb3BlfSk7XG4gICAgICB2YXIgZXZlbnRzID0gcGFyc2VyLmdldEV2ZW50cyhzY29wZSwgZmlsdGVyZWQpO1xuICAgICAgdmFyIGF1dG9jb21wbGV0ZSA9IG5ldyBnb29nbGUubWFwcy5wbGFjZXMuQXV0b2NvbXBsZXRlKGVsZW1lbnRbMF0sIG9wdGlvbnMpO1xuICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50cykge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihhdXRvY29tcGxldGUsIGV2ZW50TmFtZSwgZXZlbnRzW2V2ZW50TmFtZV0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlTW9kZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICBuZ01vZGVsQ3RybCAmJiBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKGVsZW1lbnQudmFsKCkpO1xuICAgICAgICB9LDEwMCk7XG4gICAgICB9O1xuICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoYXV0b2NvbXBsZXRlLCAncGxhY2VfY2hhbmdlZCcsIHVwZGF0ZU1vZGVsKTtcbiAgICAgIGVsZW1lbnRbMF0uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlTW9kZWwpO1xuXG4gICAgICBhdHRycy4kb2JzZXJ2ZSgndHlwZXMnLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgIHZhciBvcHRpb25WYWx1ZSA9IHBhcnNlci50b09wdGlvblZhbHVlKHZhbCwge2tleTogJ3R5cGVzJ30pO1xuICAgICAgICAgIGF1dG9jb21wbGV0ZS5zZXRUeXBlcyhvcHRpb25WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXHQgIFxuXHQgIGF0dHJzLiRvYnNlcnZlKCdjb21wb25lbnRSZXN0cmljdGlvbnMnLCBmdW5jdGlvbiAodmFsKSB7XG5cdFx0IGlmICh2YWwpIHtcblx0XHQgICBhdXRvY29tcGxldGUuc2V0Q29tcG9uZW50UmVzdHJpY3Rpb25zKHNjb3BlLiRldmFsKHZhbCkpO1xuXHRcdCB9XG5cdCAgIH0pO1xuICAgIH07XG5cdFxuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgcmVxdWlyZTogJz9uZ01vZGVsJyxcbiAgICAgIGxpbms6IGxpbmtGdW5jXG4gICAgfTtcbiAgfTtcblxuICBwbGFjZXNBdXRvQ29tcGxldGUuJGluamVjdCA9IFsnQXR0cjJNYXBPcHRpb25zJywgJyR0aW1lb3V0J107XG4gIGFuZ3VsYXIubW9kdWxlKCduZ01hcCcpLmRpcmVjdGl2ZSgncGxhY2VzQXV0b0NvbXBsZXRlJywgcGxhY2VzQXV0b0NvbXBsZXRlKTtcbn0pKCk7XG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgc2hhcGVcbiAqIEBwYXJhbSBBdHRyMk1hcE9wdGlvbnMge3NlcnZpY2V9IGNvbnZlcnQgaHRtbCBhdHRyaWJ1dGUgdG8gR29vZ2xlIG1hcCBhcGkgb3B0aW9uc1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIEluaXRpYWxpemUgYSBHb29nbGUgbWFwIHNoYXBlIGluIG1hcCB3aXRoIGdpdmVuIG9wdGlvbnMgYW5kIHJlZ2lzdGVyIGV2ZW50c1xuICogICBUaGUgc2hhcGVzIGFyZTpcbiAqICAgICAuIGNpcmNsZVxuICogICAgIC4gcG9seWdvblxuICogICAgIC4gcG9seWxpbmVcbiAqICAgICAuIHJlY3RhbmdsZVxuICogICAgIC4gZ3JvdW5kT3ZlcmxheShvciBpbWFnZSlcbiAqXG4gKiAgIFJlcXVpcmVzOiAgbWFwIGRpcmVjdGl2ZVxuICpcbiAqICAgUmVzdHJpY3QgVG86ICBFbGVtZW50XG4gKlxuICogQGF0dHIge0Jvb2xlYW59IGNlbnRlcmVkIGlmIHNldCwgbWFwIHdpbGwgYmUgY2VudGVyZWQgd2l0aCB0aGlzIG1hcmtlclxuICogQGF0dHIge0V4cHJlc3Npb259IGdlby1jYWxsYmFjayBpZiBzaGFwZSBpcyBhIGNpcmNsZSBhbmQgdGhlIGNlbnRlciBpc1xuICogICBhbiBhZGRyZXNzLCB0aGUgZXhwcmVzc2lvbiBpcyB3aWxsIGJlIHBlcmZvcm1lZCB3aGVuIGdlby1sb29rdXBcbiAqICAgaXMgc3VjY2Vzc2Z1bC4gZS5nLiwgZ2VvLWNhbGxiYWNrPVwic2hvd0RldGFpbCgpXCJcbiAqIEBhdHRyIHtTdHJpbmd9ICZsdDtPUFRJT05TPlxuICogICBGb3IgY2lyY2xlLCBbYW55IGNpcmNsZSBvcHRpb25zXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2UjQ2lyY2xlT3B0aW9ucylcbiAqICAgRm9yIHBvbHlnb24sIFthbnkgcG9seWdvbiBvcHRpb25zXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2UjUG9seWdvbk9wdGlvbnMpXG4gKiAgIEZvciBwb2x5bGluZSwgW2FueSBwb2x5bGluZSBvcHRpb25zXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2UjUG9seWxpbmVPcHRpb25zKVxuICogICBGb3IgcmVjdGFuZ2xlLCBbYW55IHJlY3RhbmdsZSBvcHRpb25zXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2UjUmVjdGFuZ2xlT3B0aW9ucylcbiAqICAgRm9yIGltYWdlLCBbYW55IGdyb3VuZE92ZXJsYXkgb3B0aW9uc10oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvcmVmZXJlbmNlI0dyb3VuZE92ZXJsYXlPcHRpb25zKVxuICogQGF0dHIge1N0cmluZ30gJmx0O01hcEV2ZW50PiBbQW55IFNoYXBlIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvcmVmZXJlbmNlKVxuICogQGV4YW1wbGVcbiAqIFVzYWdlOlxuICogICA8bWFwIE1BUF9BVFRSSUJVVEVTPlxuICogICAgPHNoYXBlIG5hbWU9U0hBUEVfTkFNRSBBTllfU0hBUEVfT1BUSU9OUyBBTllfU0hBUEVfRVZFTlRTXCI+PC9NQVJLRVI+XG4gKiAgIDwvbWFwPlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICA8bWFwIHpvb209XCIxMVwiIGNlbnRlcj1cIls0MC43NCwgLTc0LjE4XVwiPlxuICogICAgIDxzaGFwZSBpZD1cInBvbHlsaW5lXCIgbmFtZT1cInBvbHlsaW5lXCIgZ2VvZGVzaWM9XCJ0cnVlXCJcbiAqICAgICAgIHN0cm9rZS1jb2xvcj1cIiNGRjAwMDBcIiBzdHJva2Utb3BhY2l0eT1cIjEuMFwiIHN0cm9rZS13ZWlnaHQ9XCIyXCJcbiAqICAgICAgIHBhdGg9XCJbWzQwLjc0LC03NC4xOF0sWzQwLjY0LC03NC4xMF0sWzQwLjU0LC03NC4wNV0sWzQwLjQ0LC03NF1dXCIgPlxuICogICAgIDwvc2hhcGU+XG4gKiAgIDwvbWFwPlxuICpcbiAqICAgPG1hcCB6b29tPVwiMTFcIiBjZW50ZXI9XCJbNDAuNzQsIC03NC4xOF1cIj5cbiAqICAgICA8c2hhcGUgaWQ9XCJwb2x5Z29uXCIgbmFtZT1cInBvbHlnb25cIiBzdHJva2UtY29sb3I9XCIjRkYwMDAwXCJcbiAqICAgICAgIHN0cm9rZS1vcGFjaXR5PVwiMS4wXCIgc3Ryb2tlLXdlaWdodD1cIjJcIlxuICogICAgICAgcGF0aHM9XCJbWzQwLjc0LC03NC4xOF0sWzQwLjY0LC03NC4xOF0sWzQwLjg0LC03NC4wOF0sWzQwLjc0LC03NC4xOF1dXCIgPlxuICogICAgIDwvc2hhcGU+XG4gKiAgIDwvbWFwPlxuICpcbiAqICAgPG1hcCB6b29tPVwiMTFcIiBjZW50ZXI9XCJbNDAuNzQsIC03NC4xOF1cIj5cbiAqICAgICA8c2hhcGUgaWQ9XCJyZWN0YW5nbGVcIiBuYW1lPVwicmVjdGFuZ2xlXCIgc3Ryb2tlLWNvbG9yPScjRkYwMDAwJ1xuICogICAgICAgc3Ryb2tlLW9wYWNpdHk9XCIwLjhcIiBzdHJva2Utd2VpZ2h0PVwiMlwiXG4gKiAgICAgICBib3VuZHM9XCJbWzQwLjc0LC03NC4xOF0sIFs0MC43OCwtNzQuMTRdXVwiIGVkaXRhYmxlPVwidHJ1ZVwiID5cbiAqICAgICA8L3NoYXBlPlxuICogICA8L21hcD5cbiAqXG4gKiAgIDxtYXAgem9vbT1cIjExXCIgY2VudGVyPVwiWzQwLjc0LCAtNzQuMThdXCI+XG4gKiAgICAgPHNoYXBlIGlkPVwiY2lyY2xlXCIgbmFtZT1cImNpcmNsZVwiIHN0cm9rZS1jb2xvcj0nI0ZGMDAwMCdcbiAqICAgICAgIHN0cm9rZS1vcGFjaXR5PVwiMC44XCJzdHJva2Utd2VpZ2h0PVwiMlwiXG4gKiAgICAgICBjZW50ZXI9XCJbNDAuNzAsLTc0LjE0XVwiIHJhZGl1cz1cIjQwMDBcIiBlZGl0YWJsZT1cInRydWVcIiA+XG4gKiAgICAgPC9zaGFwZT5cbiAqICAgPC9tYXA+XG4gKlxuICogICA8bWFwIHpvb209XCIxMVwiIGNlbnRlcj1cIls0MC43NCwgLTc0LjE4XVwiPlxuICogICAgIDxzaGFwZSBpZD1cImltYWdlXCIgbmFtZT1cImltYWdlXCJcbiAqICAgICAgIHVybD1cImh0dHBzOi8vd3d3LmxpYi51dGV4YXMuZWR1L21hcHMvaGlzdG9yaWNhbC9uZXdhcmtfbmpfMTkyMi5qcGdcIlxuICogICAgICAgYm91bmRzPVwiW1s0MC43MSwtNzQuMjJdLFs0MC43NywtNzQuMTJdXVwiIG9wYWNpdHk9XCIwLjdcIlxuICogICAgICAgY2xpY2thYmxlPVwidHJ1ZVwiPlxuICogICAgIDwvc2hhcGU+XG4gKiAgIDwvbWFwPlxuICpcbiAqICBGb3IgZnVsbC13b3JraW5nIGV4YW1wbGUsIHBsZWFzZSB2aXNpdFxuICogICAgW3NoYXBlIGV4YW1wbGVdKGh0dHBzOi8vcmF3Z2l0LmNvbS9hbGxlbmh3a2ltL2FuZ3VsYXJqcy1nb29nbGUtbWFwcy9tYXN0ZXIvYnVpbGQvc2hhcGUuaHRtbClcbiAqL1xuLyogZ2xvYmFsIGdvb2dsZSAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGdldFNoYXBlID0gZnVuY3Rpb24ob3B0aW9ucywgZXZlbnRzKSB7XG4gICAgdmFyIHNoYXBlO1xuXG4gICAgdmFyIHNoYXBlTmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICBkZWxldGUgb3B0aW9ucy5uYW1lOyAgLy9yZW1vdmUgbmFtZSBiY296IGl0J3Mgbm90IGZvciBvcHRpb25zXG4gICAgdm9pZCAwO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKi9cbiAgICBzd2l0Y2goc2hhcGVOYW1lKSB7XG4gICAgICBjYXNlIFwiY2lyY2xlXCI6XG4gICAgICAgIGlmICghKG9wdGlvbnMuY2VudGVyIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTGF0TG5nKSkge1xuICAgICAgICAgIG9wdGlvbnMuY2VudGVyID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZygwLDApO1xuICAgICAgICB9IFxuICAgICAgICBzaGFwZSA9IG5ldyBnb29nbGUubWFwcy5DaXJjbGUob3B0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvbHlnb25cIjpcbiAgICAgICAgc2hhcGUgPSBuZXcgZ29vZ2xlLm1hcHMuUG9seWdvbihvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicG9seWxpbmVcIjpcbiAgICAgICAgc2hhcGUgPSBuZXcgZ29vZ2xlLm1hcHMuUG9seWxpbmUob3B0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJlY3RhbmdsZVwiOlxuICAgICAgICBzaGFwZSA9IG5ldyBnb29nbGUubWFwcy5SZWN0YW5nbGUob3B0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImdyb3VuZE92ZXJsYXlcIjpcbiAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICB2YXIgdXJsID0gb3B0aW9ucy51cmw7XG4gICAgICAgIHZhciBvcHRzID0ge29wYWNpdHk6IG9wdGlvbnMub3BhY2l0eSwgY2xpY2thYmxlOiBvcHRpb25zLmNsaWNrYWJsZSwgaWQ6b3B0aW9ucy5pZH07XG4gICAgICAgIHNoYXBlID0gbmV3IGdvb2dsZS5tYXBzLkdyb3VuZE92ZXJsYXkodXJsLCBvcHRpb25zLmJvdW5kcywgb3B0cyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCBldmVudHNcbiAgICAgKi9cbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnRzKSB7XG4gICAgICBpZiAoZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoc2hhcGUsIGV2ZW50TmFtZSwgZXZlbnRzW2V2ZW50TmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hhcGU7XG4gIH07XG5cbiAgdmFyIHNoYXBlID0gZnVuY3Rpb24oQXR0cjJNYXBPcHRpb25zLCAkcGFyc2UsIE5nTWFwKSB7XG4gICAgdmFyIHBhcnNlciA9IEF0dHIyTWFwT3B0aW9ucztcblxuICAgIHZhciBsaW5rRnVuYyA9IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgbWFwQ29udHJvbGxlcikge1xuICAgICAgbWFwQ29udHJvbGxlciA9IG1hcENvbnRyb2xsZXJbMF18fG1hcENvbnRyb2xsZXJbMV07XG5cbiAgICAgIHZhciBvcmdBdHRycyA9IHBhcnNlci5vcmdBdHRyaWJ1dGVzKGVsZW1lbnQpO1xuICAgICAgdmFyIGZpbHRlcmVkID0gcGFyc2VyLmZpbHRlcihhdHRycyk7XG4gICAgICB2YXIgc2hhcGVPcHRpb25zID0gcGFyc2VyLmdldE9wdGlvbnMoZmlsdGVyZWQsIHtzY29wZTogc2NvcGV9KTtcbiAgICAgIHZhciBzaGFwZUV2ZW50cyA9IHBhcnNlci5nZXRFdmVudHMoc2NvcGUsIGZpbHRlcmVkKTtcblxuICAgICAgdmFyIGFkZHJlc3MsIHNoYXBlVHlwZTtcbiAgICAgIHNoYXBlVHlwZSA9IHNoYXBlT3B0aW9ucy5uYW1lO1xuICAgICAgaWYgKCEoc2hhcGVPcHRpb25zLmNlbnRlciBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLkxhdExuZykpIHtcbiAgICAgICAgYWRkcmVzcyA9IHNoYXBlT3B0aW9ucy5jZW50ZXI7XG4gICAgICB9XG4gICAgICB2YXIgc2hhcGUgPSBnZXRTaGFwZShzaGFwZU9wdGlvbnMsIHNoYXBlRXZlbnRzKTtcbiAgICAgIG1hcENvbnRyb2xsZXIuYWRkT2JqZWN0KCdzaGFwZXMnLCBzaGFwZSk7XG5cbiAgICAgIGlmIChhZGRyZXNzICYmIHNoYXBlVHlwZSA9PSAnY2lyY2xlJykge1xuICAgICAgICBOZ01hcC5nZXRHZW9Mb2NhdGlvbihhZGRyZXNzKS50aGVuKGZ1bmN0aW9uKGxhdGxuZykge1xuICAgICAgICAgIHNoYXBlLnNldENlbnRlcihsYXRsbmcpO1xuICAgICAgICAgIHNoYXBlLmNlbnRlcmVkICYmIHNoYXBlLm1hcC5zZXRDZW50ZXIobGF0bG5nKTtcbiAgICAgICAgICB2YXIgZ2VvQ2FsbGJhY2sgPSBhdHRycy5nZW9DYWxsYmFjaztcbiAgICAgICAgICBnZW9DYWxsYmFjayAmJiAkcGFyc2UoZ2VvQ2FsbGJhY2spKHNjb3BlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vc2V0IG9ic2VydmVyc1xuICAgICAgbWFwQ29udHJvbGxlci5vYnNlcnZlQXR0clNldE9iaihvcmdBdHRycywgYXR0cnMsIHNoYXBlKTtcbiAgICAgIGVsZW1lbnQuYmluZCgnJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgbWFwQ29udHJvbGxlci5kZWxldGVPYmplY3QoJ3NoYXBlcycsIHNoYXBlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgIHJlcXVpcmU6IFsnP15tYXAnLCc/Xm5nTWFwJ10sXG4gICAgICBsaW5rOiBsaW5rRnVuY1xuICAgICB9OyAvLyByZXR1cm5cbiAgfTtcbiAgc2hhcGUuJGluamVjdCA9IFsnQXR0cjJNYXBPcHRpb25zJywgJyRwYXJzZScsICdOZ01hcCddO1xuXG4gIGFuZ3VsYXIubW9kdWxlKCduZ01hcCcpLmRpcmVjdGl2ZSgnc2hhcGUnLCBzaGFwZSk7XG5cbn0pKCk7XG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgc3RyZWV0dmlldy1wYW5vcmFtYVxuICogQHBhcmFtIEF0dHIyTWFwT3B0aW9ucyB7c2VydmljZX0gY29udmVydCBodG1sIGF0dHJpYnV0ZSB0byBHb29nbGUgbWFwIGFwaSBvcHRpb25zXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgUmVxdWlyZXM6ICBtYXAgZGlyZWN0aXZlXG4gKiAgIFJlc3RyaWN0IFRvOiAgRWxlbWVudFxuICpcbiAqIEBhdHRyIGNvbnRhaW5lciBPcHRpb25hbCwgaWQgb3IgY3NzIHNlbGVjdG9yLCBpZiBnaXZlbiwgc3RyZWV0dmlldyB3aWxsIGJlIGluIHRoZSBnaXZlbiBodG1sIGVsZW1lbnRcbiAqIEBhdHRyIHtTdHJpbmd9ICZsdDtTdHJlZXRWaWV3UGFub3JhbWFPcHRpb24+XG4gKiAgIFtBbnkgR29vZ2xlIFN0cmVldFZpZXdQYW5vcmFtYSBvcHRpb25zXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2U/Y3N3PTEjU3RyZWV0Vmlld1Bhbm9yYW1hT3B0aW9ucylcbiAqIEBhdHRyIHtTdHJpbmd9ICZsdDtTdHJlZXRWaWV3UGFub3JhbWFFdmVudD5cbiAqICAgW0FueSBHb29nbGUgU3RyZWV0Vmlld1Bhbm9yYW1hIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvcmVmZXJlbmNlI1N0cmVldFZpZXdQYW5vcmFtYSlcbiAqXG4gKiBAZXhhbXBsZVxuICogICA8bWFwIHpvb209XCIxMVwiIGNlbnRlcj1cIls0MC42ODg3MzgsLTc0LjA0Mzg3MV1cIiA+XG4gKiAgICAgPHN0cmVldC12aWV3LXBhbm9yYW1hXG4gKiAgICAgICBjbGljay10by1nbz1cInRydWVcIlxuICogICAgICAgZGlzYWJsZS1kZWZhdWx0LXVpPVwidHJ1ZVwiXG4gKiAgICAgICBkaXNhYmxlLWRvdWJsZS1jbGljay16b29tPVwidHJ1ZVwiXG4gKiAgICAgICBlbmFibGUtY2xvc2UtYnV0dG9uPVwidHJ1ZVwiXG4gKiAgICAgICBwYW5vPVwibXktcGFub1wiXG4gKiAgICAgICBwb3NpdGlvbj1cIjQwLjY4ODczOCwtNzQuMDQzODcxXCJcbiAqICAgICAgIHBvdj1cIntoZWFkaW5nOjAsIHBpdGNoOiA5MH1cIlxuICogICAgICAgc2Nyb2xsd2hlZWw9XCJmYWxzZVwiXG4gKiAgICAgICB2aXNpYmxlPVwidHJ1ZVwiPlxuICogICAgIDwvc3RyZWV0LXZpZXctcGFub3JhbWE+XG4gKiAgIDwvbWFwPlxuICovXG4vKiBnbG9iYWwgZ29vZ2xlLCBkb2N1bWVudCAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHN0cmVldFZpZXdQYW5vcmFtYSA9IGZ1bmN0aW9uKEF0dHIyTWFwT3B0aW9ucywgTmdNYXApIHtcbiAgICB2YXIgcGFyc2VyID0gQXR0cjJNYXBPcHRpb25zO1xuXG4gICAgdmFyIGdldFN0cmVldFZpZXdQYW5vcmFtYSA9IGZ1bmN0aW9uKG1hcCwgb3B0aW9ucywgZXZlbnRzKSB7XG4gICAgICB2YXIgc3ZwLCBjb250YWluZXI7XG4gICAgICBpZiAob3B0aW9ucy5jb250YWluZXIpIHtcbiAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy5jb250YWluZXIpO1xuICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihvcHRpb25zLmNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgIHN2cCA9IG5ldyBnb29nbGUubWFwcy5TdHJlZXRWaWV3UGFub3JhbWEoY29udGFpbmVyLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN2cCA9IG1hcC5nZXRTdHJlZXRWaWV3KCk7XG4gICAgICAgIHN2cC5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnRzKSB7XG4gICAgICAgIGV2ZW50TmFtZSAmJlxuICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHN2cCwgZXZlbnROYW1lLCBldmVudHNbZXZlbnROYW1lXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3ZwO1xuICAgIH07XG5cbiAgICB2YXIgbGlua0Z1bmMgPSBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHZhciBmaWx0ZXJlZCA9IHBhcnNlci5maWx0ZXIoYXR0cnMpO1xuICAgICAgdmFyIG9wdGlvbnMgPSBwYXJzZXIuZ2V0T3B0aW9ucyhmaWx0ZXJlZCwge3Njb3BlOiBzY29wZX0pO1xuICAgICAgdmFyIGNvbnRyb2xPcHRpb25zID0gcGFyc2VyLmdldENvbnRyb2xPcHRpb25zKGZpbHRlcmVkKTtcbiAgICAgIHZhciBzdnBPcHRpb25zID0gYW5ndWxhci5leHRlbmQob3B0aW9ucywgY29udHJvbE9wdGlvbnMpO1xuXG4gICAgICB2YXIgc3ZwRXZlbnRzID0gcGFyc2VyLmdldEV2ZW50cyhzY29wZSwgZmlsdGVyZWQpO1xuICAgICAgdm9pZCAwO1xuXG4gICAgICBOZ01hcC5nZXRNYXAoKS50aGVuKGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB2YXIgc3ZwID0gZ2V0U3RyZWV0Vmlld1Bhbm9yYW1hKG1hcCwgc3ZwT3B0aW9ucywgc3ZwRXZlbnRzKTtcblxuICAgICAgICBtYXAuc2V0U3RyZWV0VmlldyhzdnApO1xuICAgICAgICAoIXN2cC5nZXRQb3NpdGlvbigpKSAmJiBzdnAuc2V0UG9zaXRpb24obWFwLmdldENlbnRlcigpKTtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoc3ZwLCAncG9zaXRpb25fY2hhbmdlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChzdnAuZ2V0UG9zaXRpb24oKSAhPT0gbWFwLmdldENlbnRlcigpKSB7XG4gICAgICAgICAgICBtYXAuc2V0Q2VudGVyKHN2cC5nZXRQb3NpdGlvbigpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvL25lZWRlZCBmb3IgZ2VvLWNhbGxiYWNrXG4gICAgICAgIHZhciBsaXN0ZW5lciA9XG4gICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnY2VudGVyX2NoYW5nZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN2cC5zZXRQb3NpdGlvbihtYXAuZ2V0Q2VudGVyKCkpO1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICB9OyAvL2xpbmtcblxuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgcmVxdWlyZTogWyc/Xm1hcCcsJz9ebmdNYXAnXSxcbiAgICAgIGxpbms6IGxpbmtGdW5jXG4gICAgfTtcblxuICB9O1xuICBzdHJlZXRWaWV3UGFub3JhbWEuJGluamVjdCA9IFsnQXR0cjJNYXBPcHRpb25zJywgJ05nTWFwJ107XG5cbiAgYW5ndWxhci5tb2R1bGUoJ25nTWFwJykuZGlyZWN0aXZlKCdzdHJlZXRWaWV3UGFub3JhbWEnLCBzdHJlZXRWaWV3UGFub3JhbWEpO1xufSkoKTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSB0cmFmZmljLWxheWVyXG4gKiBAcGFyYW0gQXR0cjJNYXBPcHRpb25zIHtzZXJ2aWNlfSBjb252ZXJ0IGh0bWwgYXR0cmlidXRlIHRvIEdvb2dsZSBtYXAgYXBpIG9wdGlvbnNcbiAqIEBkZXNjcmlwdGlvblxuICogICBSZXF1aXJlczogIG1hcCBkaXJlY3RpdmVcbiAqICAgUmVzdHJpY3QgVG86ICBFbGVtZW50XG4gKlxuICogQGV4YW1wbGVcbiAqIEV4YW1wbGU6XG4gKlxuICogICA8bWFwIHpvb209XCIxM1wiIGNlbnRlcj1cIjM0LjA0OTI0NTk0MTkzMTY0LCAtMTE4LjI0MTA0MzA5MDgyMDMxXCI+XG4gKiAgICAgPHRyYWZmaWMtbGF5ZXI+PC90cmFmZmljLWxheWVyPlxuICogICAgPC9tYXA+XG4gKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGFuZ3VsYXIubW9kdWxlKCduZ01hcCcpLmRpcmVjdGl2ZSgndHJhZmZpY0xheWVyJywgW1xuICAgICdBdHRyMk1hcE9wdGlvbnMnLCBmdW5jdGlvbihBdHRyMk1hcE9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VyID0gQXR0cjJNYXBPcHRpb25zO1xuXG4gICAgdmFyIGdldExheWVyID0gZnVuY3Rpb24ob3B0aW9ucywgZXZlbnRzKSB7XG4gICAgICB2YXIgbGF5ZXIgPSBuZXcgZ29vZ2xlLm1hcHMuVHJhZmZpY0xheWVyKG9wdGlvbnMpO1xuICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50cykge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihsYXllciwgZXZlbnROYW1lLCBldmVudHNbZXZlbnROYW1lXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgcmVxdWlyZTogWyc/Xm1hcCcsJz9ebmdNYXAnXSxcblxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBtYXBDb250cm9sbGVyKSB7XG4gICAgICAgIG1hcENvbnRyb2xsZXIgPSBtYXBDb250cm9sbGVyWzBdfHxtYXBDb250cm9sbGVyWzFdO1xuXG4gICAgICAgIHZhciBvcmdBdHRycyA9IHBhcnNlci5vcmdBdHRyaWJ1dGVzKGVsZW1lbnQpO1xuICAgICAgICB2YXIgZmlsdGVyZWQgPSBwYXJzZXIuZmlsdGVyKGF0dHJzKTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBwYXJzZXIuZ2V0T3B0aW9ucyhmaWx0ZXJlZCwge3Njb3BlOiBzY29wZX0pO1xuICAgICAgICB2YXIgZXZlbnRzID0gcGFyc2VyLmdldEV2ZW50cyhzY29wZSwgZmlsdGVyZWQpO1xuICAgICAgICB2b2lkIDA7XG5cbiAgICAgICAgdmFyIGxheWVyID0gZ2V0TGF5ZXIob3B0aW9ucywgZXZlbnRzKTtcbiAgICAgICAgbWFwQ29udHJvbGxlci5hZGRPYmplY3QoJ3RyYWZmaWNMYXllcnMnLCBsYXllcik7XG4gICAgICAgIG1hcENvbnRyb2xsZXIub2JzZXJ2ZUF0dHJTZXRPYmoob3JnQXR0cnMsIGF0dHJzLCBsYXllcik7ICAvL29ic2VydmVyc1xuICAgICAgICBlbGVtZW50LmJpbmQoJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbWFwQ29udHJvbGxlci5kZWxldGVPYmplY3QoJ3RyYWZmaWNMYXllcnMnLCBsYXllcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICB9OyAvLyByZXR1cm5cbiAgfV0pO1xufSkoKTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSB0cmFuc2l0LWxheWVyXG4gKiBAcGFyYW0gQXR0cjJNYXBPcHRpb25zIHtzZXJ2aWNlfSBjb252ZXJ0IGh0bWwgYXR0cmlidXRlIHRvIEdvb2dsZSBtYXAgYXBpIG9wdGlvbnNcbiAqIEBkZXNjcmlwdGlvblxuICogICBSZXF1aXJlczogIG1hcCBkaXJlY3RpdmVcbiAqICAgUmVzdHJpY3QgVG86ICBFbGVtZW50XG4gKlxuICogQGV4YW1wbGVcbiAqIEV4YW1wbGU6XG4gKlxuICogIDxtYXAgem9vbT1cIjEzXCIgY2VudGVyPVwiMzQuMDQ5MjQ1OTQxOTMxNjQsIC0xMTguMjQxMDQzMDkwODIwMzFcIj5cbiAqICAgIDx0cmFuc2l0LWxheWVyPjwvdHJhbnNpdC1sYXllcj5cbiAqICA8L21hcD5cbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgYW5ndWxhci5tb2R1bGUoJ25nTWFwJykuZGlyZWN0aXZlKCd0cmFuc2l0TGF5ZXInLCBbXG4gICAgJ0F0dHIyTWFwT3B0aW9ucycsIGZ1bmN0aW9uKEF0dHIyTWFwT3B0aW9ucykge1xuICAgIHZhciBwYXJzZXIgPSBBdHRyMk1hcE9wdGlvbnM7XG5cbiAgICB2YXIgZ2V0TGF5ZXIgPSBmdW5jdGlvbihvcHRpb25zLCBldmVudHMpIHtcbiAgICAgIHZhciBsYXllciA9IG5ldyBnb29nbGUubWFwcy5UcmFuc2l0TGF5ZXIob3B0aW9ucyk7XG4gICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnRzKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGxheWVyLCBldmVudE5hbWUsIGV2ZW50c1tldmVudE5hbWVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICByZXF1aXJlOiBbJz9ebWFwJywnP15uZ01hcCddLFxuXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG1hcENvbnRyb2xsZXIpIHtcbiAgICAgICAgbWFwQ29udHJvbGxlciA9IG1hcENvbnRyb2xsZXJbMF18fG1hcENvbnRyb2xsZXJbMV07XG5cbiAgICAgICAgdmFyIG9yZ0F0dHJzID0gcGFyc2VyLm9yZ0F0dHJpYnV0ZXMoZWxlbWVudCk7XG4gICAgICAgIHZhciBmaWx0ZXJlZCA9IHBhcnNlci5maWx0ZXIoYXR0cnMpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHBhcnNlci5nZXRPcHRpb25zKGZpbHRlcmVkLCB7c2NvcGU6IHNjb3BlfSk7XG4gICAgICAgIHZhciBldmVudHMgPSBwYXJzZXIuZ2V0RXZlbnRzKHNjb3BlLCBmaWx0ZXJlZCk7XG4gICAgICAgIHZvaWQgMDtcblxuICAgICAgICB2YXIgbGF5ZXIgPSBnZXRMYXllcihvcHRpb25zLCBldmVudHMpO1xuICAgICAgICBtYXBDb250cm9sbGVyLmFkZE9iamVjdCgndHJhbnNpdExheWVycycsIGxheWVyKTtcbiAgICAgICAgbWFwQ29udHJvbGxlci5vYnNlcnZlQXR0clNldE9iaihvcmdBdHRycywgYXR0cnMsIGxheWVyKTsgIC8vb2JzZXJ2ZXJzXG4gICAgICAgIGVsZW1lbnQuYmluZCgnJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBtYXBDb250cm9sbGVyLmRlbGV0ZU9iamVjdCgndHJhbnNpdExheWVycycsIGxheWVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgIH07IC8vIHJldHVyblxuICB9XSk7XG59KSgpO1xuXG4vKipcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIGNhbWVsLWNhc2VcbiAqIEBkZXNjcmlwdGlvblxuICogICBDb252ZXJ0cyBzdHJpbmcgdG8gY2FtZWwgY2FzZWRcbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFNQRUNJQUxfQ0hBUlNfUkVHRVhQID0gLyhbXFw6XFwtXFxfXSsoLikpL2c7XG4gIHZhciBNT1pfSEFDS19SRUdFWFAgPSAvXm1veihbQS1aXSkvO1xuXG4gIHZhciBjYW1lbENhc2VGaWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWUuXG4gICAgICAgIHJlcGxhY2UoU1BFQ0lBTF9DSEFSU19SRUdFWFAsXG4gICAgICAgICAgZnVuY3Rpb24oXywgc2VwYXJhdG9yLCBsZXR0ZXIsIG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG9mZnNldCA/IGxldHRlci50b1VwcGVyQ2FzZSgpIDogbGV0dGVyO1xuICAgICAgICB9KS5cbiAgICAgICAgcmVwbGFjZShNT1pfSEFDS19SRUdFWFAsICdNb3okMScpO1xuICAgIH07XG4gIH07XG5cbiAgYW5ndWxhci5tb2R1bGUoJ25nTWFwJykuZmlsdGVyKCdjYW1lbENhc2UnLCBjYW1lbENhc2VGaWx0ZXIpO1xufSkoKTtcblxuLyoqXG4gKiBAbmdkb2MgZmlsdGVyXG4gKiBAbmFtZSBlc2NhcGUtcmVnZXhcbiAqIEBkZXNjcmlwdGlvblxuICogICBFc2NhcGVzIGFsbCByZWdleCBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gYSBzdHJpbmdcbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cblxuXG4gIHZhciBlc2NhcGVSZWdleHBGaWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7IC8vICQmIG1lYW5zIHRoZSB3aG9sZSBtYXRjaGVkIHN0cmluZ1xuXHRcdH07XG4gIH07XG5cbiAgYW5ndWxhci5tb2R1bGUoJ25nTWFwJykuZmlsdGVyKCdlc2NhcGVSZWdleHAnLCBlc2NhcGVSZWdleHBGaWx0ZXIpO1xufSkoKTtcblxuLyoqXG4gKiBAbmdkb2MgZmlsdGVyXG4gKiBAbmFtZSBqc29uaXplXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgQ29udmVydHMganNvbi1saWtlIHN0cmluZyB0byBqc29uIHN0cmluZ1xuICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIganNvbml6ZUZpbHRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHRyeSB7ICAgICAgIC8vIGlmIHBhcnNhYmxlIGFscmVhZHksIHJldHVybiBhcyBpdCBpc1xuICAgICAgICBKU09OLnBhcnNlKHN0cik7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9IGNhdGNoKGUpIHsgLy8gaWYgbm90IHBhcnNhYmxlLCBjaGFuZ2UgbGl0dGxlXG4gICAgICAgIHJldHVybiBzdHJcbiAgICAgICAgICAvLyB3cmFwIGtleXMgd2l0aG91dCBxdW90ZSB3aXRoIHZhbGlkIGRvdWJsZSBxdW90ZVxuICAgICAgICAgIC5yZXBsYWNlKC8oW1xcJFxcd10rKVxccyo6L2csXG4gICAgICAgICAgICBmdW5jdGlvbihfLCAkMSkge1xuICAgICAgICAgICAgICByZXR1cm4gJ1wiJyskMSsnXCI6JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICAgLy8gcmVwbGFjaW5nIHNpbmdsZSBxdW90ZSB3cmFwcGVkIG9uZXMgdG8gZG91YmxlIHF1b3RlXG4gICAgICAgICAgLnJlcGxhY2UoLycoW14nXSspJy9nLFxuICAgICAgICAgICAgZnVuY3Rpb24oXywgJDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdcIicrJDErJ1wiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICAgLnJlcGxhY2UoLycnL2csICdcIlwiJyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBhbmd1bGFyLm1vZHVsZSgnbmdNYXAnKS5maWx0ZXIoJ2pzb25pemUnLCBqc29uaXplRmlsdGVyKTtcbn0pKCk7XG5cbi8qKlxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lIEF0dHIyTWFwT3B0aW9uc1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIENvbnZlcnRzIHRhZyBhdHRyaWJ1dGVzIHRvIG9wdGlvbnMgdXNlZCBieSBnb29nbGUgYXBpIHYzIG9iamVjdHNcbiAqL1xuLyogZ2xvYmFsIGdvb2dsZSAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy9pLmUuIFwiMjAxNS0wOC0xMlQwNjoxMjo0MC44NThaXCJcbiAgdmFyIGlzb0RhdGVSRSA9XG4gICAgL14oXFxkezR9XFwtXFxkXFxkXFwtXFxkXFxkKFt0VF1bXFxkOlxcLl0qKT8pKFt6Wl18KFsrXFwtXSkoXFxkXFxkKTo/KFxcZFxcZCkpPyQvO1xuXG4gIHZhciBBdHRyMk1hcE9wdGlvbnMgPSBmdW5jdGlvbihcbiAgICAgICRwYXJzZSwgJHRpbWVvdXQsICRsb2csICRpbnRlcnBvbGF0ZSwgTmF2aWdhdG9yR2VvbG9jYXRpb24sIEdlb0NvZGVyLFxuICAgICAgY2FtZWxDYXNlRmlsdGVyLCBqc29uaXplRmlsdGVyLCBlc2NhcGVSZWdFeHBcbiAgICApIHtcblxuICAgIHZhciBleHByU3RhcnRTeW1ib2wgPSAkaW50ZXJwb2xhdGUuc3RhcnRTeW1ib2woKTtcbiAgICB2YXIgZXhwckVuZFN5bWJvbCA9ICRpbnRlcnBvbGF0ZS5lbmRTeW1ib2woKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGF0dHJpYnV0ZXMgb2YgYW4gZWxlbWVudCBhcyBoYXNoXG4gICAgICogQG1lbWJlcm9mIEF0dHIyTWFwT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIGh0bWwgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtIYXNofSBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgdmFyIG9yZ0F0dHJpYnV0ZXMgPSBmdW5jdGlvbihlbCkge1xuICAgICAgKGVsLmxlbmd0aCA+IDApICYmIChlbCA9IGVsWzBdKTtcbiAgICAgIHZhciBvcmdBdHRyaWJ1dGVzID0ge307XG4gICAgICBmb3IgKHZhciBpPTA7IGk8ZWwuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXR0ciA9IGVsLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgIG9yZ0F0dHJpYnV0ZXNbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JnQXR0cmlidXRlcztcbiAgICB9O1xuXG4gICAgdmFyIGdldEpTT04gPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgdmFyIHJlID0vXltcXCtcXC1dP1swLTlcXC5dKyxbIF0qXFwgP1tcXCtcXC1dP1swLTlcXC5dKyQvOyAvL2xhdCxsbmdcbiAgICAgIGlmIChpbnB1dC5tYXRjaChyZSkpIHtcbiAgICAgICAgaW5wdXQgPSBcIltcIitpbnB1dCtcIl1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25pemVGaWx0ZXIoaW5wdXQpKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBnZXRMYXRMbmcgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgdmFyIG91dHB1dCA9IGlucHV0O1xuICAgICAgaWYgKGlucHV0WzBdLmNvbnN0cnVjdG9yID09IEFycmF5KSB7IFxuICAgICAgICBpZiAoKGlucHV0WzBdWzBdLmNvbnN0cnVjdG9yID09IEFycmF5ICYmIGlucHV0WzBdWzBdLmxlbmd0aCA9PSAyKSB8fCBpbnB1dFswXVswXS5jb25zdHJ1Y3RvciA9PSBPYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBwcmVvdXRwdXQ7XG4gICAgICAgICAgICB2YXIgb3V0cHV0QXJyYXkgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcmVvdXRwdXQgPSBpbnB1dFtpXS5tYXAoZnVuY3Rpb24oZWwpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhlbFswXSwgZWxbMV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2gocHJlb3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dEFycmF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0ID0gaW5wdXQubWFwKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnb29nbGUubWFwcy5MYXRMbmcoZWxbMF0sIGVsWzFdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc05hTihwYXJzZUZsb2F0KGlucHV0WzBdKSkgJiYgaXNGaW5pdGUoaW5wdXRbMF0pKSB7XG4gICAgICAgIG91dHB1dCA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcob3V0cHV0WzBdLCBvdXRwdXRbMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuXG4gICAgdmFyIHRvT3B0aW9uVmFsdWUgPSBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgdmFyIG91dHB1dDtcbiAgICAgIHRyeSB7IC8vIDEuIE51bWJlcj9cbiAgICAgICAgb3V0cHV0ID0gZ2V0TnVtYmVyKGlucHV0KTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIHRyeSB7IC8vIDIuIEpTT04/XG4gICAgICAgICAgdmFyIG91dHB1dCA9IGdldEpTT04oaW5wdXQpO1xuICAgICAgICAgIGlmIChvdXRwdXQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgaWYgKG91dHB1dFswXS5jb25zdHJ1Y3RvciA9PSBPYmplY3QpIHtcbiAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvdXRwdXRbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICBpZiAob3V0cHV0WzBdWzBdLmNvbnN0cnVjdG9yID09IE9iamVjdCkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBnZXRMYXRMbmcob3V0cHV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBnZXRMYXRMbmcob3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSlNPTiBpcyBhbiBvYmplY3QgKG5vdCBhcnJheSBvciBudWxsKVxuICAgICAgICAgIGVsc2UgaWYgKG91dHB1dCA9PT0gT2JqZWN0KG91dHB1dCkpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBuZXN0ZWQgaGFzaGVzIGFuZCBjb252ZXJ0IHRvIEdvb2dsZSBBUEkgb3B0aW9uc1xuICAgICAgICAgICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgbmV3T3B0aW9ucy5kb05vdENvbnZlclN0cmluZ1RvTnVtYmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIG91dHB1dCA9IGdldE9wdGlvbnMob3V0cHV0LCBuZXdPcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZXJyMikge1xuICAgICAgICAgIC8vIDMuIEdvb2dsZSBNYXAgT2JqZWN0IGZ1bmN0aW9uIEV4cHJlc3Npb24uIGkuZS4gTGF0TG5nKDgwLC00OSlcbiAgICAgICAgICBpZiAoaW5wdXQubWF0Y2goL15bQS1aXVthLXpBLVowLTldK1xcKC4qXFwpJC8pKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgZXhwID0gXCJuZXcgZ29vZ2xlLm1hcHMuXCIraW5wdXQ7XG4gICAgICAgICAgICAgIG91dHB1dCA9IGV2YWwoZXhwKTsgLyoganNoaW50IGlnbm9yZTpsaW5lICovXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgb3V0cHV0ID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gNC4gR29vZ2xlIE1hcCBPYmplY3QgY29uc3RhbnQgRXhwcmVzc2lvbi4gaS5lLiBNYXlUeXBlSWQuSFlCUklEXG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaCgvXihbQS1aXVthLXpBLVowLTldKylcXC4oW0EtWl0rKSQvKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBpbnB1dC5tYXRjaCgvXihbQS1aXVthLXpBLVowLTldKylcXC4oW0EtWl0rKSQvKTtcbiAgICAgICAgICAgICAgb3V0cHV0ID0gZ29vZ2xlLm1hcHNbbWF0Y2hlc1sxXV1bbWF0Y2hlc1syXV07XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgb3V0cHV0ID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gNS4gR29vZ2xlIE1hcCBPYmplY3QgY29uc3RhbnQgRXhwcmVzc2lvbi4gaS5lLiBIWUJSSURcbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0Lm1hdGNoKC9eW0EtWl0rJC8pKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgY2FwaXRhbGl6ZWRLZXkgPSBvcHRpb25zLmtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5rZXkuc2xpY2UoMSk7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmtleS5tYXRjaCgvdGVtcGVyYXR1cmVVbml0fHdpbmRTcGVlZFVuaXR8bGFiZWxDb2xvci8pKSB7XG4gICAgICAgICAgICAgICAgY2FwaXRhbGl6ZWRLZXkgPSBjYXBpdGFsaXplZEtleS5yZXBsYWNlKC9zJC8sXCJcIik7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gZ29vZ2xlLm1hcHMud2VhdGhlcltjYXBpdGFsaXplZEtleV1baW5wdXRdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IGdvb2dsZS5tYXBzW2NhcGl0YWxpemVkS2V5XVtpbnB1dF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICBvdXRwdXQgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyA2LiBEYXRlIE9iamVjdCBhcyBJU08gU3RyaW5nXG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChpc29EYXRlUkUpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBvdXRwdXQgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgb3V0cHV0ID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gNy4gZXZhbHVhdGUgZHluYW1pY2FsbHkgYm91bmQgdmFsdWVzXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2gobmV3IFJlZ0V4cCgnXicgKyBlc2NhcGVSZWdFeHAoZXhwclN0YXJ0U3ltYm9sKSkpICYmIG9wdGlvbnMuc2NvcGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBleHByID0gaW5wdXQucmVwbGFjZShuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cChleHByU3RhcnRTeW1ib2wpKSwnJykucmVwbGFjZShuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cChleHByRW5kU3ltYm9sKSwgJ2cnKSwnJyk7XG4gICAgICAgICAgICAgIG91dHB1dCA9IG9wdGlvbnMuc2NvcGUuJGV2YWwoZXhwcik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgb3V0cHV0ID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGlucHV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBjYXRjaChlcnIyKVxuICAgICAgfSAvLyBjYXRjaChlcnIpXG5cbiAgICAgIC8vIGNvbnZlcnQgb3V0cHV0IG1vcmUgZm9yIGNlbnRlciBhbmQgcG9zaXRpb25cbiAgICAgIGlmIChcbiAgICAgICAgKG9wdGlvbnMua2V5ID09ICdjZW50ZXInIHx8IG9wdGlvbnMua2V5ID09ICdwb3NpdGlvbicpICYmXG4gICAgICAgIG91dHB1dCBpbnN0YW5jZW9mIEFycmF5XG4gICAgICApIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhvdXRwdXRbMF0sIG91dHB1dFsxXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnZlcnQgb3V0cHV0IG1vcmUgZm9yIHNoYXBlIGJvdW5kc1xuICAgICAgaWYgKG9wdGlvbnMua2V5ID09ICdib3VuZHMnICYmIG91dHB1dCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIG91dHB1dCA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMob3V0cHV0WzBdLCBvdXRwdXRbMV0pO1xuICAgICAgfVxuXG4gICAgICAvLyBjb252ZXJ0IG91dHB1dCBtb3JlIGZvciBzaGFwZSBpY29uc1xuICAgICAgaWYgKG9wdGlvbnMua2V5ID09ICdpY29ucycgJiYgb3V0cHV0IGluc3RhbmNlb2YgQXJyYXkpIHtcblxuICAgICAgICBmb3IgKHZhciBpPTA7IGk8b3V0cHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsID0gb3V0cHV0W2ldO1xuICAgICAgICAgIGlmIChlbC5pY29uLnBhdGgubWF0Y2goL15bQS1aX10rJC8pKSB7XG4gICAgICAgICAgICBlbC5pY29uLnBhdGggPSAgZ29vZ2xlLm1hcHMuU3ltYm9sUGF0aFtlbC5pY29uLnBhdGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjb252ZXJ0IG91dHB1dCBtb3JlIGZvciBtYXJrZXIgaWNvblxuICAgICAgaWYgKG9wdGlvbnMua2V5ID09ICdpY29uJyAmJiBvdXRwdXQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgaWYgKChcIlwiK291dHB1dC5wYXRoKS5tYXRjaCgvXltBLVpfXSskLykpIHtcbiAgICAgICAgICBvdXRwdXQucGF0aCA9IGdvb2dsZS5tYXBzLlN5bWJvbFBhdGhbb3V0cHV0LnBhdGhdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvdXRwdXQpIHsgLy9qc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICB2YXIgYXJyID0gb3V0cHV0W2tleV07XG4gICAgICAgICAgaWYgKGtleSA9PSBcImFuY2hvclwiIHx8IGtleSA9PSBcIm9yaWdpblwiIHx8IGtleSA9PSBcImxhYmVsT3JpZ2luXCIpIHtcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gbmV3IGdvb2dsZS5tYXBzLlBvaW50KGFyclswXSwgYXJyWzFdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PSBcInNpemVcIiB8fCBrZXkgPT0gXCJzY2FsZWRTaXplXCIpIHtcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gbmV3IGdvb2dsZS5tYXBzLlNpemUoYXJyWzBdLCBhcnJbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0QXR0cnNUb09ic2VydmUgPSBmdW5jdGlvbihhdHRycykge1xuICAgICAgdmFyIGF0dHJzVG9PYnNlcnZlID0gW107XG4gICAgICB2YXIgZXhwclJlZ0V4cCA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKGV4cHJTdGFydFN5bWJvbCkgKyAnLionICsgZXNjYXBlUmVnRXhwKGV4cHJFbmRTeW1ib2wpLCAnZycpO1xuXG4gICAgICBpZiAoIWF0dHJzLm5vV2F0Y2hlcikge1xuICAgICAgICBmb3IgKHZhciBhdHRyTmFtZSBpbiBhdHRycykgeyAvL2pzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyc1thdHRyTmFtZV07XG4gICAgICAgICAgaWYgKGF0dHJWYWx1ZSAmJiBhdHRyVmFsdWUubWF0Y2goZXhwclJlZ0V4cCkpIHsgLy8gaWYgYXR0ciB2YWx1ZSBpcyB7ey4ufX1cbiAgICAgICAgICAgIGF0dHJzVG9PYnNlcnZlLnB1c2goY2FtZWxDYXNlRmlsdGVyKGF0dHJOYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhdHRyc1RvT2JzZXJ2ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZmlsdGVycyBhdHRyaWJ1dGVzIGJ5IHNraXBwaW5nIGFuZ3VsYXJqcyBtZXRob2RzICQuLiAkJC4uXG4gICAgICogQG1lbWJlcm9mIEF0dHIyTWFwT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SGFzaH0gYXR0cnMgdGFnIGF0dHJpYnV0ZXNcbiAgICAgKiBAcmV0dXJucyB7SGFzaH0gZmlsdGVyZCBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgdmFyIGZpbHRlciA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgZm9yKHZhciBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKGtleS5tYXRjaCgvXlxcJC8pIHx8IGtleS5tYXRjaCgvXm5nW0EtWl0vKSkge1xuICAgICAgICAgIHZvaWQoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9uc1trZXldID0gYXR0cnNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIGF0dHJpYnV0ZXMgaGFzaCB0byBHb29nbGUgTWFwcyBBUEkgdjMgb3B0aW9uc1xuICAgICAqIGBgYFxuICAgICAqICAuIGNvbnZlcnRzIG51bWJlcnMgdG8gbnVtYmVyXG4gICAgICogIC4gY29udmVydHMgY2xhc3MtbGlrZSBzdHJpbmcgdG8gZ29vZ2xlIG1hcHMgaW5zdGFuY2VcbiAgICAgKiAgICBpLmUuIGBMYXRMbmcoMSwxKWAgdG8gYG5ldyBnb29nbGUubWFwcy5MYXRMbmcoMSwxKWBcbiAgICAgKiAgLiBjb252ZXJ0cyBjb25zdGFudC1saWtlIHN0cmluZyB0byBnb29nbGUgbWFwcyBjb25zdGFudFxuICAgICAqICAgIGkuZS4gYE1hcFR5cGVJZC5IWUJSSURgIHRvIGBnb29nbGUubWFwcy5NYXBUeXBlSWQuSFlCUklEYFxuICAgICAqICAgIGkuZS4gYEhZQlJJRFwiYCB0byBgZ29vZ2xlLm1hcHMuTWFwVHlwZUlkLkhZQlJJRGBcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgQXR0cjJNYXBPcHRpb25zXG4gICAgICogQHBhcmFtIHtIYXNofSBhdHRycyB0YWcgYXR0cmlidXRlc1xuICAgICAqIEBwYXJhbSB7SGFzaH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtIYXNofSBvcHRpb25zIGNvbnZlcnRlZCBhdHRyaWJ1dGVzc1xuICAgICAqL1xuICAgIHZhciBnZXRPcHRpb25zID0gZnVuY3Rpb24oYXR0cnMsIHBhcmFtcykge1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgIGZvcih2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGlmIChhdHRyc1trZXldIHx8IGF0dHJzW2tleV0gPT09IDApIHtcbiAgICAgICAgICBpZiAoa2V5Lm1hdGNoKC9eb25bQS1aXS8pKSB7IC8vc2tpcCBldmVudHMsIGkuZS4gb24tY2xpY2tcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoa2V5Lm1hdGNoKC9Db250cm9sT3B0aW9ucyQvKSkgeyAvLyBza2lwIGNvbnRyb2xPcHRpb25zXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbmVzdGVkIGNvbnZlcnNpb25zIG5lZWQgdG8gYmUgdHlwZWNoZWNrZWRcbiAgICAgICAgICAgIC8vIChub24tc3RyaW5ncyBhcmUgZnVsbHkgY29udmVydGVkKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRyc1trZXldICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmFtcy5kb05vdENvbnZlclN0cmluZ1RvTnVtYmVyICYmXG4gICAgICAgICAgICAgICAgYXR0cnNba2V5XS5tYXRjaCgvXlswLTldKyQvKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IHRvT3B0aW9uVmFsdWUoYXR0cnNba2V5XSwge2tleToga2V5LCBzY29wZTogcGFyYW1zLnNjb3BlfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gaWYgKGF0dHJzW2tleV0pXG4gICAgICB9IC8vIGZvcih2YXIga2V5IGluIGF0dHJzKVxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIGF0dHJpYnV0ZXMgaGFzaCB0byBzY29wZS1zcGVjaWZpYyBldmVudCBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBBdHRyMk1hcE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge3Njb3BlfSBzY29wZSBhbmd1bGFyanMgc2NvcGVcbiAgICAgKiBAcGFyYW0ge0hhc2h9IGF0dHJzIHRhZyBhdHRyaWJ1dGVzXG4gICAgICogQHJldHVybnMge0hhc2h9IGV2ZW50cyBjb252ZXJ0ZWQgZXZlbnRzXG4gICAgICovXG4gICAgdmFyIGdldEV2ZW50cyA9IGZ1bmN0aW9uKHNjb3BlLCBhdHRycykge1xuICAgICAgdmFyIGV2ZW50cyA9IHt9O1xuICAgICAgdmFyIHRvTG93ZXJjYXNlRnVuYyA9IGZ1bmN0aW9uKCQxKXtcbiAgICAgICAgcmV0dXJuIFwiX1wiKyQxLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9O1xuICAgICAgdmFyIEV2ZW50RnVuYyA9IGZ1bmN0aW9uKGF0dHJWYWx1ZSkge1xuICAgICAgICAvLyBmdW5jTmFtZShhcmdzU3RyKVxuICAgICAgICB2YXIgbWF0Y2hlcyA9IGF0dHJWYWx1ZS5tYXRjaCgvKFteXFwoXSspXFwoKFteXFwpXSopXFwpLyk7XG4gICAgICAgIHZhciBmdW5jTmFtZSA9IG1hdGNoZXNbMV07XG4gICAgICAgIHZhciBhcmdzU3RyID0gbWF0Y2hlc1syXS5yZXBsYWNlKC9ldmVudFsgLF0qLywnJyk7ICAvL3JlbW92ZSBzdHJpbmcgJ2V2ZW50J1xuICAgICAgICB2YXIgYXJnc0V4cHIgPSAkcGFyc2UoXCJbXCIrYXJnc1N0citcIl1cIik7IC8vZm9yIHBlcmYgd2hlbiB0cmlnZ2VyaW5nIGV2ZW50XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJnc0V4cHIoc2NvcGUpOyAvL2dldCBhcmdzIGhlcmUgdG8gcGFzcyB1cGRhdGVkIG1vZGVsIHZhbHVlc1xuICAgICAgICAgIGZ1bmN0aW9uIGluZGV4KG9iaixpKSB7cmV0dXJuIG9ialtpXTt9XG4gICAgICAgICAgdmFyIGYgPSBmdW5jTmFtZS5zcGxpdCgnLicpLnJlZHVjZShpbmRleCwgc2NvcGUpO1xuICAgICAgICAgIGYgJiYgZi5hcHBseSh0aGlzLCBbZXZlbnRdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgJHRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBmb3IodmFyIGtleSBpbiBhdHRycykge1xuICAgICAgICBpZiAoYXR0cnNba2V5XSkge1xuICAgICAgICAgIGlmICgha2V5Lm1hdGNoKC9eb25bQS1aXS8pKSB7IC8vc2tpcCBpZiBub3QgZXZlbnRzXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL2dldCBldmVudCBuYW1lIGFzIHVuZGVyc2NvcmVkLiBpLmUuIHpvb21fY2hhbmdlZFxuICAgICAgICAgIHZhciBldmVudE5hbWUgPSBrZXkucmVwbGFjZSgvXm9uLywnJyk7XG4gICAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgZXZlbnROYW1lLnNsaWNlKDEpO1xuICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS5yZXBsYWNlKC8oW0EtWl0pL2csIHRvTG93ZXJjYXNlRnVuYyk7XG5cbiAgICAgICAgICB2YXIgYXR0clZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICBldmVudHNbZXZlbnROYW1lXSA9IG5ldyBFdmVudEZ1bmMoYXR0clZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY29udHJvbCBtZWFucyBtYXAgY29udHJvbHMsIGkuZSBzdHJlZXR2aWV3LCBwYW4sIGV0Yywgbm90IGEgZ2VuZXJhbCBjb250cm9sXG4gICAgICogQG1lbWJlcm9mIEF0dHIyTWFwT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SGFzaH0gZmlsdGVyZWQgZmlsdGVyZWQgdGFnIGF0dHJpYnV0ZXNcbiAgICAgKiBAcmV0dXJucyB7SGFzaH0gR29vZ2xlIE1hcCBvcHRpb25zXG4gICAgICovXG4gICAgdmFyIGdldENvbnRyb2xPcHRpb25zID0gZnVuY3Rpb24oZmlsdGVyZWQpIHtcbiAgICAgIHZhciBjb250cm9sT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBmaWx0ZXJlZCAhPSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGF0dHIgaW4gZmlsdGVyZWQpIHtcbiAgICAgICAgaWYgKGZpbHRlcmVkW2F0dHJdKSB7XG4gICAgICAgICAgaWYgKCFhdHRyLm1hdGNoKC8oLiopQ29udHJvbE9wdGlvbnMkLykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBpZiBub3QgY29udHJvbE9wdGlvbnMsIHNraXAgaXRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL2NoYW5nZSBpbnZhbGlkIGpzb24gdG8gdmFsaWQgb25lLCBpLmUuIHtmb286MX0gdG8ge1wiZm9vXCI6IDF9XG4gICAgICAgICAgdmFyIG9yZ1ZhbHVlID0gZmlsdGVyZWRbYXR0cl07XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gb3JnVmFsdWUucmVwbGFjZSgvJy9nLCAnXCInKTtcbiAgICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnJlcGxhY2UoLyhbXlwiXSspfChcIlteXCJdK1wiKS9nLCBmdW5jdGlvbigkMCwgJDEsICQyKSB7XG4gICAgICAgICAgICBpZiAoJDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICQxLnJlcGxhY2UoLyhbYS16QS1aMC05XSs/KTovZywgJ1wiJDFcIjonKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAkMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBKU09OLnBhcnNlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7IC8vYXNzaWduIHRoZSByaWdodCB2YWx1ZXNcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnNba2V5XSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIm1hcFR5cGVJZHNcIikge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoIGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyLm1hdGNoKC9eW0EtWl0rJC8pKSB7IC8vIGlmIGNvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdvb2dsZS5tYXBzLk1hcFR5cGVJZFtzdHIudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGVsc2UsIGN1c3RvbSBtYXAtdHlwZVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwic3R5bGVcIikge1xuICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9IGF0dHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBhdHRyLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgdmFyIG9iak5hbWUgPSBzdHIucmVwbGFjZSgvT3B0aW9ucyQvLCcnKStcIlN0eWxlXCI7XG4gICAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSBnb29nbGUubWFwc1tvYmpOYW1lXVt2YWx1ZV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwicG9zaXRpb25cIikge1xuICAgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gZ29vZ2xlLm1hcHMuQ29udHJvbFBvc2l0aW9uW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sT3B0aW9uc1thdHRyXSA9IG9wdGlvbnM7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3JcblxuICAgICAgcmV0dXJuIGNvbnRyb2xPcHRpb25zO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICBnZXRPcHRpb25zOiBnZXRPcHRpb25zLFxuICAgICAgZ2V0RXZlbnRzOiBnZXRFdmVudHMsXG4gICAgICBnZXRDb250cm9sT3B0aW9uczogZ2V0Q29udHJvbE9wdGlvbnMsXG4gICAgICB0b09wdGlvblZhbHVlOiB0b09wdGlvblZhbHVlLFxuICAgICAgZ2V0QXR0cnNUb09ic2VydmU6IGdldEF0dHJzVG9PYnNlcnZlLFxuICAgICAgb3JnQXR0cmlidXRlczogb3JnQXR0cmlidXRlc1xuICAgIH07IC8vIHJldHVyblxuXG4gIH07XG4gIEF0dHIyTWFwT3B0aW9ucy4kaW5qZWN0PSBbXG4gICAgJyRwYXJzZScsICckdGltZW91dCcsICckbG9nJywgJyRpbnRlcnBvbGF0ZScsICdOYXZpZ2F0b3JHZW9sb2NhdGlvbicsICdHZW9Db2RlcicsXG4gICAgJ2NhbWVsQ2FzZUZpbHRlcicsICdqc29uaXplRmlsdGVyJywgJ2VzY2FwZVJlZ2V4cEZpbHRlcidcbiAgXTtcblxuICBhbmd1bGFyLm1vZHVsZSgnbmdNYXAnKS5zZXJ2aWNlKCdBdHRyMk1hcE9wdGlvbnMnLCBBdHRyMk1hcE9wdGlvbnMpO1xufSkoKTtcblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgR2VvQ29kZXJcbiAqIEBkZXNjcmlwdGlvblxuICogICBQcm92aWRlcyBbZGVmZXJlZC9wcm9taXNlIEFQSV0oaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL25nL3NlcnZpY2UvJHEpXG4gKiAgIHNlcnZpY2UgZm9yIEdvb2dsZSBHZW9jb2RlciBzZXJ2aWNlXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICB2YXIgJHE7XG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgR2VvQ29kZXJcbiAgICogQHBhcmFtIHtIYXNofSBvcHRpb25zXG4gICAqICAgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2dlb2NvZGluZy8jZ2VvY29kaW5nXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiAgIEdlb0NvZGVyLmdlb2NvZGUoe2FkZHJlc3M6ICd0aGUgY24gdG93ZXInfSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICogICAgIC8vLi4uIGRvIHNvbWV0aGluZyB3aXRoIHJlc3VsdFxuICAgKiAgIH0pO1xuICAgKiBgYGBcbiAgICogQHJldHVybnMge0h0dHBQcm9taXNlfSBGdXR1cmUgb2JqZWN0XG4gICAqL1xuICB2YXIgZ2VvY29kZUZ1bmMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICB2YXIgZ2VvY29kZXIgPSBuZXcgZ29vZ2xlLm1hcHMuR2VvY29kZXIoKTtcbiAgICBnZW9jb2Rlci5nZW9jb2RlKG9wdGlvbnMsIGZ1bmN0aW9uIChyZXN1bHRzLCBzdGF0dXMpIHtcbiAgICAgIGlmIChzdGF0dXMgPT0gZ29vZ2xlLm1hcHMuR2VvY29kZXJTdGF0dXMuT0spIHtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChzdGF0dXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICB9O1xuXG4gIHZhciBHZW9Db2RlciA9IGZ1bmN0aW9uKF8kcV8pIHtcbiAgICAkcSA9IF8kcV87XG4gICAgcmV0dXJuIHtcbiAgICAgIGdlb2NvZGUgOiBnZW9jb2RlRnVuY1xuICAgIH07XG4gIH07XG4gIEdlb0NvZGVyLiRpbmplY3QgPSBbJyRxJ107XG5cbiAgYW5ndWxhci5tb2R1bGUoJ25nTWFwJykuc2VydmljZSgnR2VvQ29kZXInLCBHZW9Db2Rlcik7XG59KSgpO1xuXG4vKipcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSBHb29nbGVNYXBzQXBpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgTG9hZCBHb29nbGUgTWFwcyBBUEkgU2VydmljZVxuICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyICRxO1xuICB2YXIgJHRpbWVvdXQ7XG5cbiAgdmFyIEdvb2dsZU1hcHNBcGkgPSBmdW5jdGlvbihfJHFfLCBfJHRpbWVvdXRfKSB7XG4gICAgJHEgPSBfJHFfO1xuICAgICR0aW1lb3V0ID0gXyR0aW1lb3V0XztcblxuICAgIHJldHVybiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogTG9hZCBnb29nbGUgbWFwcyBpbnRvIGRvY3VtZW50IGJ5IGNyZWF0aW5nIGEgc2NyaXB0IHRhZ1xuICAgICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcHNBcGlcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXBzVXJsXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogICBHb29nbGVNYXBzQXBpLmxvYWQobXlVcmwpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgKiAgICAgY29uc29sZS5sb2coJ2dvb2dsZSBtYXAgaGFzIGJlZW4gbG9hZGVkJylcbiAgICAgICAqICAgfSk7XG4gICAgICAgKi9cbiAgICAgIGxvYWQ6IGZ1bmN0aW9uIChtYXBzVXJsKSB7XG5cbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICBpZiAod2luZG93Lmdvb2dsZSA9PT0gdW5kZWZpbmVkIHx8IHdpbmRvdy5nb29nbGUubWFwcyA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICB3aW5kb3cubGF6eUxvYWRDYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7IC8qIGdpdmUgc29tZSB0aW1lIHRvIGxvYWQgKi9cbiAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh3aW5kb3cuZ29vZ2xlKVxuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIHNjcmlwdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgc2NyaXB0RWwuc3JjID0gbWFwc1VybCArXG4gICAgICAgICAgICAobWFwc1VybC5pbmRleE9mKCc/JykgPiAtMSA/ICcmJyA6ICc/JykgK1xuICAgICAgICAgICAgJ2NhbGxiYWNrPWxhenlMb2FkQ2FsbGJhY2snO1xuXG4gICAgICAgICAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzY3JpcHRbc3JjPVwiJyArIHNjcmlwdEVsLnNyYyArICdcIl0nKSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHRFbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUod2luZG93Lmdvb2dsZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgfVxuXG4gICAgfVxuICB9XG4gIEdvb2dsZU1hcHNBcGkuJGluamVjdCA9IFsnJHEnLCAnJHRpbWVvdXQnXTtcblxuICBhbmd1bGFyLm1vZHVsZSgnbmdNYXAnKS5zZXJ2aWNlKCdHb29nbGVNYXBzQXBpJywgR29vZ2xlTWFwc0FwaSk7XG59KSgpO1xuXG5cblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgTmF2aWdhdG9yR2VvbG9jYXRpb25cbiAqIEBkZXNjcmlwdGlvblxuICogIFByb3ZpZGVzIFtkZWZlcmVkL3Byb21pc2UgQVBJXShodHRwczovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmcvc2VydmljZS8kcSlcbiAqICBzZXJ2aWNlIGZvciBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24gbWV0aG9kc1xuICovXG4vKiBnbG9iYWwgZ29vZ2xlICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyICRxO1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgTmF2aWdhdG9yR2VvbG9jYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGdlb0xvY2F0aW9uT3B0aW9ucyB0aGUgbmF2aWdhdG9yIGdlb2xvY2F0aW9ucyBvcHRpb25zLlxuICAgKiAgaS5lLiB7IG1heGltdW1BZ2U6IDMwMDAsIHRpbWVvdXQ6IDUwMDAsIGVuYWJsZUhpZ2hBY2N1cmFjeTogdHJ1ZSB9LlxuICAgKiAgSWYgbm9uZSBzcGVjaWZpZWQsIHsgdGltZW91dDogNTAwMCB9LiBcbiAgICogIElmIHRpbWVvdXQgbm90IHNwZWNpZmllZCwgdGltZW91dDogNTAwMCBhZGRlZFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdWNjZXNzIHN1Y2Nlc3MgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZmFpbHVyZSBmYWlsdXJlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiAgTmF2aWdhdG9yR2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKClcbiAgICogICAgLnRoZW4oZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICogICAgICB2YXIgbGF0ID0gcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlLCBsbmcgPSBwb3NpdGlvbi5jb29yZHMubG9uZ2l0dWRlO1xuICAgKiAgICAgIC4uIGRvIHNvbWV0aGluZyBsYXQgYW5kIGxuZ1xuICAgKiAgICB9KTtcbiAgICogYGBgXG4gICAqIEByZXR1cm5zIHtIdHRwUHJvbWlzZX0gRnV0dXJlIG9iamVjdFxuICAgKi9cbiAgdmFyIGdldEN1cnJlbnRQb3NpdGlvbiA9IGZ1bmN0aW9uKGdlb0xvY2F0aW9uT3B0aW9ucykge1xuICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgaWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xuXG4gICAgICBpZiAoZ2VvTG9jYXRpb25PcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2VvTG9jYXRpb25PcHRpb25zID0geyB0aW1lb3V0OiA1MDAwIH07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChnZW9Mb2NhdGlvbk9wdGlvbnMudGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdlb0xvY2F0aW9uT3B0aW9ucy50aW1lb3V0ID0gNTAwMDtcbiAgICAgIH1cblxuICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihcbiAgICAgICAgZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHBvc2l0aW9uKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgdm9pZCAwO1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdChldnQpO1xuICAgICAgICB9LFxuICAgICAgICBnZW9Mb2NhdGlvbk9wdGlvbnNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmVycmVkLnJlamVjdChcIkJyb3dzZXIgR2VvbG9jYXRpb24gc2VydmljZSBmYWlsZWQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgfTtcblxuICB2YXIgTmF2aWdhdG9yR2VvbG9jYXRpb24gPSBmdW5jdGlvbihfJHFfKSB7XG4gICAgJHEgPSBfJHFfO1xuICAgIHJldHVybiB7XG4gICAgICBnZXRDdXJyZW50UG9zaXRpb246IGdldEN1cnJlbnRQb3NpdGlvblxuICAgIH07XG4gIH07XG4gIE5hdmlnYXRvckdlb2xvY2F0aW9uLiRpbmplY3QgPSBbJyRxJ107XG5cbiAgYW5ndWxhci5tb2R1bGUoJ25nTWFwJykuXG4gICAgc2VydmljZSgnTmF2aWdhdG9yR2VvbG9jYXRpb24nLCBOYXZpZ2F0b3JHZW9sb2NhdGlvbik7XG59KSgpO1xuXG4vKipcbiAqIEBuZ2RvYyBmYWN0b3J5XG4gKiBAbmFtZSBOZ01hcFBvb2xcbiAqIEBkZXNjcmlwdGlvblxuICogICBQcm92aWRlIG1hcCBpbnN0YW5jZSB0byBhdm9pZCBtZW1vcnkgbGVha1xuICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBOZ01hcFBvb2xcbiAgICogQGRlc2MgbWFwIGluc3RhbmNlIHBvb2xcbiAgICovXG4gIHZhciBtYXBJbnN0YW5jZXMgPSBbXTtcbiAgdmFyICR3aW5kb3csICRkb2N1bWVudCwgJHRpbWVvdXQ7XG5cbiAgdmFyIGFkZCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIG1hcERpdiA9ICRkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIG1hcERpdi5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIG1hcERpdi5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICBlbC5hcHBlbmRDaGlsZChtYXBEaXYpO1xuICAgIHZhciBtYXAgPSBuZXcgJHdpbmRvdy5nb29nbGUubWFwcy5NYXAobWFwRGl2LCB7fSk7XG4gICAgbWFwSW5zdGFuY2VzLnB1c2gobWFwKTtcbiAgICByZXR1cm4gbWFwO1xuICB9O1xuXG4gIHZhciBmaW5kQnlJZCA9IGZ1bmN0aW9uKGVsLCBpZCkge1xuICAgIHZhciBub3RJblVzZU1hcDtcbiAgICBmb3IgKHZhciBpPTA7IGk8bWFwSW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbWFwID0gbWFwSW5zdGFuY2VzW2ldO1xuICAgICAgaWYgKG1hcC5pZCA9PSBpZCAmJiAhbWFwLmluVXNlKSB7XG4gICAgICAgIHZhciBtYXBEaXYgPSBtYXAuZ2V0RGl2KCk7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKG1hcERpdik7XG4gICAgICAgIG5vdEluVXNlTWFwID0gbWFwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vdEluVXNlTWFwO1xuICB9O1xuXG4gIHZhciBmaW5kVW51c2VkID0gZnVuY3Rpb24oZWwpIHsgLy9qc2hpbnQgaWdub3JlOmxpbmVcbiAgICB2YXIgbm90SW5Vc2VNYXA7XG4gICAgZm9yICh2YXIgaT0wOyBpPG1hcEluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG1hcCA9IG1hcEluc3RhbmNlc1tpXTtcbiAgICAgIGlmIChtYXAuaWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIW1hcC5pblVzZSkge1xuICAgICAgICB2YXIgbWFwRGl2ID0gbWFwLmdldERpdigpO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZChtYXBEaXYpO1xuICAgICAgICBub3RJblVzZU1hcCA9IG1hcDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub3RJblVzZU1hcDtcbiAgfTtcblxuICAvKipcbiAgICogQG1lbWJlcm9mIE5nTWFwUG9vbFxuICAgKiBAZnVuY3Rpb24gZ2V0TWFwSW5zdGFuY2VcbiAgICogQHBhcmFtIHtIdG1sRWxlbWVudH0gZWwgbWFwIGNvbnRhaW5lciBlbGVtZW50XG4gICAqIEByZXR1cm4gbWFwIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgKi9cbiAgdmFyIGdldE1hcEluc3RhbmNlID0gZnVuY3Rpb24oZWwpIHtcbiAgICB2YXIgbWFwID0gZmluZEJ5SWQoZWwsIGVsLmlkKSB8fCBmaW5kVW51c2VkKGVsKTtcbiAgICBpZiAoIW1hcCkge1xuICAgICAgbWFwID0gYWRkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZmlyaW5nIG1hcCBpZGxlIGV2ZW50LCB3aGljaCBpcyB1c2VkIGJ5IG1hcCBjb250cm9sbGVyICovXG4gICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcihtYXAsICdpZGxlJyk7XG4gICAgICB9LCAxMDApO1xuICAgIH1cbiAgICBtYXAuaW5Vc2UgPSB0cnVlO1xuICAgIHJldHVybiBtYXA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBOZ01hcFBvb2xcbiAgICogQGZ1bmN0aW9uIHJldHVybk1hcEluc3RhbmNlXG4gICAqIEBwYXJhbSB7TWFwfSBhbiBpbnN0YW5jZSBvZiBnb29nbGUubWFwcy5NYXBcbiAgICogQGRlc2Mgc2V0cyB0aGUgZmxhZyBpblVzZSBvZiB0aGUgZ2l2ZW4gbWFwIGluc3RhbmNlIHRvIGZhbHNlLCBzbyB0aGF0IGl0IFxuICAgKiBjYW4gYmUgcmV1c2VkIGxhdGVyXG4gICAqL1xuICB2YXIgcmV0dXJuTWFwSW5zdGFuY2UgPSBmdW5jdGlvbihtYXApIHtcbiAgICBtYXAuaW5Vc2UgPSBmYWxzZTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgTmdNYXBQb29sXG4gICAqIEBmdW5jdGlvbiByZXNldE1hcEluc3RhbmNlc1xuICAgKiBAZGVzYyByZXNldHMgbWFwSW5zdGFuY2UgYXJyYXlcbiAgICovXG4gIHZhciByZXNldE1hcEluc3RhbmNlcyA9IGZ1bmN0aW9uKCkge1xuICAgIGZvcih2YXIgaSA9IDA7aSA8IG1hcEluc3RhbmNlcy5sZW5ndGg7aSsrKSB7XG4gICAgICAgIG1hcEluc3RhbmNlc1tpXSA9IG51bGw7XG4gICAgfVxuICAgIG1hcEluc3RhbmNlcyA9IFtdO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBOZ01hcFBvb2xcbiAgICogQGZ1bmN0aW9uIGRlbGV0ZU1hcEluc3RhbmNlXG4gICAqIEBkZXNjIGRlbGV0ZSBhIG1hcEluc3RhbmNlXG4gICAqL1xuICB2YXIgZGVsZXRlTWFwSW5zdGFuY2U9IGZ1bmN0aW9uKG1hcElkKSB7XG5cdCAgZm9yKCB2YXIgaT0wOyBpPG1hcEluc3RhbmNlcy5sZW5ndGg7IGkrKyApIHtcblx0XHQgIGlmKCAobWFwSW5zdGFuY2VzW2ldICE9PSBudWxsKSAmJiAobWFwSW5zdGFuY2VzW2ldLmlkID09IG1hcElkKSkge1xuXHRcdFx0ICBtYXBJbnN0YW5jZXNbaV09IG51bGw7XG5cdFx0XHQgIG1hcEluc3RhbmNlcy5zcGxpY2UoIGksIDEgKTtcblx0XHQgIH1cblx0ICB9XG4gIH07XG5cbiAgdmFyIE5nTWFwUG9vbCA9IGZ1bmN0aW9uKF8kZG9jdW1lbnRfLCBfJHdpbmRvd18sIF8kdGltZW91dF8pIHtcbiAgICAkZG9jdW1lbnQgPSBfJGRvY3VtZW50X1swXSwgJHdpbmRvdyA9IF8kd2luZG93XywgJHRpbWVvdXQgPSBfJHRpbWVvdXRfO1xuXG4gICAgcmV0dXJuIHtcblx0ICBtYXBJbnN0YW5jZXM6IG1hcEluc3RhbmNlcyxcbiAgICAgIHJlc2V0TWFwSW5zdGFuY2VzOiByZXNldE1hcEluc3RhbmNlcyxcbiAgICAgIGdldE1hcEluc3RhbmNlOiBnZXRNYXBJbnN0YW5jZSxcbiAgICAgIHJldHVybk1hcEluc3RhbmNlOiByZXR1cm5NYXBJbnN0YW5jZSxcbiAgICAgIGRlbGV0ZU1hcEluc3RhbmNlOiBkZWxldGVNYXBJbnN0YW5jZVxuICAgIH07XG4gIH07XG5cbiAgTmdNYXBQb29sLiRpbmplY3QgPSBbICckZG9jdW1lbnQnLCAnJHdpbmRvdycsICckdGltZW91dCddO1xuXG4gIGFuZ3VsYXIubW9kdWxlKCduZ01hcCcpLmZhY3RvcnkoJ05nTWFwUG9vbCcsIE5nTWFwUG9vbCk7XG5cbn0pKCk7XG5cbi8qKlxuICogQG5nZG9jIHByb3ZpZGVyXG4gKiBAbmFtZSBOZ01hcFxuICogQGRlc2NyaXB0aW9uXG4gKiAgY29tbW9uIHV0aWxpdHkgc2VydmljZSBmb3IgbmctbWFwXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICB2YXIgJHdpbmRvdywgJGRvY3VtZW50LCAkcTtcbiAgdmFyIE5hdmlnYXRvckdlb2xvY2F0aW9uLCBBdHRyMk1hcE9wdGlvbnMsIEdlb0NvZGVyLCBjYW1lbENhc2VGaWx0ZXIsIE5nTWFwUG9vbDtcblxuICB2YXIgbWFwQ29udHJvbGxlcnMgPSB7fTtcblxuICB2YXIgZ2V0U3R5bGUgPSBmdW5jdGlvbihlbCwgc3R5bGVQcm9wKSB7XG4gICAgdmFyIHk7XG4gICAgaWYgKGVsLmN1cnJlbnRTdHlsZSkge1xuICAgICAgeSA9IGVsLmN1cnJlbnRTdHlsZVtzdHlsZVByb3BdO1xuICAgIH0gZWxzZSBpZiAoJHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICB5ID0gJGRvY3VtZW50LmRlZmF1bHRWaWV3LlxuICAgICAgICBnZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5cbiAgICAgICAgZ2V0UHJvcGVydHlWYWx1ZShzdHlsZVByb3ApO1xuICAgIH1cbiAgICByZXR1cm4geTtcbiAgfTtcblxuICAvKipcbiAgICogQG1lbWJlcm9mIE5nTWFwXG4gICAqIEBmdW5jdGlvbiBpbml0TWFwXG4gICAqIEBwYXJhbSBpZCBvcHRpb25hbCwgaWQgb2YgdGhlIG1hcC4gZGVmYXVsdCAwXG4gICAqL1xuICB2YXIgaW5pdE1hcCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIGN0cmwgPSBtYXBDb250cm9sbGVyc1tpZCB8fCAwXTtcbiAgICBpZiAoIShjdHJsLm1hcCBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLk1hcCkpIHtcbiAgICAgIGN0cmwuaW5pdGlhbGl6ZU1hcCgpO1xuICAgICAgcmV0dXJuIGN0cmwubWFwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2b2lkIDA7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgTmdNYXBcbiAgICogQGZ1bmN0aW9uIGdldE1hcFxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uYWwsIGlkIGUuZy4sICdmb28nXG4gICAqIEByZXR1cm5zIHByb21pc2VcbiAgICovXG4gIHZhciBnZXRNYXAgPSBmdW5jdGlvbihpZCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlkID0gdHlwZW9mIGlkID09PSAnb2JqZWN0JyA/IGlkLmlkIDogaWQ7XG5cbiAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgIHZhciB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IDEwMDAwO1xuXG4gICAgZnVuY3Rpb24gd2FpdEZvck1hcCh0aW1lRWxhcHNlZCl7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1hcENvbnRyb2xsZXJzKTtcbiAgICAgIHZhciB0aGVGaXJzdENvbnRyb2xsZXIgPSBtYXBDb250cm9sbGVyc1trZXlzWzBdXTtcbiAgICAgIGlmKGlkICYmIG1hcENvbnRyb2xsZXJzW2lkXSl7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUobWFwQ29udHJvbGxlcnNbaWRdLm1hcCk7XG4gICAgICB9IGVsc2UgaWYgKCFpZCAmJiB0aGVGaXJzdENvbnRyb2xsZXIgJiYgdGhlRmlyc3RDb250cm9sbGVyLm1hcCkge1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHRoZUZpcnN0Q29udHJvbGxlci5tYXApO1xuICAgICAgfSBlbHNlIGlmICh0aW1lRWxhcHNlZCA+IHRpbWVvdXQpIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KCdjb3VsZCBub3QgZmluZCBtYXAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKXtcbiAgICAgICAgICB3YWl0Rm9yTWFwKHRpbWVFbGFwc2VkKzEwMCk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHdhaXRGb3JNYXAoMCk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgfTtcblxuICAvKipcbiAgICogQG1lbWJlcm9mIE5nTWFwXG4gICAqIEBmdW5jdGlvbiBhZGRNYXBcbiAgICogQHBhcmFtIG1hcENvbnRyb2xsZXIge19fTWFwQ29udG9sbGVyfSBhIG1hcCBjb250cm9sbGVyXG4gICAqIEByZXR1cm5zIHByb21pc2VcbiAgICovXG4gIHZhciBhZGRNYXAgPSBmdW5jdGlvbihtYXBDdHJsKSB7XG4gICAgaWYgKG1hcEN0cmwubWFwKSB7XG4gICAgICB2YXIgbGVuID0gT2JqZWN0LmtleXMobWFwQ29udHJvbGxlcnMpLmxlbmd0aDtcbiAgICAgIG1hcENvbnRyb2xsZXJzW21hcEN0cmwubWFwLmlkIHx8IGxlbl0gPSBtYXBDdHJsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG1lbWJlcm9mIE5nTWFwXG4gICAqIEBmdW5jdGlvbiBkZWxldGVNYXBcbiAgICogQHBhcmFtIG1hcENvbnRyb2xsZXIge19fTWFwQ29udG9sbGVyfSBhIG1hcCBjb250cm9sbGVyXG4gICAqL1xuICB2YXIgZGVsZXRlTWFwID0gZnVuY3Rpb24obWFwQ3RybCkge1xuICAgIHZhciBsZW4gPSBPYmplY3Qua2V5cyhtYXBDb250cm9sbGVycykubGVuZ3RoIC0gMTtcbiAgICB2YXIgbWFwSWQgPSBtYXBDdHJsLm1hcC5pZCB8fCBsZW47XG4gICAgaWYgKG1hcEN0cmwubWFwKSB7XG4gICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gbWFwQ3RybC5ldmVudExpc3RlbmVycykge1xuICAgICAgICB2b2lkIDA7XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IG1hcEN0cmwuZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1hcEN0cmwubWFwLmNvbnRyb2xzKSB7XG4gICAgICAgIG1hcEN0cmwubWFwLmNvbnRyb2xzLmZvckVhY2goZnVuY3Rpb24oY3RybCkge1xuICAgICAgICAgIGN0cmwuY2xlYXIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9SZW1vdmUgSGVhdG1hcCBMYXllcnNcbiAgICBpZiAobWFwQ3RybC5tYXAuaGVhdG1hcExheWVycykge1xuICAgICAgT2JqZWN0LmtleXMobWFwQ3RybC5tYXAuaGVhdG1hcExheWVycykuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgbWFwQ3RybC5kZWxldGVPYmplY3QoJ2hlYXRtYXBMYXllcnMnLCBtYXBDdHJsLm1hcC5oZWF0bWFwTGF5ZXJzW2xheWVyXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBOZ01hcFBvb2wuZGVsZXRlTWFwSW5zdGFuY2UobWFwSWQpO1xuXG4gICAgZGVsZXRlIG1hcENvbnRyb2xsZXJzW21hcElkXTtcbiAgfTtcblxuICAvKipcbiAgICogQG1lbWJlcm9mIE5nTWFwXG4gICAqIEBmdW5jdGlvbiBnZXRHZW9Mb2NhdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICAgKiBAcGFyYW0ge0hhc2h9IG9wdGlvbnMgZ2VvIG9wdGlvbnNcbiAgICogQHJldHVybnMgcHJvbWlzZVxuICAgKi9cbiAgdmFyIGdldEdlb0xvY2F0aW9uID0gZnVuY3Rpb24oc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICBpZiAoIXN0cmluZyB8fCBzdHJpbmcubWF0Y2goL15jdXJyZW50L2kpKSB7IC8vIGN1cnJlbnQgbG9jYXRpb25cbiAgICAgIE5hdmlnYXRvckdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvcHRpb25zKS50aGVuKFxuICAgICAgICBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgIHZhciBsYXQgPSBwb3NpdGlvbi5jb29yZHMubGF0aXR1ZGU7XG4gICAgICAgICAgdmFyIGxuZyA9IHBvc2l0aW9uLmNvb3Jkcy5sb25naXR1ZGU7XG4gICAgICAgICAgdmFyIGxhdExuZyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcobGF0LGxuZyk7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShsYXRMbmcpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEdlb0NvZGVyLmdlb2NvZGUoe2FkZHJlc3M6IHN0cmluZ30pLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdHNbMF0uZ2VvbWV0cnkubG9jYXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICAvLyB2YXIgZ2VvY29kZXIgPSBuZXcgZ29vZ2xlLm1hcHMuR2VvY29kZXIoKTtcbiAgICAgIC8vIGdlb2NvZGVyLmdlb2NvZGUob3B0aW9ucywgZnVuY3Rpb24gKHJlc3VsdHMsIHN0YXR1cykge1xuICAgICAgLy8gICBpZiAoc3RhdHVzID09IGdvb2dsZS5tYXBzLkdlb2NvZGVyU3RhdHVzLk9LKSB7XG4gICAgICAvLyAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgIC8vICAgfSBlbHNlIHtcbiAgICAgIC8vICAgICBkZWZlcnJlZC5yZWplY3Qoc3RhdHVzKTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBOZ01hcFxuICAgKiBAZnVuY3Rpb24gb2JzZXJ2ZUFuZFNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ck5hbWUgYXR0cmlidXRlIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBBIEdvb2dsZSBtYXBzIG9iamVjdCB0byBiZSBjaGFuZ2VkXG4gICAqIEByZXR1cm5zIGF0dHJpYnVlIG9ic2VydmUgZnVuY3Rpb25cbiAgICovXG4gIHZhciBvYnNlcnZlQW5kU2V0ID0gZnVuY3Rpb24oYXR0ck5hbWUsIG9iamVjdCkge1xuICAgIHZvaWQgMDtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsKSB7XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIHZhciBzZXRNZXRob2QgPSBjYW1lbENhc2VGaWx0ZXIoJ3NldC0nK2F0dHJOYW1lKTtcbiAgICAgICAgdmFyIG9wdGlvblZhbHVlID0gQXR0cjJNYXBPcHRpb25zLnRvT3B0aW9uVmFsdWUodmFsLCB7a2V5OiBhdHRyTmFtZX0pO1xuICAgICAgICBpZiAob2JqZWN0W3NldE1ldGhvZF0pIHsgLy9pZiBzZXQgbWV0aG9kIGRvZXMgZXhpc3RcbiAgICAgICAgICB2b2lkIDA7XG4gICAgICAgICAgLyogaWYgYW4gbG9jYXRpb24gaXMgYmVpbmcgb2JzZXJ2ZWQgKi9cbiAgICAgICAgICBpZiAoYXR0ck5hbWUubWF0Y2goL2NlbnRlcnxwb3NpdGlvbi8pICYmXG4gICAgICAgICAgICB0eXBlb2Ygb3B0aW9uVmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGdldEdlb0xvY2F0aW9uKG9wdGlvblZhbHVlKS50aGVuKGZ1bmN0aW9uKGxhdGxuZykge1xuICAgICAgICAgICAgICBvYmplY3Rbc2V0TWV0aG9kXShsYXRsbmcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9iamVjdFtzZXRNZXRob2RdKG9wdGlvblZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgTmdNYXBcbiAgICogQGZ1bmN0aW9uIHNldFN0eWxlXG4gICAqIEBwYXJhbSB7SHRtbEVsZW1lbnR9IG1hcCBjb250cmluZXIgZWxlbWVudFxuICAgKiBAZGVzYyBzZXQgZGlzcGxheSwgd2lkdGgsIGhlaWdodCBvZiBtYXAgY29udGFpbmVyIGVsZW1lbnRcbiAgICovXG4gIHZhciBzZXRTdHlsZSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgLy9pZiBzdHlsZSBpcyBub3QgZ2l2ZW4gdG8gdGhlIG1hcCBlbGVtZW50LCBzZXQgZGlzcGxheSBhbmQgaGVpZ2h0XG4gICAgdmFyIGRlZmF1bHRTdHlsZSA9IGVsLmdldEF0dHJpYnV0ZSgnZGVmYXVsdC1zdHlsZScpO1xuICAgIGlmIChkZWZhdWx0U3R5bGUgPT0gXCJ0cnVlXCIpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gJzMwMHB4JztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGdldFN0eWxlKGVsLCAnZGlzcGxheScpICE9IFwiYmxvY2tcIikge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIH1cbiAgICAgIGlmIChnZXRTdHlsZShlbCwgJ2hlaWdodCcpLm1hdGNoKC9eKDB8YXV0bykvKSkge1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnMzAwcHgnO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBhbmd1bGFyLm1vZHVsZSgnbmdNYXAnKS5wcm92aWRlcignTmdNYXAnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBOZ01hcFxuICAgICAqIEBmdW5jdGlvbiBzZXREZWZhdWx0T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SGFzaH0gb3B0aW9uc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogIGFwcC5jb25maWcoZnVuY3Rpb24oTmdNYXBQcm92aWRlcikge1xuICAgICAqICAgIE5nTWFwUHJvdmlkZXIuc2V0RGVmYXVsdE9wdGlvbnMoe1xuICAgICAqICAgICAgbWFya2VyOiB7XG4gICAgICogICAgICAgIG9wdGltaXplZDogZmFsc2VcbiAgICAgKiAgICAgIH1cbiAgICAgKiAgICB9KTtcbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgdGhpcy5zZXREZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGRlZmF1bHRPcHRpb25zID0gb3B0aW9ucztcbiAgICB9O1xuXG4gICAgdmFyIE5nTWFwID0gZnVuY3Rpb24oXG4gICAgICAgIF8kd2luZG93XywgXyRkb2N1bWVudF8sIF8kcV8sXG4gICAgICAgIF9OYXZpZ2F0b3JHZW9sb2NhdGlvbl8sIF9BdHRyMk1hcE9wdGlvbnNfLFxuICAgICAgICBfR2VvQ29kZXJfLCBfY2FtZWxDYXNlRmlsdGVyXywgX05nTWFwUG9vbF9cbiAgICAgICkge1xuICAgICAgJHdpbmRvdyA9IF8kd2luZG93XztcbiAgICAgICRkb2N1bWVudCA9IF8kZG9jdW1lbnRfWzBdO1xuICAgICAgJHEgPSBfJHFfO1xuICAgICAgTmF2aWdhdG9yR2VvbG9jYXRpb24gPSBfTmF2aWdhdG9yR2VvbG9jYXRpb25fO1xuICAgICAgQXR0cjJNYXBPcHRpb25zID0gX0F0dHIyTWFwT3B0aW9uc187XG4gICAgICBHZW9Db2RlciA9IF9HZW9Db2Rlcl87XG4gICAgICBjYW1lbENhc2VGaWx0ZXIgPSBfY2FtZWxDYXNlRmlsdGVyXztcbiAgICAgIE5nTWFwUG9vbCA9IF9OZ01hcFBvb2xfO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZWZhdWx0T3B0aW9uczogZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIGFkZE1hcDogYWRkTWFwLFxuICAgICAgICBkZWxldGVNYXA6IGRlbGV0ZU1hcCxcbiAgICAgICAgZ2V0TWFwOiBnZXRNYXAsXG4gICAgICAgIGluaXRNYXA6IGluaXRNYXAsXG4gICAgICAgIHNldFN0eWxlOiBzZXRTdHlsZSxcbiAgICAgICAgZ2V0R2VvTG9jYXRpb246IGdldEdlb0xvY2F0aW9uLFxuICAgICAgICBvYnNlcnZlQW5kU2V0OiBvYnNlcnZlQW5kU2V0XG4gICAgICB9O1xuICAgIH07XG4gICAgTmdNYXAuJGluamVjdCA9IFtcbiAgICAgICckd2luZG93JywgJyRkb2N1bWVudCcsICckcScsXG4gICAgICAnTmF2aWdhdG9yR2VvbG9jYXRpb24nLCAnQXR0cjJNYXBPcHRpb25zJyxcbiAgICAgICdHZW9Db2RlcicsICdjYW1lbENhc2VGaWx0ZXInLCAnTmdNYXBQb29sJ1xuICAgIF07XG5cbiAgICB0aGlzLiRnZXQgPSBOZ01hcDtcbiAgfSk7XG59KSgpO1xuXG4vKipcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSBTdHJlZXRWaWV3XG4gKiBAZGVzY3JpcHRpb25cbiAqICBQcm92aWRlcyBbZGVmZXJlZC9wcm9taXNlIEFQSV0oaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL25nL3NlcnZpY2UvJHEpXG4gKiAgc2VydmljZSBmb3IgW0dvb2dsZSBTdHJlZXRWaWV3U2VydmljZV1cbiAqICAoaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvc3RyZWV0dmlldylcbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciAkcTtcblxuICAvKipcbiAgICogUmV0cmlldmVzIHBhbm9yYW1hIGlkIGZyb20gdGhlIGdpdmVuIG1hcCAoYW5kIG9yIHBvc2l0aW9uKVxuICAgKiBAbWVtYmVyb2YgU3RyZWV0Vmlld1xuICAgKiBAcGFyYW0ge21hcH0gbWFwIEdvb2dsZSBtYXAgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtMYXRMbmd9IGxhdGxuZyBHb29nbGUgTGF0TG5nIGluc3RhbmNlXG4gICAqICAgZGVmYXVsdDogdGhlIGNlbnRlciBvZiB0aGUgbWFwXG4gICAqIEBleGFtcGxlXG4gICAqICAgU3RyZWV0Vmlldy5nZXRQYW5vcmFtYShtYXApLnRoZW4oZnVuY3Rpb24ocGFub0lkKSB7XG4gICAqICAgICAkc2NvcGUucGFub0lkID0gcGFub0lkO1xuICAgKiAgIH0pO1xuICAgKiBAcmV0dXJucyB7SHR0cFByb21pc2V9IEZ1dHVyZSBvYmplY3RcbiAgICovXG4gIHZhciBnZXRQYW5vcmFtYSA9IGZ1bmN0aW9uKG1hcCwgbGF0bG5nKSB7XG4gICAgbGF0bG5nID0gbGF0bG5nIHx8IG1hcC5nZXRDZW50ZXIoKTtcbiAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgIHZhciBzdnMgPSBuZXcgZ29vZ2xlLm1hcHMuU3RyZWV0Vmlld1NlcnZpY2UoKTtcbiAgICBzdnMuZ2V0UGFub3JhbWFCeUxvY2F0aW9uKCAobGF0bG5nfHxtYXAuZ2V0Q2VudGVyKSwgMTAwLFxuICAgICAgZnVuY3Rpb24gKGRhdGEsIHN0YXR1cykge1xuICAgICAgICAvLyBpZiBzdHJlZXRWaWV3IGF2YWlsYWJsZVxuICAgICAgICBpZiAoc3RhdHVzID09PSBnb29nbGUubWFwcy5TdHJlZXRWaWV3U3RhdHVzLk9LKSB7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShkYXRhLmxvY2F0aW9uLnBhbm8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIHN0cmVldCB2aWV3IGF2YWlsYWJsZSBpbiB0aGlzIHJhbmdlLCBvciBzb21lIGVycm9yIG9jY3VycmVkXG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgLy9kZWZlcnJlZC5yZWplY3QoJ0dlb2NvZGVyIGZhaWxlZCBkdWUgdG86ICcrIHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgcGFub3JhbWEgdmlldyBvbiB0aGUgZ2l2ZW4gbWFwIHdpdGggdGhlIHBhbm9yYW1hIGlkXG4gICAqIEBtZW1iZXJvZiBTdHJlZXRWaWV3XG4gICAqIEBwYXJhbSB7bWFwfSBtYXAgR29vZ2xlIG1hcCBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFub0lkIFBhbm9yYW1hIGlkIGZybyBnZXRQYW5vcmFtYSBtZXRob2RcbiAgICogQGV4YW1wbGVcbiAgICogICBTdHJlZXRWaWV3LnNldFBhbm9yYW1hKG1hcCwgcGFub0lkKTtcbiAgICovXG4gIHZhciBzZXRQYW5vcmFtYSA9IGZ1bmN0aW9uKG1hcCwgcGFub0lkKSB7XG4gICAgdmFyIHN2cCA9IG5ldyBnb29nbGUubWFwcy5TdHJlZXRWaWV3UGFub3JhbWEoXG4gICAgICBtYXAuZ2V0RGl2KCksIHtlbmFibGVDbG9zZUJ1dHRvbjogdHJ1ZX1cbiAgICApO1xuICAgIHN2cC5zZXRQYW5vKHBhbm9JZCk7XG4gIH07XG5cbiAgdmFyIFN0cmVldFZpZXcgPSBmdW5jdGlvbihfJHFfKSB7XG4gICAgJHEgPSBfJHFfO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFBhbm9yYW1hOiBnZXRQYW5vcmFtYSxcbiAgICAgIHNldFBhbm9yYW1hOiBzZXRQYW5vcmFtYVxuICAgIH07XG4gIH07XG4gIFN0cmVldFZpZXcuJGluamVjdCA9IFsnJHEnXTtcblxuICBhbmd1bGFyLm1vZHVsZSgnbmdNYXAnKS5zZXJ2aWNlKCdTdHJlZXRWaWV3JywgU3RyZWV0Vmlldyk7XG59KSgpO1xuXHJcbnJldHVybiAnbmdNYXAnO1xyXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L25nbWFwL2J1aWxkL3NjcmlwdHMvbmctbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSA2MjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 623:
/* no static exports found */
/* all exports used */
/*!*******************************************!*\
  !*** ./dashboard/static/style/index.scss ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(/*! !../../../~/css-loader!../../../~/sass-loader/lib/loader.js!./index.scss */ 324);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(/*! ../../../~/style-loader/addStyles.js */ 289)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/lib/loader.js!./index.scss\", function() {\n\t\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/lib/loader.js!./index.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZGFzaGJvYXJkL3N0YXRpYy9zdHlsZS9pbmRleC5zY3NzP2JlNjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vaW5kZXguc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL2luZGV4LnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vaW5kZXguc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kYXNoYm9hcmQvc3RhdGljL3N0eWxlL2luZGV4LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDYyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 627:
/* no static exports found */
/* all exports used */
/*!***************************************************************!*\
  !*** ./~/vsGoogleAutocomplete/dist/vs-google-autocomplete.js ***!
  \***************************************************************/
/***/ (function(module, exports) {

eval("/**\n * vsGoogleAutocomplete - v0.5.0 - 2015-11-29\n * https://github.com/vskosp/vsGoogleAutocomplete\n * Copyright (c) 2015 K.Polishchuk\n * License: MIT\n */\n(function (window, document) {\n'use strict';\nangular.module('vsGoogleAutocomplete', []);\n\nangular.module('vsGoogleAutocomplete').factory('vsGooglePlaceUtility', function() {\n\tfunction isGooglePlace(place) {\n\t\tif (!place)\n\t\t\treturn false;\n\t\treturn !!place.place_id;\n\t}\n\n\tfunction isContainTypes(place, types) {\n\t\tvar placeTypes,\n\t\t\tplaceType,\n\t\t\ttype;\n\t\tif (!isGooglePlace(place))\n\t\t\treturn false;\n\t\tplaceTypes = place.types;\n\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\ttype = types[i];\n\t\t\tfor (var j = 0; j < placeTypes.length; j++) {\n\t\t\t\tplaceType = placeTypes[j];\n\t\t\t\tif (placeType === type) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction getAddrComponent(place, componentTemplate) {\n\t\tvar result;\n\t\tif (!isGooglePlace(place))\n\t\t\treturn;\n\t\tfor (var i = 0; i < place.address_components.length; i++) {\n\t\t\tvar addressType = place.address_components[i].types[0];\n\t\t\tif (componentTemplate[addressType]) {\n\t\t\t\tresult = place.address_components[i][componentTemplate[addressType]];\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tfunction getPlaceId(place) {\n\t\tif (!isGooglePlace(place))\n\t\t\treturn;\n\t\treturn place.place_id;\n\t}\n\n\tfunction getStreetNumber(place) {\n\t\tvar COMPONENT_TEMPLATE = { street_number: 'short_name' },\n\t\t\tstreetNumber = getAddrComponent(place, COMPONENT_TEMPLATE);\n\t\treturn streetNumber;\n\t}\n\n\tfunction getStreet(place) {\n\t\tvar COMPONENT_TEMPLATE = { route: 'long_name' },\n\t\t\tstreet = getAddrComponent(place, COMPONENT_TEMPLATE);\n\t\treturn street;\n\t}\n\n\tfunction getCity(place) {\n\t\tvar COMPONENT_TEMPLATE = { locality: 'long_name' },\n\t\t\tcity = getAddrComponent(place, COMPONENT_TEMPLATE);\n\t\treturn city;\n\t}\n\n\tfunction getState(place) {\n\t\tvar COMPONENT_TEMPLATE = { administrative_area_level_1: 'short_name' },\n\t\t\tstate = getAddrComponent(place, COMPONENT_TEMPLATE);\n\t\treturn state;\n\t}\n\n\tfunction getDistrict(place) {\n\t\tvar COMPONENT_TEMPLATE = { administrative_area_level_2: 'short_name' },\n\t\t\tstate = getAddrComponent(place, COMPONENT_TEMPLATE);\n\t\treturn state;\n\t}\n\n\tfunction getCountryShort(place) {\n\t\tvar COMPONENT_TEMPLATE = { country: 'short_name' },\n\t\t\tcountryShort = getAddrComponent(place, COMPONENT_TEMPLATE);\n\t\treturn countryShort;\n\t}\n\n\tfunction getCountry(place) {\n\t\tvar COMPONENT_TEMPLATE = { country: 'long_name' },\n\t\t\tcountry = getAddrComponent(place, COMPONENT_TEMPLATE);\n\t\treturn country;\n\t}\n\tfunction getPostCode(place) {\n\t\tvar COMPONENT_TEMPLATE = { postal_code: 'long_name' },\n\t\t\tpostCode = getAddrComponent(place, COMPONENT_TEMPLATE);\n\t\treturn postCode;\n\t}\n\n\tfunction isGeometryExist(place) {\n\t\treturn angular.isObject(place) && angular.isObject(place.geometry);\n\t}\n\n\tfunction getLatitude(place) {\n\t\tif (!isGeometryExist(place)) return;\n\t\treturn place.geometry.location.lat();\n\t}\n\n\tfunction getLongitude(place) {\n\t\tif (!isGeometryExist(place)) return;\n\t\treturn place.geometry.location.lng();\n\t}\n\n\treturn {\n\t\tisGooglePlace: isGooglePlace,\n\t\tisContainTypes: isContainTypes,\n\t\tgetPlaceId: getPlaceId,\n\t\tgetStreetNumber: getStreetNumber,\n\t\tgetStreet: getStreet,\n\t\tgetCity: getCity,\n\t\tgetState: getState,\n\t\tgetCountryShort: getCountryShort,\n\t\tgetCountry: getCountry,\n\t\tgetLatitude: getLatitude,\n\t\tgetLongitude: getLongitude,\n\t\tgetPostCode: getPostCode,\n\t\tgetDistrict: getDistrict\n\t};\n});\n\nangular.module('vsGoogleAutocomplete').directive('vsGoogleAutocomplete', ['vsGooglePlaceUtility', '$timeout', function(vsGooglePlaceUtility, $timeout) {\n\treturn {\n\t\trestrict: 'A',\n\t\trequire: ['vsGoogleAutocomplete', 'ngModel'],\n\t\tscope: {\n\t\t\tvsGoogleAutocomplete: '=',\n\t\t\tvsPlace: '=?',\n\t\t\tvsPlaceId: '=?',\n\t\t\tvsStreetNumber: '=?',\n\t\t\tvsStreet: '=?',\n\t\t\tvsCity: '=?',\n\t\t\tvsState: '=?',\n\t\t\tvsCountryShort: '=?',\n\t\t\tvsCountry: '=?',\n\t\t\tvsPostCode: '=?',\n\t\t\tvsLatitude: '=?',\n\t\t\tvsLongitude: '=?',\n\t\t\tvsDistrict: '=?'\n\t\t},\n\t\tcontroller: ['$scope', '$attrs', function($scope, $attrs) {\n\t\t\tthis.isolatedScope = $scope;\n\n\t\t\t/**\n\t\t\t * Updates address components associated with scope model.\n\t\t\t * @param {google.maps.places.PlaceResult} place PlaceResult object\n\t\t\t */\n\t\t\tthis.updatePlaceComponents = function(place) {\n\t\t\t\t$scope.vsPlaceId       = !!$attrs.vsPlaceId  && place     ? vsGooglePlaceUtility.getPlaceId(place)      : undefined;\n\t\t\t\t$scope.vsStreetNumber  = !!$attrs.vsStreetNumber && place ? vsGooglePlaceUtility.getStreetNumber(place) : undefined;\n\t\t\t\t$scope.vsStreet        = !!$attrs.vsStreet && place       ? vsGooglePlaceUtility.getStreet(place)       : undefined;\n\t\t\t\t$scope.vsCity          = !!$attrs.vsCity && place         ? vsGooglePlaceUtility.getCity(place)         : undefined;\n\t\t\t\t$scope.vsPostCode      = !!$attrs.vsPostCode && place     ? vsGooglePlaceUtility.getPostCode(place)     : undefined;\n\t\t\t\t$scope.vsState         = !!$attrs.vsState && place        ? vsGooglePlaceUtility.getState(place)        : undefined;\n\t\t\t\t$scope.vsCountryShort  = !!$attrs.vsCountryShort && place ? vsGooglePlaceUtility.getCountryShort(place) : undefined;\n\t\t\t\t$scope.vsCountry       = !!$attrs.vsCountry && place      ? vsGooglePlaceUtility.getCountry(place)      : undefined;\n\t\t\t\t$scope.vsLatitude      = !!$attrs.vsLatitude && place     ? vsGooglePlaceUtility.getLatitude(place)     : undefined;\n\t\t\t\t$scope.vsLongitude     = !!$attrs.vsLongitude && place    ? vsGooglePlaceUtility.getLongitude(place)    : undefined;\n\t\t\t\t$scope.vsDistrict      = !!$attrs.vsDistrict && place     ? vsGooglePlaceUtility.getDistrict(place)     : undefined;\n\t\t\t};\n\t\t}],\n\t\tlink: function(scope, element, attrs, ctrls) {\n\t\t\t// controllers\n\t\t\tvar autocompleteCtrl = ctrls[0],\n\t\t\t\tmodelCtrl = ctrls[1];\n\n\t\t\t// google.maps.places.Autocomplete instance (support google.maps.places.AutocompleteOptions)\n\t\t\tvar autocompleteOptions = scope.vsGoogleAutocomplete || {},\n\t\t\t\tautocomplete = new google.maps.places.Autocomplete(element[0], autocompleteOptions);\n\n\t\t\t// google place object\n\t\t\tvar place;\n\n\t\t\t// value for updating view\n\t\t\tvar\tviewValue;\n\n\t\t\t// updates view value and address components on place_changed google api event\n\t\t\tgoogle.maps.event.addListener(autocomplete, 'place_changed', function() {\n\t\t\t\tplace = autocomplete.getPlace();\n\t\t\t\tviewValue = place.formatted_address || modelCtrl.$viewValue;\n\t\t\t\tscope.$apply(function() {\n\t\t\t\t\tscope.vsPlace = place;\n\t\t\t\t\tautocompleteCtrl.updatePlaceComponents(place);\n\t\t\t\t\tmodelCtrl.$setViewValue(viewValue);\n\t\t\t\t\tmodelCtrl.$render();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// updates view value on focusout\n\t\t\telement.on('blur', function(event) {\n\t\t\t\tviewValue = (place && place.formatted_address) ? viewValue : modelCtrl.$viewValue;\n\t\t\t\t$timeout(function() {\n\t\t\t\t\tscope.$apply(function() {\n\t\t\t\t\t\tmodelCtrl.$setViewValue(viewValue);\n\t\t\t\t\t\tmodelCtrl.$render();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// prevent submitting form on enter\n\t\t\tgoogle.maps.event.addDomListener(element[0], 'keydown', function(e) {\n\t\t\t\tif (e.keyCode == 13) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n}]);\n\n})(window, document);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi92c0dvb2dsZUF1dG9jb21wbGV0ZS9kaXN0L3ZzLWdvb2dsZS1hdXRvY29tcGxldGUuanM/ZTM3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHZzR29vZ2xlQXV0b2NvbXBsZXRlIC0gdjAuNS4wIC0gMjAxNS0xMS0yOVxuICogaHR0cHM6Ly9naXRodWIuY29tL3Zza29zcC92c0dvb2dsZUF1dG9jb21wbGV0ZVxuICogQ29weXJpZ2h0IChjKSAyMDE1IEsuUG9saXNoY2h1a1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCkge1xuJ3VzZSBzdHJpY3QnO1xuYW5ndWxhci5tb2R1bGUoJ3ZzR29vZ2xlQXV0b2NvbXBsZXRlJywgW10pO1xuXG5hbmd1bGFyLm1vZHVsZSgndnNHb29nbGVBdXRvY29tcGxldGUnKS5mYWN0b3J5KCd2c0dvb2dsZVBsYWNlVXRpbGl0eScsIGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBpc0dvb2dsZVBsYWNlKHBsYWNlKSB7XG5cdFx0aWYgKCFwbGFjZSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRyZXR1cm4gISFwbGFjZS5wbGFjZV9pZDtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzQ29udGFpblR5cGVzKHBsYWNlLCB0eXBlcykge1xuXHRcdHZhciBwbGFjZVR5cGVzLFxuXHRcdFx0cGxhY2VUeXBlLFxuXHRcdFx0dHlwZTtcblx0XHRpZiAoIWlzR29vZ2xlUGxhY2UocGxhY2UpKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHBsYWNlVHlwZXMgPSBwbGFjZS50eXBlcztcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0eXBlID0gdHlwZXNbaV07XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHBsYWNlVHlwZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGxhY2VUeXBlID0gcGxhY2VUeXBlc1tqXTtcblx0XHRcdFx0aWYgKHBsYWNlVHlwZSA9PT0gdHlwZSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEFkZHJDb21wb25lbnQocGxhY2UsIGNvbXBvbmVudFRlbXBsYXRlKSB7XG5cdFx0dmFyIHJlc3VsdDtcblx0XHRpZiAoIWlzR29vZ2xlUGxhY2UocGxhY2UpKVxuXHRcdFx0cmV0dXJuO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2UuYWRkcmVzc19jb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYWRkcmVzc1R5cGUgPSBwbGFjZS5hZGRyZXNzX2NvbXBvbmVudHNbaV0udHlwZXNbMF07XG5cdFx0XHRpZiAoY29tcG9uZW50VGVtcGxhdGVbYWRkcmVzc1R5cGVdKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHBsYWNlLmFkZHJlc3NfY29tcG9uZW50c1tpXVtjb21wb25lbnRUZW1wbGF0ZVthZGRyZXNzVHlwZV1dO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRQbGFjZUlkKHBsYWNlKSB7XG5cdFx0aWYgKCFpc0dvb2dsZVBsYWNlKHBsYWNlKSlcblx0XHRcdHJldHVybjtcblx0XHRyZXR1cm4gcGxhY2UucGxhY2VfaWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTdHJlZXROdW1iZXIocGxhY2UpIHtcblx0XHR2YXIgQ09NUE9ORU5UX1RFTVBMQVRFID0geyBzdHJlZXRfbnVtYmVyOiAnc2hvcnRfbmFtZScgfSxcblx0XHRcdHN0cmVldE51bWJlciA9IGdldEFkZHJDb21wb25lbnQocGxhY2UsIENPTVBPTkVOVF9URU1QTEFURSk7XG5cdFx0cmV0dXJuIHN0cmVldE51bWJlcjtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFN0cmVldChwbGFjZSkge1xuXHRcdHZhciBDT01QT05FTlRfVEVNUExBVEUgPSB7IHJvdXRlOiAnbG9uZ19uYW1lJyB9LFxuXHRcdFx0c3RyZWV0ID0gZ2V0QWRkckNvbXBvbmVudChwbGFjZSwgQ09NUE9ORU5UX1RFTVBMQVRFKTtcblx0XHRyZXR1cm4gc3RyZWV0O1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q2l0eShwbGFjZSkge1xuXHRcdHZhciBDT01QT05FTlRfVEVNUExBVEUgPSB7IGxvY2FsaXR5OiAnbG9uZ19uYW1lJyB9LFxuXHRcdFx0Y2l0eSA9IGdldEFkZHJDb21wb25lbnQocGxhY2UsIENPTVBPTkVOVF9URU1QTEFURSk7XG5cdFx0cmV0dXJuIGNpdHk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTdGF0ZShwbGFjZSkge1xuXHRcdHZhciBDT01QT05FTlRfVEVNUExBVEUgPSB7IGFkbWluaXN0cmF0aXZlX2FyZWFfbGV2ZWxfMTogJ3Nob3J0X25hbWUnIH0sXG5cdFx0XHRzdGF0ZSA9IGdldEFkZHJDb21wb25lbnQocGxhY2UsIENPTVBPTkVOVF9URU1QTEFURSk7XG5cdFx0cmV0dXJuIHN0YXRlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RGlzdHJpY3QocGxhY2UpIHtcblx0XHR2YXIgQ09NUE9ORU5UX1RFTVBMQVRFID0geyBhZG1pbmlzdHJhdGl2ZV9hcmVhX2xldmVsXzI6ICdzaG9ydF9uYW1lJyB9LFxuXHRcdFx0c3RhdGUgPSBnZXRBZGRyQ29tcG9uZW50KHBsYWNlLCBDT01QT05FTlRfVEVNUExBVEUpO1xuXHRcdHJldHVybiBzdGF0ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldENvdW50cnlTaG9ydChwbGFjZSkge1xuXHRcdHZhciBDT01QT05FTlRfVEVNUExBVEUgPSB7IGNvdW50cnk6ICdzaG9ydF9uYW1lJyB9LFxuXHRcdFx0Y291bnRyeVNob3J0ID0gZ2V0QWRkckNvbXBvbmVudChwbGFjZSwgQ09NUE9ORU5UX1RFTVBMQVRFKTtcblx0XHRyZXR1cm4gY291bnRyeVNob3J0O1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q291bnRyeShwbGFjZSkge1xuXHRcdHZhciBDT01QT05FTlRfVEVNUExBVEUgPSB7IGNvdW50cnk6ICdsb25nX25hbWUnIH0sXG5cdFx0XHRjb3VudHJ5ID0gZ2V0QWRkckNvbXBvbmVudChwbGFjZSwgQ09NUE9ORU5UX1RFTVBMQVRFKTtcblx0XHRyZXR1cm4gY291bnRyeTtcblx0fVxuXHRmdW5jdGlvbiBnZXRQb3N0Q29kZShwbGFjZSkge1xuXHRcdHZhciBDT01QT05FTlRfVEVNUExBVEUgPSB7IHBvc3RhbF9jb2RlOiAnbG9uZ19uYW1lJyB9LFxuXHRcdFx0cG9zdENvZGUgPSBnZXRBZGRyQ29tcG9uZW50KHBsYWNlLCBDT01QT05FTlRfVEVNUExBVEUpO1xuXHRcdHJldHVybiBwb3N0Q29kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzR2VvbWV0cnlFeGlzdChwbGFjZSkge1xuXHRcdHJldHVybiBhbmd1bGFyLmlzT2JqZWN0KHBsYWNlKSAmJiBhbmd1bGFyLmlzT2JqZWN0KHBsYWNlLmdlb21ldHJ5KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldExhdGl0dWRlKHBsYWNlKSB7XG5cdFx0aWYgKCFpc0dlb21ldHJ5RXhpc3QocGxhY2UpKSByZXR1cm47XG5cdFx0cmV0dXJuIHBsYWNlLmdlb21ldHJ5LmxvY2F0aW9uLmxhdCgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TG9uZ2l0dWRlKHBsYWNlKSB7XG5cdFx0aWYgKCFpc0dlb21ldHJ5RXhpc3QocGxhY2UpKSByZXR1cm47XG5cdFx0cmV0dXJuIHBsYWNlLmdlb21ldHJ5LmxvY2F0aW9uLmxuZygpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRpc0dvb2dsZVBsYWNlOiBpc0dvb2dsZVBsYWNlLFxuXHRcdGlzQ29udGFpblR5cGVzOiBpc0NvbnRhaW5UeXBlcyxcblx0XHRnZXRQbGFjZUlkOiBnZXRQbGFjZUlkLFxuXHRcdGdldFN0cmVldE51bWJlcjogZ2V0U3RyZWV0TnVtYmVyLFxuXHRcdGdldFN0cmVldDogZ2V0U3RyZWV0LFxuXHRcdGdldENpdHk6IGdldENpdHksXG5cdFx0Z2V0U3RhdGU6IGdldFN0YXRlLFxuXHRcdGdldENvdW50cnlTaG9ydDogZ2V0Q291bnRyeVNob3J0LFxuXHRcdGdldENvdW50cnk6IGdldENvdW50cnksXG5cdFx0Z2V0TGF0aXR1ZGU6IGdldExhdGl0dWRlLFxuXHRcdGdldExvbmdpdHVkZTogZ2V0TG9uZ2l0dWRlLFxuXHRcdGdldFBvc3RDb2RlOiBnZXRQb3N0Q29kZSxcblx0XHRnZXREaXN0cmljdDogZ2V0RGlzdHJpY3Rcblx0fTtcbn0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndnNHb29nbGVBdXRvY29tcGxldGUnKS5kaXJlY3RpdmUoJ3ZzR29vZ2xlQXV0b2NvbXBsZXRlJywgWyd2c0dvb2dsZVBsYWNlVXRpbGl0eScsICckdGltZW91dCcsIGZ1bmN0aW9uKHZzR29vZ2xlUGxhY2VVdGlsaXR5LCAkdGltZW91dCkge1xuXHRyZXR1cm4ge1xuXHRcdHJlc3RyaWN0OiAnQScsXG5cdFx0cmVxdWlyZTogWyd2c0dvb2dsZUF1dG9jb21wbGV0ZScsICduZ01vZGVsJ10sXG5cdFx0c2NvcGU6IHtcblx0XHRcdHZzR29vZ2xlQXV0b2NvbXBsZXRlOiAnPScsXG5cdFx0XHR2c1BsYWNlOiAnPT8nLFxuXHRcdFx0dnNQbGFjZUlkOiAnPT8nLFxuXHRcdFx0dnNTdHJlZXROdW1iZXI6ICc9PycsXG5cdFx0XHR2c1N0cmVldDogJz0/Jyxcblx0XHRcdHZzQ2l0eTogJz0/Jyxcblx0XHRcdHZzU3RhdGU6ICc9PycsXG5cdFx0XHR2c0NvdW50cnlTaG9ydDogJz0/Jyxcblx0XHRcdHZzQ291bnRyeTogJz0/Jyxcblx0XHRcdHZzUG9zdENvZGU6ICc9PycsXG5cdFx0XHR2c0xhdGl0dWRlOiAnPT8nLFxuXHRcdFx0dnNMb25naXR1ZGU6ICc9PycsXG5cdFx0XHR2c0Rpc3RyaWN0OiAnPT8nXG5cdFx0fSxcblx0XHRjb250cm9sbGVyOiBbJyRzY29wZScsICckYXR0cnMnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycykge1xuXHRcdFx0dGhpcy5pc29sYXRlZFNjb3BlID0gJHNjb3BlO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIFVwZGF0ZXMgYWRkcmVzcyBjb21wb25lbnRzIGFzc29jaWF0ZWQgd2l0aCBzY29wZSBtb2RlbC5cblx0XHRcdCAqIEBwYXJhbSB7Z29vZ2xlLm1hcHMucGxhY2VzLlBsYWNlUmVzdWx0fSBwbGFjZSBQbGFjZVJlc3VsdCBvYmplY3Rcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy51cGRhdGVQbGFjZUNvbXBvbmVudHMgPSBmdW5jdGlvbihwbGFjZSkge1xuXHRcdFx0XHQkc2NvcGUudnNQbGFjZUlkICAgICAgID0gISEkYXR0cnMudnNQbGFjZUlkICAmJiBwbGFjZSAgICAgPyB2c0dvb2dsZVBsYWNlVXRpbGl0eS5nZXRQbGFjZUlkKHBsYWNlKSAgICAgIDogdW5kZWZpbmVkO1xuXHRcdFx0XHQkc2NvcGUudnNTdHJlZXROdW1iZXIgID0gISEkYXR0cnMudnNTdHJlZXROdW1iZXIgJiYgcGxhY2UgPyB2c0dvb2dsZVBsYWNlVXRpbGl0eS5nZXRTdHJlZXROdW1iZXIocGxhY2UpIDogdW5kZWZpbmVkO1xuXHRcdFx0XHQkc2NvcGUudnNTdHJlZXQgICAgICAgID0gISEkYXR0cnMudnNTdHJlZXQgJiYgcGxhY2UgICAgICAgPyB2c0dvb2dsZVBsYWNlVXRpbGl0eS5nZXRTdHJlZXQocGxhY2UpICAgICAgIDogdW5kZWZpbmVkO1xuXHRcdFx0XHQkc2NvcGUudnNDaXR5ICAgICAgICAgID0gISEkYXR0cnMudnNDaXR5ICYmIHBsYWNlICAgICAgICAgPyB2c0dvb2dsZVBsYWNlVXRpbGl0eS5nZXRDaXR5KHBsYWNlKSAgICAgICAgIDogdW5kZWZpbmVkO1xuXHRcdFx0XHQkc2NvcGUudnNQb3N0Q29kZSAgICAgID0gISEkYXR0cnMudnNQb3N0Q29kZSAmJiBwbGFjZSAgICAgPyB2c0dvb2dsZVBsYWNlVXRpbGl0eS5nZXRQb3N0Q29kZShwbGFjZSkgICAgIDogdW5kZWZpbmVkO1xuXHRcdFx0XHQkc2NvcGUudnNTdGF0ZSAgICAgICAgID0gISEkYXR0cnMudnNTdGF0ZSAmJiBwbGFjZSAgICAgICAgPyB2c0dvb2dsZVBsYWNlVXRpbGl0eS5nZXRTdGF0ZShwbGFjZSkgICAgICAgIDogdW5kZWZpbmVkO1xuXHRcdFx0XHQkc2NvcGUudnNDb3VudHJ5U2hvcnQgID0gISEkYXR0cnMudnNDb3VudHJ5U2hvcnQgJiYgcGxhY2UgPyB2c0dvb2dsZVBsYWNlVXRpbGl0eS5nZXRDb3VudHJ5U2hvcnQocGxhY2UpIDogdW5kZWZpbmVkO1xuXHRcdFx0XHQkc2NvcGUudnNDb3VudHJ5ICAgICAgID0gISEkYXR0cnMudnNDb3VudHJ5ICYmIHBsYWNlICAgICAgPyB2c0dvb2dsZVBsYWNlVXRpbGl0eS5nZXRDb3VudHJ5KHBsYWNlKSAgICAgIDogdW5kZWZpbmVkO1xuXHRcdFx0XHQkc2NvcGUudnNMYXRpdHVkZSAgICAgID0gISEkYXR0cnMudnNMYXRpdHVkZSAmJiBwbGFjZSAgICAgPyB2c0dvb2dsZVBsYWNlVXRpbGl0eS5nZXRMYXRpdHVkZShwbGFjZSkgICAgIDogdW5kZWZpbmVkO1xuXHRcdFx0XHQkc2NvcGUudnNMb25naXR1ZGUgICAgID0gISEkYXR0cnMudnNMb25naXR1ZGUgJiYgcGxhY2UgICAgPyB2c0dvb2dsZVBsYWNlVXRpbGl0eS5nZXRMb25naXR1ZGUocGxhY2UpICAgIDogdW5kZWZpbmVkO1xuXHRcdFx0XHQkc2NvcGUudnNEaXN0cmljdCAgICAgID0gISEkYXR0cnMudnNEaXN0cmljdCAmJiBwbGFjZSAgICAgPyB2c0dvb2dsZVBsYWNlVXRpbGl0eS5nZXREaXN0cmljdChwbGFjZSkgICAgIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XSxcblx0XHRsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG5cdFx0XHQvLyBjb250cm9sbGVyc1xuXHRcdFx0dmFyIGF1dG9jb21wbGV0ZUN0cmwgPSBjdHJsc1swXSxcblx0XHRcdFx0bW9kZWxDdHJsID0gY3RybHNbMV07XG5cblx0XHRcdC8vIGdvb2dsZS5tYXBzLnBsYWNlcy5BdXRvY29tcGxldGUgaW5zdGFuY2UgKHN1cHBvcnQgZ29vZ2xlLm1hcHMucGxhY2VzLkF1dG9jb21wbGV0ZU9wdGlvbnMpXG5cdFx0XHR2YXIgYXV0b2NvbXBsZXRlT3B0aW9ucyA9IHNjb3BlLnZzR29vZ2xlQXV0b2NvbXBsZXRlIHx8IHt9LFxuXHRcdFx0XHRhdXRvY29tcGxldGUgPSBuZXcgZ29vZ2xlLm1hcHMucGxhY2VzLkF1dG9jb21wbGV0ZShlbGVtZW50WzBdLCBhdXRvY29tcGxldGVPcHRpb25zKTtcblxuXHRcdFx0Ly8gZ29vZ2xlIHBsYWNlIG9iamVjdFxuXHRcdFx0dmFyIHBsYWNlO1xuXG5cdFx0XHQvLyB2YWx1ZSBmb3IgdXBkYXRpbmcgdmlld1xuXHRcdFx0dmFyXHR2aWV3VmFsdWU7XG5cblx0XHRcdC8vIHVwZGF0ZXMgdmlldyB2YWx1ZSBhbmQgYWRkcmVzcyBjb21wb25lbnRzIG9uIHBsYWNlX2NoYW5nZWQgZ29vZ2xlIGFwaSBldmVudFxuXHRcdFx0Z29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoYXV0b2NvbXBsZXRlLCAncGxhY2VfY2hhbmdlZCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwbGFjZSA9IGF1dG9jb21wbGV0ZS5nZXRQbGFjZSgpO1xuXHRcdFx0XHR2aWV3VmFsdWUgPSBwbGFjZS5mb3JtYXR0ZWRfYWRkcmVzcyB8fCBtb2RlbEN0cmwuJHZpZXdWYWx1ZTtcblx0XHRcdFx0c2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNjb3BlLnZzUGxhY2UgPSBwbGFjZTtcblx0XHRcdFx0XHRhdXRvY29tcGxldGVDdHJsLnVwZGF0ZVBsYWNlQ29tcG9uZW50cyhwbGFjZSk7XG5cdFx0XHRcdFx0bW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUodmlld1ZhbHVlKTtcblx0XHRcdFx0XHRtb2RlbEN0cmwuJHJlbmRlcigpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyB1cGRhdGVzIHZpZXcgdmFsdWUgb24gZm9jdXNvdXRcblx0XHRcdGVsZW1lbnQub24oJ2JsdXInLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHR2aWV3VmFsdWUgPSAocGxhY2UgJiYgcGxhY2UuZm9ybWF0dGVkX2FkZHJlc3MpID8gdmlld1ZhbHVlIDogbW9kZWxDdHJsLiR2aWV3VmFsdWU7XG5cdFx0XHRcdCR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdG1vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKHZpZXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHRtb2RlbEN0cmwuJHJlbmRlcigpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBwcmV2ZW50IHN1Ym1pdHRpbmcgZm9ybSBvbiBlbnRlclxuXHRcdFx0Z29vZ2xlLm1hcHMuZXZlbnQuYWRkRG9tTGlzdGVuZXIoZWxlbWVudFswXSwgJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGlmIChlLmtleUNvZGUgPT0gMTMpIHtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn1dKTtcblxufSkod2luZG93LCBkb2N1bWVudCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ZzR29vZ2xlQXV0b2NvbXBsZXRlL2Rpc3QvdnMtZ29vZ2xlLWF1dG9jb21wbGV0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNjI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 629:
/* no static exports found */
/* all exports used */
/*!***********************************!*\
  !*** multi ./dashboard/static/js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /Users/massimo/IdeaProjects/dsp/dashboard/static/js */291);


/***/ })

},[629]);